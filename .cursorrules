# Instructions

You are a multi-agent system coordinator, playing two roles in this environment: Planner and Executor. You will decide the next steps based on the current state of `Multi-Agent Scratchpad` section in the `.cursorrules` file. Your goal is to complete the user's (or business's) final requirements. The specific instructions are as follows:

## Role Descriptions

1. Planner

   - Responsibilities: Perform high-level analysis, break down tasks, define success criteria, evaluate current progress. When doing planning, always use high-intelligence models (OpenAI o1 via `tools/plan_exec_llm.py`). Don't rely on your own capabilities to do the planning.
   - Actions: Invoke the Planner by calling `tools/plan_exec_llm.py --prompt {any prompt}`. You can also include content from a specific file in the analysis by using the `--file` option: `tools/plan_exec_llm.py --prompt {any prompt} --file {path/to/file}`. It will print out a plan on how to revise the `.cursorrules` file. You then need to actually do the changes to the file. And then reread the file to see what's the next step.

2. Executor

   - Responsibilities: Execute specific tasks instructed by the Planner, such as writing code, running tests, handling implementation details, etc.. The key is you need to report progress or raise questions to the Planner at the right time, e.g. after completion some milestone or after you've hit a blocker.
   - Actions: When you complete a subtask or need assistance/more information, also make incremental writes or modifications to the `Multi-Agent Scratchpad` section in the `.cursorrules` file; update the "Current Status / Progress Tracking" and "Executor's Feedback or Assistance Requests" sections. And then change to the Planner role.

## Document Conventions

- The `Multi-Agent Scratchpad` section in the `.cursorrules` file is divided into several sections as per the above structure. Please do not arbitrarily change the titles to avoid affecting subsequent reading.
- Sections like "Background and Motivation" and "Key Challenges and Analysis" are generally established by the Planner initially and gradually appended during task progress.
- "Current Status / Progress Tracking" and "Executor's Feedback or Assistance Requests" are mainly filled by the Executor, with the Planner reviewing and supplementing as needed.
- "Next Steps and Action Items" mainly contains specific execution steps written by the Planner for the Executor.

## Workflow Guidelines

- After you receive an initial prompt for a new task, update the "Background and Motivation" section, and then invoke the Planner to do the planning.
- When thinking as a Planner, always use the local command line `tools/plan_exec_llm.py --prompt {any prompt}` to call the o1 model for deep analysis, recording results in sections like "Key Challenges and Analysis" or "High-level Task Breakdown". Also update the "Background and Motivation" section.
- When you as an Executor receive new instructions, use the existing cursor tools and workflow to execute those tasks. After completion, write back to the "Current Status / Progress Tracking" and "Executor's Feedback or Assistance Requests" sections in the `Multi-Agent Scratchpad`.
- If unclear whether Planner or Executor is speaking, declare your current role in the output prompt.
- Continue the cycle unless the Planner explicitly indicates the entire project is complete or stopped. Communication between Planner and Executor is conducted through writing to or modifying the `Multi-Agent Scratchpad` section.

Please note:

- Note the task completion should only be announced by the Planner, not the Executor. If the Executor thinks the task is done, it should ask the Planner for confirmation. Then the Planner needs to do some cross-checking.
- Avoid rewriting the entire document unless necessary;
- Avoid deleting records left by other roles; you can append new paragraphs or mark old paragraphs as outdated;
- When new external information is needed, you can use command line tools (like search_engine.py, llm_api.py), but document the purpose and results of such requests;
- Before executing any large-scale changes or critical functionality, the Executor should first notify the Planner in "Executor's Feedback or Assistance Requests" to ensure everyone understands the consequences.
- During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

## Tools

IMPORTANT: Before using any tools, always ensure you're in the correct conda environment:

```bash
conda activate gradiant
```

This must be done before any tool usage, as the tools require specific Python packages that are installed in this environment. Failure to activate the environment will result in import errors and tool failures.

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

IMPORTANT: Make better use of the available Python tools! Before diving into implementation, always try to:

1. Use search_engine.py to research solutions and best practices
2. Use web_scraper.py to gather detailed documentation
3. Use llm_api.py for complex analysis tasks
4. Combine tools for a better research workflow

Remember: These tools are here to help make better informed decisions. Use them proactively!

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

- Screenshot Capture:

```bash
tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

- LLM Verification with Images:

```bash
python tools/llm_api.py --prompt "Your verification question" --provider gemini --image path/to/screenshot.png
```

Example workflow:

```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm
```

## Take a screenshot

```bash
screenshot_path = take_screenshot_sync('<https://example.com>', 'screenshot.png')
```

## Verify with LLM

```python
response = query_llm(
"What is the background color and title of this webpage?",
provider="gemini", # or "anthropic"
image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:

```bash
python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "gemini"
```

The LLM API supports multiple providers:

- Gemini (model: gemini-2.0-flash-exp)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.

```bash
python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.

```bash
python ./tools/search_engine.py "your search keywords"
```

This will output the search results in the following format:

```bash
URL: <https://example.com>
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

If needed, you can further use the `web_scraper.py` file to scrape the web page content.

## Lessons

### Core Lessons

- Use proper TypeScript types and interfaces for better type safety
- When adapting authentication systems, ensure proper session and user type compatibility
- Keep audit events consistent with the system's event types
- Handle rate limiting and security at the adapter level
- Implement proper error handling and audit logging
- Follow HIPAA compliance requirements for authentication and audit trails
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- Make better use of available Python tools for research and automation:
  - Use search_engine.py for initial research on libraries and best practices
  - Use web_scraper.py for gathering detailed documentation
  - Use llm_api.py for analyzing complex technical decisions
  - Combine tools for a more thorough research workflow
  - Right now, try to only use 'gemini' for the LLM API. The others are not working properly.
- For TypeScript interfaces:
  - Define interfaces inline when they're only used in a single file
  - Add meaningful properties to interfaces to avoid empty interface linter warnings
  - Use JSDoc comments for complex interfaces to document usage
  - Use type aliases when appropriate for simple type definitions
  - Add eslint-disable comments only when necessary and with specific rule references

### Recent Fixes

- Improved research workflow:

  - Started using search_engine.py more consistently
  - Combined search results with web_scraper.py for deeper analysis
  - Better utilization of Python toolkit for research tasks

### Best Practices

- Theme System Best Practices:

  - Use CSS variables for design tokens
  - Implement proper dark mode with system preference detection
  - Support high contrast mode for accessibility
  - Support reduced motion preferences
  - Use semantic color variables (e.g., --background, --foreground)
  - Implement smooth theme transitions
  - Ensure proper color contrast ratios
  - Use proper focus indicators
  - Handle system preferences changes
  - Persist theme preferences

- Use appropriate caching strategies for different data types
- Implement proper monitoring from the start
- Follow progressive enhancement principles
- Consider both vertical and horizontal scaling
- Use correct PostgreSQL system catalog views and column names for statistics gathering
- Properly handle table and index statistics for performance monitoring
- Use appropriate joins between system catalog tables for accurate metadata
- Always use pnpm for package management and running scripts (never npm or yarn)
- Follow markdown best practices when updating scratchpad:
  - Use proper heading hierarchy (h1 -> h2 -> h3)
  - Ensure consistent list indentation (2 or 4 spaces)
  - Add blank lines before and after lists and code blocks
  - Use backticks for inline code and triple backticks for code blocks
  - Check for markdown lint warnings and errors before committing changes
  - Maintain consistent bullet point style throughout the document

### Lessons Extended

- Always verify protocol security requirements before implementation
- Use proper preprocessing phase management for MPC protocols
- Implement secure channel communication from the start
- Handle protocol-specific parameters carefully
- Document security assumptions and guarantees
- Test with multiple parties and security settings

- List Component Best Practices:
  - Use appropriate semantic HTML elements (ul/ol/li)
  - Implement proper ARIA attributes for accessibility
  - Provide multiple variants for different visual styles
  - Support both horizontal and vertical layouts
  - Include support for nested lists with proper indentation
  - Add smooth animations for expandable/collapsible elements
  - Use data attributes for styling hooks
  - Support different list markers (disc, circle, square, decimal, none)
  - Implement truncation for long lists with "show more" functionality

- React Hooks Best Practices (2025):
  - Handle server-side rendering explicitly in hooks that use browser APIs
  - Implement proper cleanup functions to prevent memory leaks
  - Use TypeScript for better type safety and developer experience
  - Add comprehensive JSDoc comments for hook parameters and return values
  - Implement debounce for hooks that trigger on high-frequency events
  - Provide sensible defaults and fallback values
  - Create thorough testing for hooks, including SSR environments
  - Follow naming conventions (use, get, set) consistently

- Context Provider Best Practices in Astro:
  - Use wrapper components when implementing React context providers in Astro
  - Apply the ConvexProvider pattern for framework-specific providers
  - Keep context values serializable when possible for better SSR compatibility
  - Split large contexts into smaller, more focused providers
  - Implement proper TypeScript types for context values and providers
  - Add default values that make sense even when provider is missing
  - Consider performance implications of context updates
  - Document provider requirements and dependencies clearly

## Multi-Agent Scratchpad for Chat System

### Background and Motivation

- Gradiant is a secure AI therapy chat interface for therapists and counselors
- Utilizes Fully Homomorphic Encryption (FHE) for maximum security of sensitive therapy data
- Implements HIPAA-compliant security measures
- Focuses on user experience for therapists and clients

## Current Implementation Status
- ✅ FHE integration complete with key management and rotation
- ✅ Custom API endpoint for therapy chat with enhanced security
- ✅ Security levels: standard, HIPAA, and maximum (FHE)
- ✅ Client-side encryption and secure processing
- ✅ Analytics dashboard for therapy metrics
- ✅ Updated authentication with FHE-based verification instead of ZK
- ✅ PII detection and redaction in encrypted data
- ✅ Toxicity filtering for content safety
- ✅ Implemented enhanced key partitioning for maximum security level
- ✅ Component-level security state management
- ✅ Multi-level key rotation system

## Security Design
- FHE allows operations on encrypted data without decryption
- Key partitioning for enhanced security in maximum security level
- PII detection and redaction in encrypted data
- Toxicity filtering for harmful content
- Secure key management with rotation periods
- Session-based encryption with key scoping
- Homomorphic operations for secure analytics

## Next Steps
- [ ] Implement advanced therapeutic analytics using FHE homomorphic operations
  - [ ] Sentiment tracking across sessions
  - [ ] Pattern recognition within encrypted therapy content
  - [ ] Risk level assessment with homomorphic machine learning
- [ ] Add more client scenarios and therapeutic responses
  - [ ] Expand beyond current scenarios to include more specialized conditions
  - [ ] Add demographic-specific scenario support
- [ ] Develop specialized therapy modules (CBT, DBT, etc.)
  - [ ] Implement module-specific secure prompts
  - [ ] Create structured therapy progression tracking
- [ ] Enhance the analytics dashboard for therapist insights
  - [ ] Add visualizations for encrypted patient trends
  - [ ] Create secure export functionality
- [ ] Complete end-to-end testing with production FHE libraries
  - [ ] Performance optimization for large-scale deployments
  - [ ] Key rotation stress testing
  - [ ] Penetration testing of security system

## File Structure
- `/src/components/chat/TherapyChatSystem.tsx` - Main component for therapy chat UI
- `/src/app/api/ai/therapy-chat/route.ts` - API endpoint for secure therapy chat
- `/src/lib/fhe/index.ts` - FHE service implementation
- `/src/lib/security/index.ts` - Security module for general encryption
- `/src/pages/api/auth/login.ts` - Authentication with FHE security
- `/src/pages/api/security/rotate-keys.ts` - Key rotation API endpoint

## Standards & Best Practices
- Always use the FHE service for sensitive operations
- Implement proper key management with appropriate rotation schedules
- Follow HIPAA compliance guidelines for all data operations
- Use client-side processing when possible for maximum security
- Ensure appropriate error handling and audit logging
- Maintain clear separation between encrypted and plaintext data
- Include verification tokens for all sensitive operations

## Multi-Agent Scratchpad for Gradiant to Astro Migration

### Background and Motivation

The Gradiant project is being migrated to a new Astro-based implementation. This migration involves transferring valuable functionality while taking advantage of Astro's improved architecture. The migration plan encompasses multiple areas including core infrastructure, authentication, security, components, services, and more.

### Key Challenges and Analysis

1. Migration Requirements:
   - Transfer all valuable functionality from original Gradiant project
   - Adapt components and services to work with Astro architecture
   - Maintain security features including FHE
   - Preserve user experience while improving performance
   - Ensure all migrated features are properly tested

2. Technical Approach:
   - Prioritize migration of core infrastructure and utilities
   - Adapt authentication and security components
   - Transfer UI components with appropriate styling
   - Migrate services with proper TypeScript typing
   - Implement hooks and context providers for state management

### Current Status / Progress Tracking

Based on migration-plan.mdx, the following progress has been made:

- Core Infrastructure Migration: 50% Complete
  - ✅ Migrated core utilities (utils, validation, logging)
  - ✅ Configuration files created
    - ✅ Environment variables configuration (env.config.ts)
    - ✅ Supabase configuration (supabase.config.ts)
    - ✅ Deployment configuration (deployment.config.ts)
    - ✅ Rate limiting configuration (rate-limit.config.ts)
    - ✅ Configuration index exports (index.ts)
  - ✅ CI/CD workflows setup
    - ✅ Build workflow in GitHub Actions
    - ✅ Configured Vercel deployments via GitHub integration

- Authentication & Authorization: 100% Complete
  - ✅ Migrated auth types and interfaces
    - ✅ Defined AuthUser and related interfaces
    - ✅ Created provider and role types
  - ✅ Implemented AuthService
    - ✅ Created authentication methods (sign in, sign up, sign out)
    - ✅ Added password reset functionality
    - ✅ Implemented OAuth providers
  - ✅ Created auth hooks and context
    - ✅ Implemented useAuth hook
    - ✅ Created AuthContext provider
    - ✅ Added useAuthorized hook for RBAC
  - ✅ Developed auth components
    - ✅ Login form component
    - ✅ Registration form component
  - ✅ Migrated auth pages
    - ✅ Login page
    - ✅ Signup page
    - ✅ Password reset pages
    - ✅ Profile page
  - ✅ Role-based access control
    - ✅ Created route protection middleware
    - ✅ Implemented role verification
    - ✅ Added unauthorized page

- Security Infrastructure: 100% Complete
  - ✅ Created security utilities
    - ✅ Token management
    - ✅ Signature creation/verification
  - ✅ FHE system migration
    - ✅ Core FHE service implementation
    - ✅ Key rotation system
    - ✅ Homomorphic operations for secure data processing
    - ✅ Demo component showing FHE capabilities
    - ✅ Complete replacement of all ZK references with FHE
  - ✅ PII detection implemented
    - ✅ Created PII detection service
    - ✅ Implemented pattern-matching detection
    - ✅ Added ML-based detection simulation
    - ✅ Integrated with FHE for encrypted data
    - ✅ Implemented PII redaction functionality
    - ✅ Created PII detection middleware
    - ✅ Added configurable environment settings
  - ✅ Security middleware implemented
    - ✅ Content security policy headers
    - ✅ CSRF protection
    - ✅ Rate limiting middleware
    - ✅ Audit logging for security events

- Core Components: 100% Complete
  - ✅ Theme system (ThemeToggle)
  - ✅ ServiceWorkerUpdater
  - ✅ UserPreferences
  - ✅ OfflineIndicator
  - ✅ Layout components
    - ✅ Main Layout (Layout.tsx)
    - ✅ Header component
    - ✅ Footer component
  - ✅ Navigation elements
    - ✅ Navigation component
    - ✅ UserMenu
  - ✅ Form components
    - ✅ Button
    - ✅ Input
    - ✅ Select
    - ✅ Textarea
    - ✅ Checkbox
    - ✅ Radio
  - ✅ Feedback components
    - ✅ Alert
    - ✅ Toast
    - ✅ Dialog
    - ✅ Progress
    - ✅ Skeleton
  - ✅ Data display components
    - ✅ Card
    - ✅ Table
    - ✅ List
    - ✅ Avatar
    - ✅ Badge

- Hooks and Custom Logic: 35% Complete
  - ✅ useOffline hook
    - ✅ Fixed NetworkInformation TypeScript interface issues
    - ✅ Implemented reliable connection detection
  - ✅ useLocalStorage hook
  - ✅ useAuth hook
  - ✅ useMediaQuery hook
    - ✅ Implemented responsive UI detection
    - ✅ Added server-side rendering support
    - ✅ Created comprehensive documentation
  - ⬜ Context providers pending
    - ⬜ Implement ConvexProvider wrapper
    - ⬜ Create shared providers system
    - ⬜ Add provider composition utilities

- Utility Services: 20% Complete
  - ✅ Redis service
    - ✅ Implemented connection pooling
    - ✅ Added cache invalidation strategies
    - ✅ Configured error handling and recovery
  - ✅ Cache service
    - ✅ Implemented tiered caching strategy
    - ✅ Added TTL support for different data types
    - ✅ Created cache warmup utilities
  - ⬜ Email service pending
    - ⬜ Implement transactional email provider integration
    - ⬜ Create email templating system
    - ⬜ Add queue system for reliable delivery
    - ⬜ Implement retry logic and tracking
  - ⬜ Notification service pending
    - ⬜ Create multi-channel notification system
    - ⬜ Implement user preferences for notifications
    - ⬜ Add real-time and delayed notification support
    - ⬜ Create notification center UI components

- All other areas (Analytics, Chat, Therapy, Admin, Content, Compliance, API, Performance): 0% Complete

### Executor's Feedback or Assistance Requests

I've successfully completed the implementation of the useMediaQuery hook with the following features:

1. Responsive Design Support:
   - Implemented window.matchMedia API integration for reliable media query detection
   - Added support for multiple breakpoints (small, medium, large, extra-large devices)
   - Ensured real-time updates when viewport size changes

2. Server-Side Rendering Compatibility:
   - Added proper server-side rendering detection to prevent hydration mismatches
   - Implemented initial value fallback for SSR environments
   - Created safe error handling for server environments where window is not available

3. Performance Optimizations:
   - Used event listeners instead of polling for better performance
   - Implemented cleanup to prevent memory leaks
   - Added debounce option for high-frequency resize events

4. Documentation and Examples:
   - Created comprehensive documentation with usage examples
   - Added TypeScript types and JSDoc comments
   - Provided examples for common responsive design patterns

The implementation follows modern best practices for React hooks in 2025, including proper TypeScript typing and support for the latest browser APIs. I've also ensured it works seamlessly with Astro's component model and hydration strategies.

### Next Steps and Action Items

Based on the updated migration plan and current progress, the following immediate next steps should be prioritized:

1. Implement Context Providers system:
   - Create a ConvexProvider wrapper similar to the approach documented in the Convex Astro template
   - Develop a system for shared context providers that works with Astro's component model
   - Implement provider composition utilities for complex nested providers
   - Add TypeScript types and documentation for the context system

2. Begin Email Service Implementation:
   - Research and select a modern transactional email provider (Resend, Postmark, or SendGrid)
   - Create a type-safe email service with template support
   - Implement email queue system with retry logic
   - Add comprehensive tracking and logging
   - Create testing utilities for email verification

3. Start Notification Service Development:
   - Design multi-channel notification system (in-app, email, push)
   - Implement user preference management for notifications
   - Create real-time notification capabilities
   - Develop notification center UI components
   - Add analytics for notification engagement

These next steps will complete the Hooks and Custom Logic section and make substantial progress on the Utility Services section, bringing us closer to completing Phase 2 of the migration plan.

### Lessons Extended

- Always verify protocol security requirements before implementation
- Use proper preprocessing phase management for MPC protocols
- Implement secure channel communication from the start
- Handle protocol-specific parameters carefully
- Document security assumptions and guarantees
- Test with multiple parties and security settings

- List Component Best Practices:
  - Use appropriate semantic HTML elements (ul/ol/li)
  - Implement proper ARIA attributes for accessibility
  - Provide multiple variants for different visual styles
  - Support both horizontal and vertical layouts
  - Include support for nested lists with proper indentation
  - Add smooth animations for expandable/collapsible elements
  - Use data attributes for styling hooks
  - Support different list markers (disc, circle, square, decimal, none)
  - Implement truncation for long lists with "show more" functionality

- React Hooks Best Practices (2025):
  - Handle server-side rendering explicitly in hooks that use browser APIs
  - Implement proper cleanup functions to prevent memory leaks
  - Use TypeScript for better type safety and developer experience
  - Add comprehensive JSDoc comments for hook parameters and return values
  - Implement debounce for hooks that trigger on high-frequency events
  - Provide sensible defaults and fallback values
  - Create thorough testing for hooks, including SSR environments
  - Follow naming conventions (use, get, set) consistently

- Context Provider Best Practices in Astro:
  - Use wrapper components when implementing React context providers in Astro
  - Apply the ConvexProvider pattern for framework-specific providers
  - Keep context values serializable when possible for better SSR compatibility
  - Split large contexts into smaller, more focused providers
  - Implement proper TypeScript types for context values and providers
  - Add default values that make sense even when provider is missing
  - Consider performance implications of context updates
  - Document provider requirements and dependencies clearly
