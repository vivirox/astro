---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
---

# Cursor Development Rules & AI Collaboration Guide for Astro/TypeScript

## ÔøΩÔøΩ Core Philosophy

1.  **Simplicity:** Prioritize simple, clear, and maintainable solutions. Avoid unnecessary complexity or over-engineering.
        *   `docs/technical.md` (Technical specifications, established patterns)
        *   `tasks/tasks.md` (Current development tasks, requirements)
        *   `astro.config.mjs` (Astro configuration and integrations)
        *   `tsconfig.json` (TypeScript configuration)
    *   If documentation is missing, unclear, or conflicts with the request, **ask for clarification**.
2.  **Architecture Adherence:**
    *   Follow Astro's recommended project structure:
        *   `src/pages/` for file-based routing
        *   `src/components/` for reusable components
        *   `src/layouts/` for page layouts
        *   `src/content/` for content collections
        *   `src/styles/` for global styles
        *   `public/` for static assets
    *   Understand and respect module boundaries, data flow, system interfaces, and component dependencies.
    *   Validate that changes comply with established architecture and Astro's best practices.
3.  **Pattern & Tech Stack Awareness:**
    *   Reference project documentation to understand existing patterns and technologies.
    *   Utilize Astro's built-in features and official integrations before adding external dependencies.

## ‚öôÔ∏è Task Execution & Workflow
- Prioritize completing the DashboardLayout.astro component before moving to other tasks. (2025-04-01)
- Prioritize setting up the testing infrastructure before proceeding with other tasks (2025-04-01).
- Prioritize completing Convex integration next. (2025-04-01)
- Prioritize creating React hooks for Convex functions after completing the Convex integration. (2025-04-01)
- The Astro conversion plan should be updated to reflect the progress made on the AdminDashboard.astro component and the creation of the `getSystemMetrics` API function. (2025-04-01)
- Prioritize blog layout and content collection setup. (2025-04-01)
- Prioritize creating the Documentation layout next. (2025-04-02)
- DocumentationLayout.astro component created (2025-04-02).
- Progress Update (2025-04-03): Documentation Layout Implementation (COMPLETED). Overall progress at 89% completion.  Next steps prioritized.
- Progress Update (2025-04-04): Fixed Invalid Imports (COMPLETED) - Removed invalid imports for `ClientRouter` and `ViewTransitions` from `astro:transitions` which were causing "Cannot find module" errors in the layouts. The project should properly install `@astrojs/transitions` if these features are needed.
- Progress Update (2025-04-05): Converted PerformanceDashboard component to Astro.
- Implement real user monitoring (RUM): Research available RUM tools compatible with Astro; Create a basic RUM implementation; Set up performance metrics collection; Implement error tracking; Create a dashboard to visualize collected data; Add documentation on how to use and interpret RUM data. (2025-04-02)
- Implement Real User Monitoring (RUM) (2025-04-02):  This task involved researching RUM tools, creating a basic implementation, setting up performance metrics collection, implementing error tracking, creating a dashboard to visualize data, and adding documentation.  The `RealUserMonitoring.astro` component and associated React hooks were created. A new page `/admin/real-user-monitoring` was created to display the RUM data.
- Focus on fixing Astro components with incorrect frontmatter structure, specifically `PatternVisualization.astro` and `PerformanceDashboard.astro`. (2025-04-02)
- Fix the JSON examples in `src/pages/docs/api/index.astro` to avoid conflicts with Astro's templating syntax. (2025-04-02)
- Focus on fixing frontmatter issues in `PatternVisualization.astro` and `PerformanceDashboard.astro`. (2025-04-02)
- Check for any remaining analytics components to convert (2025-04-02)
- Implement API versioning and documentation (2025-04-02)
- Set up server-side auth checks for improved security (2025-04-02)
- Update the conversion plan to reflect the completion of the SimulatorDashboard conversion. (2025-04-02)
- Convert SimulatorDashboard component to Astro wrapper (2025-04-06)
- Add mobile device tests for responsive layouts (2025-04-06)
- Convert SimulatorDashboard component to an Astro wrapper (2025-04-02)
- Add mobile device tests for responsive layouts (2025-04-02)
- Convert SimulatorDashboard component to an Astro wrapper (2025-04-02)
- Convert SimulatorDashboard component to an Astro wrapper (2025-04-02)
- Convert SimulatorDashboard component to an Astro wrapper (2025-04-02)
- Convert SimulatorDashboard component to an Astro wrapper (2025-04-02)


## ‚ú® Code Quality & Style

1.  **TypeScript Guidelines:**
    *   Use strict typing (avoid `any`). Document complex logic with JSDoc.
    *   Leverage TypeScript's type inference where appropriate.
    *   Define proper interfaces for component props.
    *   Use type guards for runtime type checking.
    *   Use `unknown` instead of `any` where appropriate.
2.  **Astro Component Guidelines:**
    *   Use `.astro` files for static or minimally interactive components.
    *   Keep React/Vue/Svelte components only for highly interactive features.
    *   Use client directives (`client:load`, `client:idle`, `client:visible`) judiciously.
    *   Implement proper prop validation using TypeScript interfaces.
    *   Use the `use client` directive for proper hydration in Astro components.
    *   **IMPORTANT**: Always use proper Astro frontmatter syntax (content between `---` fences) for imports, props, and scripts.
    *   Correct Astro file structure has three parts:
        1. Frontmatter section between `---` fences containing imports, TypeScript definitions, and JavaScript logic
        2. HTML template section after the closing `---`
        3. Optional `<style>` section at the bottom
    *   Variables defined in the frontmatter section are available in the template.
    *   After creating or editing `.astro` files, verify that frontmatter sections are properly defined.
    *   **Common Errors to Check for:**
        - Missing or improper frontmatter fences (`---` at beginning and end of frontmatter)
        - Incorrect imports (verify if the imported module uses default or named exports)
        - Type import errors (ensure correct type paths and imports)
        - Undefined variable errors for props and imported components in templates
    *   Example of correct structure:
      ```astro
      ---
      // Imports and TypeScript in frontmatter section
      import MyComponent from './MyComponent';
      import type { MyProps } from './types';
      
      // Props interface
      interface Props {
        title: string;
        items?: string[];
      }
      
      // Props destructuring
      const { title, items = [] } = Astro.props;
      
      // Any other JS logic
      const count = items.length;
      ---
      
      <!-- HTML template section -->
      <div>
        <h1>{title}</h1>
        <p>Item count: {count}</p>
        <ul>
          {items.map(item => <li>{item}</li>)}
        </ul>
      </div>
      
      <!-- Optional style section -->
      <style>
        h1 { color: blue; }
      </style>
      ```
3.  **Small Files & Components:**
    *   Keep files under **300 lines**. Refactor proactively.
4.  **Performance Optimization:**
    *   Minimize client-side JavaScript usage.
    *   Leverage Astro's static site generation capabilities.
    *   Implement proper image optimization using `@astrojs/image`.
    *   Use dynamic imports for code splitting.
5.  **Pattern Consistency:**
    *   Follow Astro's component patterns and conventions.
    *   Use consistent naming for files: PascalCase for components, kebab-case for pages.
    *   Maintain consistent directory structure.
6.  **Avoid Duplication (DRY):** Actively look for and reuse existing functionality. Refactor to eliminate duplication.
7.  **No Bazel:** Bazel is not permitted. Use project-specified build tools.
8.  **Linting/Formatting:** 
    *   Ensure all code conforms to project's ESLint/Prettier rules.
    *   **CRITICAL**: Always check for linter errors after creating or editing files.
    *   For `.astro` files, verify correct structure with imports and TypeScript in the frontmatter section (between `---` fences) and template code after.
    *   Fix any syntax or import errors before committing changes.
9.  **File Naming:** Use clear, descriptive names. Avoid "temp", "refactored", "improved", etc., in permanent file names.
10. **No One-Time Scripts:** Do not commit one-time utility scripts into the main codebase.


## ‚ôªÔ∏è Refactoring
## üîí Security

1.  **Server-Side Security:**
    *   Keep sensitive logic in server-side only components.
    *   Use Astro's built-in security features (automatic HTML escaping, CSP).
    *   Implement proper CORS policies.
    *   Use environment variables for sensitive configuration.
2.  **Client-Side Security:**
    *   Sanitize and validate all user inputs.
    *   Implement proper XSS protection.
    *   Use Content Security Policy (CSP) headers.
    *   Avoid exposing sensitive information in client-side scripts.
3.  **API Security:**
    *   Implement proper authentication and authorization.
    *   Rate limit API endpoints.
    *   Validate and sanitize API inputs.
    *   Use HTTPS for all external communications.
4.  **Dependency Security:**
    *   Regularly audit dependencies using `npm audit`.
    *   Pin dependency versions for consistency.
    *   Use official Astro integrations when available.
    *   Keep dependencies updated to patch security vulnerabilities.
5.  **Data Protection:**
    *   Never expose sensitive data in client-side code or public directories.
    *   Implement proper session management.
    *   Use secure headers (HSTS, X-Frame-Options, etc.).
    *   Follow data protection regulations (GDPR, CCPA, etc.).

## üå≥ Version Control & Environment
## üìÑ Documentation Maintenance

1.  **Update Docs:**
    *   Keep documentation in sync with code changes.
    *   Document Astro-specific configurations and integrations.
    *   Maintain TypeScript type definitions and interfaces.
    *   Update security-related documentation promptly.
    *   Add documentation for Real User Monitoring (RUM) implementation, including setup, usage, and interpretation of data. (2025-04-02)
2.  **Keep Rules Updated:**
    *   Review and update this `.cursorrules` file regularly.
    *   Document new security measures and best practices.
    *   Track changes in Astro's recommended patterns.
    *   Monitor and document TypeScript version updates.

## PROJECT OVERVIEW
Project: Astro.  A significant portion of the codebase consists of React and TypeScript components, requiring conversion to Astro's component model.  The analysis indicates a substantial conversion effort is needed to fully transition to an Astro-based architecture.  A recent codebase analysis (2025-03-31 17:53:45) estimates that 40-50% of components (primarily static UI, layout, and content-heavy components) could benefit from conversion to `.astro` format, while the remaining 50-60% (interactive components like chat, analytics, and admin dashboards) should remain as React components due to their interactive nature.  Further investigation is needed to precisely quantify the number of files requiring conversion.  A more detailed breakdown of the conversion effort is available in `astro-conversion-plan.mdx`.  MainLayout.astro component created on 2025-03-31 22:59:59.
DashboardLayout.astro component updated on 2025-04-01.
MainLayout.astro uses UnoCSS.
DashboardLayout.astro uses UnoCSS.
DashboardLayout.astro component updated with ClientRouter, ErrorBoundary, improved responsiveness, meta tags, theme handling, transitions, accessibility features, and container class.  (2025-04-01)
DashboardLayout.astro component significantly improved on 2025-04-01: Added ClientRouter, ErrorBoundary, improved responsiveness, meta tags, theme handling with CSS variables, transitions, smoother theme changes, accessibility features (font fallbacks, dvh units), and container class.  Selection styling added.
ErrorBoundary component added (2025-04-01).
Convex integration prioritized on 2025-04-01.  React hooks for Convex functions created on 2025-04-01.
AdminDashboard.astro component updated on 2025-04-01: Import path for logging uses the alias path, metrics fetch moved to a separate API function (`getSystemMetrics`), error handling improved, and the client-side script is better organized.
BlogLayout.astro component added (2025-04-01).  Blog index page added (2025-04-01). Dynamic blog post route added (2025-04-01).
DocumentationLayout.astro component creation prioritized (2025-04-02).
DocumentationLayout.astro component created (2025-04-02).
Progress Update (2025-04-03): Documentation Layout Implementation (COMPLETED). Overall progress at 89% completion. Next steps prioritized.
Progress Update (2025-04-04): DocumentationLayout.astro component created (2025-04-04). Added sample documentation pages (getting-started and API reference).
Progress Update (2025-04-05): Converted PerformanceDashboard component to Astro.
RealUserMonitoring.astro component created (2025-04-02).  A new page `/admin/real-user-monitoring` was added to display the RUM dashboard. (2025-04-02)
SimulatorDashboard.astro component created (2025-04-02).
Progress Update (2025-04-06): SimulatorDashboard Conversion (COMPLETED) - Created SimulatorDashboard.astro wrapper component with proper frontmatter structure and client:load directive. Created SimulatorDashboardReact.tsx as the actual implementation. Added comprehensive tests for the components. Mobile Device Tests (COMPLETED) - Implemented Playwright-based mobile device compatibility tests for various screen sizes and orientations. Tested core pages including home, documentation, dashboard, and simulator. Added screenshot generation for visual verification. Overall Progress - Project now at 95% completion with all dashboard components converted to Astro format and significant progress on testing infrastructure.
Progress Update (2025-04-07): Cross-Browser Compatibility Tests (COMPLETED) - Created comprehensive cross-browser tests using Playwright to ensure the application works correctly across Chromium, Firefox, and WebKit browsers. Added tests for page functionality, responsive behavior, form interactions, and animations.
Progress Update (2025-04-08): API Versioning and Documentation (COMPLETED) - Implemented API versioning through URL paths (e.g., /api/v1/...) with automatic redirects from legacy endpoints. Created OpenAPI specification and Swagger UI documentation for interactive API testing. Updated API documentation with version history and guidelines. Overall Progress - Project now at 98% completion with all dashboard components converted to Astro format, complete testing infrastructure, and properly versioned API endpoints.


## CODE STYLE
Adhere to standard TypeScript coding conventions.  Avoid using the `any` type unless absolutely necessary and clearly documented. Use `unknown` instead of `any` where appropriate.  Follow clean code principles as outlined in the `clean-code` rule.


## FOLDER ORGANIZATION
Based on the project exploration, the following folders are identified: `src/pages`, `src/layouts`, `src/components`, `src/lib`, `src/config`, `src/constants`, `src/types`, `src/styles`, `src/hooks`, `src/scripts`, `src/data`, `src/workers`, `src/services`, `src/tests`, `src/context`, `src/@types`, `src/db`, `src/docs`, `src/assets`, `src/integrations`, `src/utils`, `src/simulator`, `src/content`.  Further refinement of folder organization may be needed based on project growth.  A new folder `src/hooks/convex` was added on 2025-04-01 to house Convex-specific React hooks.  A new folder `src/lib/api/admin` was added on 2025-04-01 to house admin-specific API functions.  A new folder `src/components/monitoring` was added on 2025-04-02 to house the Real User Monitoring components.  Adhere to Astro's recommended project structure as outlined in the `astro` rule.


## TECH STACK
TypeScript, ESLint, Jest, Vitest, Resend, Redis, ioredis, @testing-library/jest-dom, @testing-library/react, @postmark/core, ioredis, @ascorbic/feed-loader, react, react-dom, pnpm, Convex, Astro, class-variance-authority, UnoCSS, @astrojs/transitions, @astrojs/client, Grafana Faro Web SDK, Playwright, swagger-ui-dist, @types/swagger-ui-dist

## PROJECT-SPECIFIC STANDARDS
- Unused variables and imports should be removed.  Address all ESLint warnings about unused code.  If a variable is declared but never used, remove it.  Use the underscore convention for unused parameters (e.g., `_key`).
- Vitest is the preferred testing framework for new tests. Jest should be used for existing tests until migration is complete.  A `vitest.config.ts` file should be created for Vitest configuration, and a Vitest setup file (e.g., `vitest.setup.ts`) is needed to declare Vitest globals for TypeScript projects.  The `jest.config.ts` and associated Jest setup file are deprecated for new tests.
- Proper configuration is required for both Jest (for existing tests) and Vitest (for new tests).  Ensure types are correctly configured for each.
- When mocking external services (like Redis or Resend) in tests, ensure proper type definitions are used to avoid linting errors. Direct access to underlying client methods might be necessary if the service class doesn't expose all required methods.  If direct access is needed, ensure proper mocking of the underlying client (e.g., `ioredis`) is implemented.
- When encountering type errors related to mocked services, consider using type assertions to match the expected type of the mocked function.  However, ensure this is done judiciously and only when necessary to avoid masking actual type problems.
- Ensure proper Jest type configuration for existing tests or migrate to Vitest for new tests.  Address all ESLint warnings about unused code.  If a variable is declared but never used, remove it.  Address all ESLint warnings, including those related to unused variables and imports.  Prioritize resolving critical issues such as redeclaration errors, unsafe optional chaining, undefined variables, and parsing errors before addressing less critical warnings.
- Ensure a `vitest.setup.ts` file exists to provide necessary test globals (e.g., `describe`, `it`, `expect`) for Vitest tests.  Missing test framework globals are a common source of errors.
- When encountering missing test framework globals (describe, it, expect, etc.) in Vitest tests, ensure that the `vitest.setup.ts` file is correctly configured and includes the necessary imports.  Commonly missing imports include `describe`, `it`, `expect`, `beforeAll`, `beforeEach`, `afterEach`, and `afterAll`.  The `vitest.setup.ts` file should also include a `declare global` block to make these globals available in test files.
- When importing modules, carefully check the export type (class vs. constant) to avoid import errors.  Correctly import modules based on their export type (e.g., `import { CacheInvalidation } from '@/lib/cache/invalidation'` instead of `import { CacheInvalidationService } from '@/lib/cache/invalidation'`).  Ensure that the import path correctly reflects the module's location.  Ensure that all necessary modules are imported, especially those from appropriate locations (e.g.,  `'@/lib/ai/services/PatternRecognitionService'`, `'@/lib/ai/services/PatternRecognitionService'`).
- When using `CacheInvalidation`, ensure that the `redis` property is passed as `{ redis: redis.getClient() }` to correctly access the Redis client.  The `initialize()` and `shutdown()` methods are not part of the `CacheInvalidation` interface and should not be used.  Use `JSON.stringify` for serializing values before storing them in Redis.  The `addTag` method is deprecated; use the `set()` method with the `tags` option to add tags to keys.  The `on` and `off` methods for event handling are not supported by `CacheInvalidation`. Direct verification of key existence should be used instead of event listeners.
- Ensure that the `vitest.setup.ts` file includes imports for `describe`, `it`, `expect`, `beforeAll`, `beforeEach`, `afterEach`, and `afterAll`, and a `declare global` block to make these globals available in test files.  Failure to include these can lead to missing test framework globals errors.  Correct import paths are crucial to avoid module import errors.  When updating tests to align with new service implementations, ensure that methods, parameters, and return types are correctly updated to match the current version.
- When encountering missing module imports, carefully check the module's location.  Incorrect import paths are a frequent source of errors.  For example, ensure that `'@/lib/ai/services/PatternRecognitionService'` is used correctly.
- Ensure proper type definitions for all RedisService methods and parameters.  Missing types are a common source of errors in Redis service integration tests.  Include necessary utility functions (e.g., `generateTestKey`, `sleep`) and custom matchers (e.g., `toBeRedisError`) for more robust testing.
- In Redis service integration tests, ensure proper type definitions for all methods and parameters. Import necessary utility functions (e.g., `generateTestKey`, `sleep`) from `test-utils` and add custom matchers (e.g., `toBeRedisError`) for more robust testing.  Ensure that `generateTestKey` and other necessary utility functions from `./test-utils` are imported into test files where needed.
- When encountering "is declared but its value is never read" errors, remove unused imports or use the underscore convention for unused parameters (e.g., `_key`).
- When using the `RedisService.set` method, ensure that TTL values are provided in milliseconds.  The method signature is `async set(key: string, value: string, ttlMs?: number): Promise<void>`.
- When using the `RedisService.set` method, ensure TTL values are provided in milliseconds. The method signature is `async set(key: string, value: string, ttlMs?: number): Promise<void>`.  Incorrectly providing TTL in seconds will result in a type error.  The correct usage is `await redis.set(key, value, ttl * 1000);` where `ttl` is in seconds.
- When using JSON.stringify, ensure the resulting string is of the correct type for Redis storage (e.g., string).
- To resolve the error "Object literal may only specify known properties, and 'globalTeardown' does not exist in type 'InlineConfig'", use a `vitest.global.setup.ts` file exporting both `setup` and `teardown` functions instead of separate `globalSetup` and `globalTeardown` properties in the Vitest configuration.
- For custom matchers in Vitest, use the `declare global` syntax as shown in the updated `test-utils.ts` example below.  This ensures correct type definitions and avoids linting errors.
- When encountering file not found errors, double-check the file path.  The error "Could not find file 'src/lib/services/redis.ts'. Did you mean one of: - src/lib/services/redis/index.ts - src/lib/services/redis/types.ts - src/lib/services/redis/RedisService.ts" indicates a potential issue with the file path or file organization.  Ensure the correct path is used and that the file exists in the specified location.  Correct import paths are crucial for resolving modules.  Ensure that the `tsconfig.json` file is correctly configured with `baseUrl` and `paths` to resolve relative imports correctly (e.g., `@/lib/redis`).  When encountering errors related to missing modules, double-check the import path. For example, ensure that `'@/lib/ai/services/PatternRecognitionService'` is used correctly.
- When using the logger, ensure proper instantiation, for example using `const logger = loggerModule.getLogger('NotificationService')`.
- Ensure proper closing tags for MDX `<Steps>` components.  Incorrect indentation can cause parsing errors.
- Ensure correct indentation for closing `</Steps>` tags in MDX files to avoid parsing errors.  Malformatted code blocks and duplicate lines in MDX files can also cause build errors.
- When encountering "Cannot find module '@/config/env.config'" errors, verify the `baseUrl` and `paths` configuration within `tsconfig.json` to ensure correct resolution of relative imports correctly.
- Avoid using JSX directly within TypeScript files.  Use `React.createElement` instead for better compatibility and type safety.  This is particularly important when working with Astro components.  The error "Unexpected token '<'" usually indicates this issue.  Ensure that all React imports are correctly handled.  For example, instead of `return <>{children}</>;`, use `return React.createElement(React.Fragment, null, children);`.  Avoid duplicate exports within the same file.  If multiple functions or variables share the same name, rename one of them to avoid naming conflicts.
- When encountering issues with React module resolution, ensure that Astro is correctly configured to handle React imports using either the `react` or `@astrojs/react` package.  Ensure that the necessary React packages are installed and configured correctly.
- When using JSX within Astro components, ensure that the necessary React packages are installed (`react`, `react-dom`) and that the component is correctly configured for JSX usage.  Incorrect configuration can result in runtime errors.  Ensure that the `astro.config.mjs` file is correctly configured to handle React imports.  Refer to the Astro documentation for guidance on configuring JSX within Astro projects. Use of `use client` directive in Astro components helps ensure proper hydration and prevents issues.
- Avoid using JSX directly within TypeScript files unless explicitly using `.tsx` file extension and configured correctly with `tsconfig.json` to handle JSX.  The error "Unexpected token '<'" usually indicates this issue.  Ensure that all React imports are correctly handled.  For example, instead of `return <>{children}</>;`, use `return React.createElement(React.Fragment, null, children);`.  Avoid duplicate exports within the same file.  If multiple functions or variables share the same name, rename one of them to avoid naming conflicts.
- Use `use client` directive in Astro components for proper hydration.
- To resolve persistent "module is not defined" errors related to React, create a custom React loader to manage the import and ensure compatibility between CommonJS and ESM modules. This custom loader will need to re-export the necessary React modules to ensure proper functionality. A custom `vite.config.js` might be necessary to configure Astro's build process for correct React import handling.  Review files in `src/pages` directory, specifically `index.astro`, for homepage issues. Review `src/layouts/BaseLayout.astro` and `src/layouts/StandardLayout.astro` for layout related problems. Investigate `src/components/widgets/SpinningGlobe.astro` for component-specific issues. Malformatted code blocks and duplicate lines in MDX files (like `src/content/docs/redis-testing.mdx`) can cause build errors and affect the homepage. Check for malformed code blocks and duplicate lines in MDX files. Review `src/simulator/index.tsx` for JSX usage within TypeScript. Use `React.createElement` instead. Check for duplicate exports in `src/simulator/utils/privacy.ts`. Rename duplicate exports to resolve conflicts. Ensure that `astro.config.mjs` is correctly formatted to avoid ESLint formatter issues resulting in empty output.  This may involve correcting indentation, spacing, or other style inconsistencies according to the ESLint configuration. When injecting scripts into Astro, avoid using import statements directly within the injected code. Use relative paths instead of aliases to ensure correct resolution during the build process.
- Ensure that `astro.config.mjs` is correctly configured to handle React imports. Address "module is not defined" errors by configuring Astro to handle React imports correctly, potentially using a custom Vite configuration or a custom React loader. The error typically indicates a mismatch between the module system used by React and the project's module system. Ensure that the correct version of React is installed and that the necessary dependencies are included. Use the `use client` directive in Astro components to ensure proper React hydration.  Avoid using JSX directly within TypeScript files unless explicitly using `.tsx` file extension and configured correctly with `tsconfig.json` to handle JSX. Use `React.createElement` instead for better type safety and compatibility.
- Ensure that settings.json uses boolean values for boolean properties.  The `window.commandCenter` property should be `true` or `false`, not a number.
- The `functions` field in `convex.json` should be a string pointing to the directory containing Convex functions (e.g., `"functions": "convex/"`).  Do not use an object.
- A large portion of the project's components are implemented using React and TypeScript.  A significant conversion effort will be required to migrate these to Astro components.  A recent analysis (2025-03-31 17:53:45) suggests a phased approach, prioritizing static and layout components for conversion while retaining interactive components as React components within Astro pages using client-side directives.
- When using MDX, ensure that link fragments in the Table of Contents accurately reflect the section headers.  Spaces in headers should be replaced with hyphens, and ampersands should be replaced with "and".
- When using MDX, ensure that link fragments in the Table of Contents accurately reflect the section headers. Replace spaces in headers with hyphens, and replace ampersands with "and".  Link fragments should be lowercase and use hyphens instead of spaces.  Link fragments in MDX files must exactly match the corresponding section headers. Replace spaces with hyphens and ampersands with "and". All fragments should be lowercase.  Link fragments should be valid.  Link fragments in the Table of Contents must exactly match the corresponding section headers in MDX files.  Spaces should be replaced with hyphens, ampersands with "and", and all fragments should be lowercase.
- Link fragments in the Table of Contents should be lowercase and use hyphens instead of spaces.  Ampersands should be replaced with "and".  Link fragments in the Table of Contents must exactly match the corresponding section headers in MDX files. Spaces should be replaced with hyphens, ampersands with "and", and all fragments should be lowercase.
- Link fragments in the Table of Contents should match the corresponding section headers exactly, with spaces replaced by hyphens, ampersands replaced by "and", and all lowercase.  Ensure that link fragments in the Table of Contents exactly match the corresponding section headers in MDX files.  Spaces should be replaced with hyphens, ampersands with "and", and all fragments should be lowercase.
- MainLayout.astro file added to `src/layouts` directory on 2025-03-31 22:59:59.
- DashboardLayout.astro file updated on 2025-04-01.  The file uses `ClientRouter` instead of the deprecated `ViewTransitions`.  The `Header` and `Footer` components are now correctly included and used within the layout.  The DashboardLayout now uses UnoCSS for styling.  Error handling improved with the addition of an `ErrorBoundary` component. Meta tags added for SEO optimization.  Improved theme handling with CSS variables.  Transitions added for smoother theme changes. Accessibility improved with font fallbacks. Viewport height handling improved using `dvh` units. Container class added for better content width management. Selection styling added.
- The `ViewTransitions` component is deprecated; use `ClientRouter` instead.
- The `Header` and `Footer` components should be used in `DashboardLayout.astro` instead of inline HTML.  The inline mobile sidebar toggle script should be removed as this functionality is handled within the `Sidebar` component.
- Case sensitivity in type imports should be checked.  The error "Property 'theme' does not exist on type 'Ui'" was caused by importing `Ui` as `UI`. Correct case is crucial for proper type resolution.  Ensure that all imports and type references use the correct casing.
- The `Ui` interface in `src/types.ts` now includes `theme` and `nav` properties as of 2025-03-31 23:34:51.  The `UI` object in `src/config.ts` has been updated to reflect these changes.
-  A new `ErrorBoundary` component has been added to handle errors gracefully within the `DashboardLayout.astro` component (2025-04-01).
-  A new Astro component test helper (`renderAstro`) and mock Astro global creator (`createMockAstro`) functions have been added to `src/test/utils/astro.ts` (2025-04-01).
-  New Convex functions and React hooks created on 2025-04-01.
- AdminDashboard.astro updated on 2025-04-01: Import path for logging uses alias path (`@/`), metrics fetch moved to separate API function (`getSystemMetrics`), error handling improved, client-side script better organized.  A new `getSystemMetrics` function was added to `src/lib/api/admin.ts` to handle fetching system metrics.
- The `id` property in blog posts is deprecated; use `slug` instead. (2025-04-01)  Conflict:  The new blog post implementation uses `id`.  Further clarification needed on whether to use `id` or `slug`.  The current implementation uses `id` for the blog post slug.  A decision is needed on whether to change this to `slug`.
- Follow Astro best practices for component development, routing, content management, styling, performance optimization, data fetching, SEO, integrations, build and deployment, and testing as detailed in the `astro` rule.
- DocumentationLayout.astro component will be created to support MDX documentation pages with Mintlify-like features. (2025-04-02)
- DocumentationLayout.astro component created (2025-04-02):  This component supports MDX documentation pages with features similar to Mintlify. It includes automatic table of contents generation, a responsive sidebar, and enhanced styling for documentation content.
- To resolve the error "Cannot find module 'astro:transitions'", update the import to use `@astrojs/client` for `ClientRouter` and ensure `@astrojs/client` is installed.
- To resolve "Cannot find module '@/components/base/Head.astro' or its corresponding type declarations", ensure the `Head.astro` component exists at `src/components/base/Head.astro` and that the import path is correct.  Verify `tsconfig.json` baseUrl and paths configuration.
- To resolve "Cannot find module '@/components/ui/ThemeToggle.astro' or its corresponding type declarations", ensure the `ThemeToggle.astro` component exists at `src/components/ui/ThemeToggle.astro` and that the import path is correct. Verify `tsconfig