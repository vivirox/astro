\doxysection{node\+\_\+modules/yocto-\/queue Directory Reference}
\hypertarget{dir_52148a1ccf34f0661ce77be895b58b04}{}\label{dir_52148a1ccf34f0661ce77be895b58b04}\index{node\_modules/yocto-\/queue Directory Reference@{node\_modules/yocto-\/queue Directory Reference}}


\doxysubsection{Detailed Description}
\begin{quote}
Tiny queue data structure \end{quote}


You should use this package instead of an array if you do a lot of {\ttfamily Array\#push()} and {\ttfamily Array\#shift()} on large arrays, since {\ttfamily Array\#shift()} has \href{https://medium.com/@ariel.salem1989/an-easy-to-use-guide-to-big-o-time-complexity-5dcf4be8a444\#:~:text=O(N)\%E2\%80\%94Linear\%20Time}{\texttt{ linear time complexity}} {\itshape O(n)} while {\ttfamily Queue\#dequeue()} has \href{https://medium.com/@ariel.salem1989/an-easy-to-use-guide-to-big-o-time-complexity-5dcf4be8a444\#:~:text=O(1)\%20\%E2\%80\%94\%20Constant\%20Time}{\texttt{ constant time complexity}} {\itshape O(1)}. That makes a huge difference for large arrays.

\begin{quote}
A \href{https://en.wikipedia.org/wiki/Queue_(abstract_data_type)}{\texttt{ queue}} is an ordered list of elements where an element is inserted at the end of the queue and is removed from the front of the queue. A queue works based on the first-\/in, first-\/out (\href{https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)}{\texttt{ FIFO}}) principle. \end{quote}
\hypertarget{readme.md_autotoc_md36253}{}\doxysubsection{\texorpdfstring{Install}{Install}}\label{readme.md_autotoc_md36253}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ yocto-\/queue}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md36254}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{readme.md_autotoc_md36254}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ Queue\ from\ 'yocto-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ Queue();}
\DoxyCodeLine{}
\DoxyCodeLine{queue.enqueue('ü¶Ñ');}
\DoxyCodeLine{queue.enqueue('üåà');}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(queue.size);}
\DoxyCodeLine{//=>\ 2}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(...queue);}
\DoxyCodeLine{//=>\ 'ü¶Ñ\ üåà'}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(queue.dequeue());}
\DoxyCodeLine{//=>\ 'ü¶Ñ'}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(queue.dequeue());}
\DoxyCodeLine{//=>\ 'üåà'}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md36255}{}\doxysubsection{\texorpdfstring{API}{API}}\label{readme.md_autotoc_md36255}
\hypertarget{readme.md_autotoc_md36256}{}\doxysubsubsection{\texorpdfstring{{\ttfamily queue = new Queue()}}{{\ttfamily queue = new Queue()}}}\label{readme.md_autotoc_md36256}
The instance is an \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols}{\texttt{ {\ttfamily Iterable}}}, which means you can iterate over the queue front to back with a ‚Äúfor‚Ä¶of‚Äù loop. Using the iterator will not remove the items from the queue. If you want that, use \doxylink{README.md_drain}{\`{}drain()\`{}} instead.

You can also use spreading to convert the queue to an array. Don\textquotesingle{}t do this unless you really need to though, since it\textquotesingle{}s slow.\hypertarget{readme.md_autotoc_md36257}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .enqueue(value)}}{{\ttfamily .enqueue(value)}}}\label{readme.md_autotoc_md36257}
Add a value to the queue.\hypertarget{readme.md_autotoc_md36258}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .dequeue()}}{{\ttfamily .dequeue()}}}\label{readme.md_autotoc_md36258}
Remove the next value in the queue.

Returns the removed value or {\ttfamily undefined} if the queue is empty.\hypertarget{readme.md_autotoc_md36259}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .peek()}}{{\ttfamily .peek()}}}\label{readme.md_autotoc_md36259}
Get the next value in the queue without removing it.

Returns the value or {\ttfamily undefined} if the queue is empty.\hypertarget{readme.md_autotoc_md36260}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .drain()}}{{\ttfamily .drain()}}}\label{readme.md_autotoc_md36260}
Returns an iterator that dequeues items as you consume it.

This allows you to empty the queue while processing its items.

If you want to not remove items as you consume it, use the {\ttfamily Queue} object as an iterator.\hypertarget{readme.md_autotoc_md36261}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .clear()}}{{\ttfamily .clear()}}}\label{readme.md_autotoc_md36261}
Clear the queue.\hypertarget{readme.md_autotoc_md36262}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .size}}{{\ttfamily .size}}}\label{readme.md_autotoc_md36262}
The size of the queue.\hypertarget{readme.md_autotoc_md36263}{}\doxysubsection{\texorpdfstring{Related}{Related}}\label{readme.md_autotoc_md36263}

\begin{DoxyItemize}
\item \href{https://github.com/sindresorhus/quick-lru}{\texttt{ quick-\/lru}} -\/ Simple ‚Äú\+Least Recently Used‚Äù (LRU) cache 
\end{DoxyItemize}