\doxysection{node\+\_\+modules/devalue Directory Reference}
\hypertarget{dir_52c49e4d65233f9332f388937856b1b7}{}\label{dir_52c49e4d65233f9332f388937856b1b7}\index{node\_modules/devalue Directory Reference@{node\_modules/devalue Directory Reference}}


\doxysubsection{Detailed Description}
Like {\ttfamily JSON.\+stringify}, but handles


\begin{DoxyItemize}
\item cyclical references ({\ttfamily obj.\+self = obj})
\item repeated references ({\ttfamily \mbox{[}value, value\mbox{]}})
\item {\ttfamily undefined}, {\ttfamily Infinity}, {\ttfamily NaN}, {\ttfamily -\/0}
\item regular expressions
\item dates
\item {\ttfamily Map} and {\ttfamily Set}
\item {\ttfamily Big\+Int}
\item {\ttfamily Array\+Buffer} and Typed Arrays
\item custom types via replacers, reducers and revivers
\end{DoxyItemize}

Try it out \href{https://svelte.dev/repl/138d70def7a748ce9eda736ef1c71239?version=3.49.0}{\texttt{ here}}.\hypertarget{README.md_autotoc_md11873}{}\doxysubsection{\texorpdfstring{Goals\+:}{Goals\+:}}\label{README.md_autotoc_md11873}

\begin{DoxyItemize}
\item Performance
\item Security (see XSS mitigation)
\item Compact output
\end{DoxyItemize}\hypertarget{README.md_autotoc_md11874}{}\doxysubsection{\texorpdfstring{Non-\/goals\+:}{Non-\/goals\+:}}\label{README.md_autotoc_md11874}

\begin{DoxyItemize}
\item Human-\/readable output
\item Stringifying functions
\end{DoxyItemize}\hypertarget{README.md_autotoc_md11875}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md11875}
There are two ways to use {\ttfamily devalue}\+:\hypertarget{README.md_autotoc_md11876}{}\doxysubsubsection{\texorpdfstring{{\ttfamily uneval}}{{\ttfamily uneval}}}\label{README.md_autotoc_md11876}
This function takes a Java\+Script value and returns the Java\+Script code to create an equivalent value â€” sort of like {\ttfamily eval} in reverse\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ devalue\ from\ 'devalue';}
\DoxyCodeLine{}
\DoxyCodeLine{let\ obj\ =\ \{\ message:\ 'hello'\ \};}
\DoxyCodeLine{devalue.uneval(obj);\ //\ '\{message:"{}hello"{}\}'}
\DoxyCodeLine{}
\DoxyCodeLine{obj.self\ =\ obj;}
\DoxyCodeLine{devalue.uneval(obj);\ //\ '(function(a)\{a.message="{}hello"{};a.self=a;return\ a\}(\{\}))'}

\end{DoxyCode}


Use {\ttfamily uneval} when you want the most compact possible output and don\textquotesingle{}t want to include any code for parsing the serialized value.\hypertarget{README.md_autotoc_md11877}{}\doxysubsubsection{\texorpdfstring{{\ttfamily stringify} and {\ttfamily parse}}{{\ttfamily stringify} and {\ttfamily parse}}}\label{README.md_autotoc_md11877}
These two functions are analogous to {\ttfamily JSON.\+stringify} and {\ttfamily JSON.\+parse}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ devalue\ from\ 'devalue';}
\DoxyCodeLine{}
\DoxyCodeLine{let\ obj\ =\ \{\ message:\ 'hello'\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{let\ stringified\ =\ devalue.stringify(obj);\ //\ '[\{"{}message"{}:1\},"{}hello"{}]'}
\DoxyCodeLine{devalue.parse(stringified);\ //\ \{\ message:\ 'hello'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{obj.self\ =\ obj;}
\DoxyCodeLine{}
\DoxyCodeLine{stringified\ =\ devalue.stringify(obj);\ //\ '[\{"{}message"{}:1,"{}self"{}:0\},"{}hello"{}]'}
\DoxyCodeLine{devalue.parse(stringified);\ //\ \{\ message:\ 'hello',\ self:\ [Circular]\ \}}

\end{DoxyCode}


Use {\ttfamily stringify} and {\ttfamily parse} when evaluating Java\+Script isn\textquotesingle{}t an option.\hypertarget{README.md_autotoc_md11878}{}\doxysubsubsection{\texorpdfstring{{\ttfamily unflatten}}{{\ttfamily unflatten}}}\label{README.md_autotoc_md11878}
In the case where devalued data is one part of a larger JSON string, {\ttfamily unflatten} allows you to revive just the bit you need\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ devalue\ from\ 'devalue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ json\ =\ \`{}\{}
\DoxyCodeLine{\ \ "{}type"{}:\ "{}data"{},}
\DoxyCodeLine{\ \ "{}data"{}:\ \$\{devalue.stringify(data)\}}
\DoxyCodeLine{\}`;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ data\ =\ devalue.unflatten(JSON.parse(json).data);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md11879}{}\doxysubsection{\texorpdfstring{Custom types}{Custom types}}\label{README.md_autotoc_md11879}
You can serialize and deserialize custom types by passing a second argument to {\ttfamily stringify} containing an object of types and their {\itshape reducers}, and a second argument to {\ttfamily parse} or {\ttfamily unflatten} containing an object of types and their {\itshape revivers}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ Vector\ \{}
\DoxyCodeLine{\ \ \ \ constructor(x,\ y)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ this.x\ =\ x;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ this.y\ =\ y;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ magnitude()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ Math.sqrt(this.x\ *\ this.x\ +\ this.y\ *\ this.y);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ stringified\ =\ devalue.stringify(new\ Vector(30,\ 40),\ \{}
\DoxyCodeLine{\ \ \ \ Vector:\ (value)\ =>\ value\ instanceof\ Vector\ \&\&\ [value.x,\ value.y]}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(stringified);\ //\ [["{}Vector"{},1],[2,3],30,40]}
\DoxyCodeLine{}
\DoxyCodeLine{const\ vector\ =\ devalue.parse(stringified,\ \{}
\DoxyCodeLine{\ \ \ \ Vector:\ ([x,\ y])\ =>\ new\ Vector(x,\ y)}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(vector.magnitude());\ //\ 50}

\end{DoxyCode}


If a function passed to {\ttfamily stringify} returns a truthy value, it\textquotesingle{}s treated as a match.

You can also use custom types with {\ttfamily uneval} by specifying a custom replacer\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{devalue.uneval(vector,\ (value,\ uneval)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (value\ instanceof\ Vector)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ \`{}new\ Vector(\$\{value.x\},\$\{value.y\})`;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});\ //\ \`{}new\ Vector(30,40)`}

\end{DoxyCode}


Note that any variables referenced in the resulting Java\+Script (like {\ttfamily Vector} in the example above) must be in scope when it runs.\hypertarget{README.md_autotoc_md11880}{}\doxysubsection{\texorpdfstring{Error handling}{Error handling}}\label{README.md_autotoc_md11880}
If {\ttfamily uneval} or {\ttfamily stringify} encounters a function or a non-\/\+POJO that isn\textquotesingle{}t handled by a custom replacer/reducer, it will throw an error. You can find where in the input data the offending value lives by inspecting {\ttfamily error.\+path}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{try\ \{}
\DoxyCodeLine{\ \ \ \ const\ map\ =\ new\ Map();}
\DoxyCodeLine{\ \ \ \ map.set('key',\ function\ invalid()\ \{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ uneval(\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ object:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ array:\ [map]}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\}\ catch\ (e)\ \{}
\DoxyCodeLine{\ \ \ \ console.log(e.path);\ //\ '.object.array[0].get("{}key"{})'}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md11881}{}\doxysubsection{\texorpdfstring{XSS mitigation}{XSS mitigation}}\label{README.md_autotoc_md11881}
Say you\textquotesingle{}re server-\/rendering a page and want to serialize some state, which could include user input. {\ttfamily JSON.\+stringify} doesn\textquotesingle{}t protect against XSS attacks\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ state\ =\ \{}
\DoxyCodeLine{\ \ \ \ userinput:\ \`{}</script><script\ src='https://evil.com/mwahaha.js'>`}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ template\ =\ \`{}}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ //\ NEVER\ DO\ THIS}
\DoxyCodeLine{\ \ var\ preloaded\ =\ \$\{JSON.stringify(state)\};}
\DoxyCodeLine{</script>`;}

\end{DoxyCode}


Which would result in this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ \ \ //\ NEVER\ DO\ THIS}
\DoxyCodeLine{\ \ \ \ var\ preloaded\ =\ \{"{}userinput"{}:"{}}
\DoxyCodeLine{</script>}
\DoxyCodeLine{<script\ src="{}https://evil.com/mwahaha.js"{}>}
\DoxyCodeLine{\ \ \ \ "{}\};}
\DoxyCodeLine{</script>}

\end{DoxyCode}


Using {\ttfamily uneval} or {\ttfamily stringify}, we\textquotesingle{}re protected against that attack\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ template\ =\ \`{}}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ var\ preloaded\ =\ \$\{uneval(state)\};}
\DoxyCodeLine{</script>`;}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ \ \ var\ preloaded\ =\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ userinput:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}\(\backslash\)\(\backslash\)u003C\(\backslash\)\(\backslash\)u002Fscript\(\backslash\)\(\backslash\)u003E\(\backslash\)\(\backslash\)u003Cscript\ src='https:\(\backslash\)\(\backslash\)u002F\(\backslash\)\(\backslash\)u002Fevil.com\(\backslash\)\(\backslash\)u002Fmwahaha.js'\(\backslash\)\(\backslash\)u003E"{}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{</script>}

\end{DoxyCode}


This, along with the fact that {\ttfamily uneval} and {\ttfamily stringify} bail on functions and non-\/\+POJOs, stops attackers from executing arbitrary code. Strings generated by {\ttfamily uneval} can be safely deserialized with {\ttfamily eval} or {\ttfamily new Function}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ value\ =\ (0,\ eval)('('\ +\ str\ +\ ')');}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md11882}{}\doxysubsection{\texorpdfstring{Other security considerations}{Other security considerations}}\label{README.md_autotoc_md11882}
While {\ttfamily uneval} prevents the XSS vulnerability shown above, meaning you can use it to send data from server to client, {\bfseries{you should not send user data from client to server}} using the same method. Since it has to be evaluated, an attacker that successfully submitted data that bypassed {\ttfamily uneval} would have access to your system.

When using {\ttfamily eval}, ensure that you call it {\itshape indirectly} so that the evaluated code doesn\textquotesingle{}t have access to the surrounding scope\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ const\ sensitiveData\ =\ 'Setec\ Astronomy';}
\DoxyCodeLine{\ \ \ \ eval('sendToEvilServer(sensitiveData)');\ //\ pwned\ :(}
\DoxyCodeLine{\ \ \ \ (0,\ eval)('sendToEvilServer(sensitiveData)');\ //\ nice\ try,\ evildoer!}
\DoxyCodeLine{\}}

\end{DoxyCode}


Using {\ttfamily new Function(code)} is akin to using indirect eval.\hypertarget{README.md_autotoc_md11883}{}\doxysubsection{\texorpdfstring{See also}{See also}}\label{README.md_autotoc_md11883}

\begin{DoxyItemize}
\item \href{https://github.com/jed/lave}{\texttt{ lave}} by Jed Schmidt
\item \href{https://github.com/benjamn/arson}{\texttt{ arson}} by Ben Newman. The {\ttfamily stringify}/{\ttfamily parse} approach in {\ttfamily devalue} was inspired by {\ttfamily arson}
\item \href{https://github.com/KnorpelSenf/oson}{\texttt{ oson}} by Steffen Trog
\item \href{https://github.com/marcello3d/node-tosource}{\texttt{ tosource}} by Marcello BastÃ©a-\/\+Forte
\item \href{https://github.com/yahoo/serialize-javascript}{\texttt{ serialize-\/javascript}} by Eric Ferraiuolo
\item \href{https://github.com/mathiasbynens/jsesc}{\texttt{ jsesc}} by Mathias Bynens
\item \href{https://github.com/blitz-js/superjson}{\texttt{ superjson}} by Blitz
\item \href{https://github.com/iccicci/next-json}{\texttt{ next-\/json}} by Daniele Ricci
\end{DoxyItemize}\hypertarget{README.md_autotoc_md11884}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md11884}
\mbox{[}MIT\mbox{]}(LICENSE) 