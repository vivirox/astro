\doxysection{node\+\_\+modules/flexsearch Directory Reference}
\hypertarget{dir_bab3eda634265ca29c1751cd3dbf8269}{}\label{dir_bab3eda634265ca29c1751cd3dbf8269}\index{node\_modules/flexsearch Directory Reference@{node\_modules/flexsearch Directory Reference}}


\doxysubsection{Detailed Description}
\doxysubsection*{  }

\doxysubsubsubsection*{Web\textquotesingle{}s fastest and most memory-\/flexible full-\/text search library with zero dependencies.}

\href{https://www.npmjs.com/package/flexsearch}{\texttt{ }} \href{https://github.com/nextapps-de/flexsearch/blob/master/LICENSE.md}{\texttt{ }}

\href{\#installation}{\texttt{ Basic Start}} \enskip{}\textbullet{}\enskip{} \href{\#api}{\texttt{ API Reference}} \enskip{}\textbullet{}\enskip{} \href{\#builds}{\texttt{ Document Indexes}} \enskip{}\textbullet{}\enskip{} Using Worker \enskip{}\textbullet{}\enskip{} \href{CHANGELOG.md}{\texttt{ Changelog}}\hypertarget{README.md_autotoc_md15652}{}\doxysubsubsubsection{\texorpdfstring{Flex\+Search v0.\+7.\+0}{Flex\+Search v0.\+7.\+0}}\label{README.md_autotoc_md15652}
The new version is finally available. Flex\+Search v0.\+7.\+0 is a modern re-\/implementation and was newly developed from the ground up. The result is an improvement in every single aspect and covers tons of enhancements and improvements which was collected over the last 3 years.

This new version has a good compatibility with the old generation, but it might require some migrations steps in your code.

Read the documentation of new features and changes\+:~\newline
 \href{https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0.md}{\texttt{ https\+://github.\+com/nextapps-\/de/flexsearch/blob/master/doc/0.\+7.\+0.\+md}}

Read the documentation of new language encoding features\+:~\newline
 \href{https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0-lang.md}{\texttt{ https\+://github.\+com/nextapps-\/de/flexsearch/blob/master/doc/0.\+7.\+0-\/lang.\+md}}

\doxysubsection*{}

When it comes to raw search speed \href{https://nextapps-de.github.io/flexsearch/bench/}{\texttt{ Flex\+Search outperforms every single searching library out there}} and also provides flexible search capabilities like multi-\/field search, phonetic transformations or partial matching.

Depending on the used \href{\#options}{\texttt{ options}} it also provides the \href{\#memory}{\texttt{ most memory-\/efficient index}}. Flex\+Search introduce a new scoring algorithm called \href{\#contextual}{\texttt{ "{}contextual index"{}}} based on a \href{\#dictionary}{\texttt{ pre-\/scored lexical dictionary}} architecture which actually performs queries up to 1,000,000 times faster compared to other libraries. Flex\+Search also provides you a non-\/blocking asynchronous processing model as well as web workers to perform any updates or queries on the index in parallel through dedicated balanced threads.

Supported Platforms\+:
\begin{DoxyItemize}
\item Browser
\item Node.\+js
\end{DoxyItemize}

Library Comparison "{}\+Gulliver\textquotesingle{}s Travels"{}\+:
\begin{DoxyItemize}
\item \href{https://nextapps-de.github.io/flexsearch/bench/}{\texttt{ Performance Benchmark}}
\item \href{https://nextapps-de.github.io/flexsearch/bench/match.html}{\texttt{ Scoring Benchmark}}
\item \href{\#consumption}{\texttt{ Memory Consumption}}
\end{DoxyItemize}

Plugins (extern projects)\+:
\begin{DoxyItemize}
\item \href{https://github.com/angeloashmore/react-use-flexsearch}{\texttt{ https\+://github.\+com/angeloashmore/react-\/use-\/flexsearch}}
\item \href{https://www.gatsbyjs.org/packages/gatsby-plugin-flexsearch/}{\texttt{ https\+://www.\+gatsbyjs.\+org/packages/gatsby-\/plugin-\/flexsearch/}}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md15653}{}\doxysubsubsubsection{\texorpdfstring{Get Latest Stable Build (Recommended)}{Get Latest Stable Build (Recommended)}}\label{README.md_autotoc_md15653}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\multicolumn{3}{|l|}{}\\\cline{1-3}
Build &File &CDN  \\\cline{1-3}
flexsearch.\+bundle.\+js &\href{https://github.com/nextapps-de/flexsearch/raw/0.7.31/dist/flexsearch.bundle.js}{\texttt{ Download}} &\href{https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.bundle.js}{\texttt{ https\+://rawcdn.\+githack.\+com/nextapps-\/de/flexsearch/0.\+7.\+31/dist/flexsearch.\+bundle.\+js}}  \\\cline{1-3}
\\\cline{1-3}
\end{longtabu}


flexsearch.\+light.\+js 

\href{https://github.com/nextapps-de/flexsearch/raw/0.7.31/dist/flexsearch.light.js}{\texttt{ Download}} 

\href{https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.light.js}{\texttt{ https\+://rawcdn.\+githack.\+com/nextapps-\/de/flexsearch/0.\+7.\+31/dist/flexsearch.\+light.\+js}}  

flexsearch.\+compact.\+js 

\href{https://github.com/nextapps-de/flexsearch/raw/0.7.31/dist/flexsearch.compact.js}{\texttt{ Download}} 

\href{https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.compact.js}{\texttt{ https\+://rawcdn.\+githack.\+com/nextapps-\/de/flexsearch/0.\+7.\+31/dist/flexsearch.\+compact.\+js}}  

flexsearch.\+es5.\+js \texorpdfstring{$\ast$}{*} 

\href{https://github.com/nextapps-de/flexsearch/raw/0.7.31/dist/flexsearch.es5.js}{\texttt{ Download}} 

\href{https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.es5.js}{\texttt{ https\+://rawcdn.\+githack.\+com/nextapps-\/de/flexsearch/0.\+7.\+31/dist/flexsearch.\+es5.\+js}}  

ES6 Modules 

\href{https://minhaskamal.github.io/DownGit/\#/home?url=https://github.com/nextapps-de/flexsearch/tree/0.7.31/dist/module/}{\texttt{ Download}} 

The {\itshape /dist/module/} folder of this Github repository  

\texorpdfstring{$\ast$}{*} The bundle "{}flexsearch.\+es5.\+js"{} includes polyfills for Ecma\+Script 5 Support.\hypertarget{README.md_autotoc_md15654}{}\doxysubsubsubsubsection{\texorpdfstring{Get Latest (NPM)}{Get Latest (NPM)}}\label{README.md_autotoc_md15654}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ flexsearch}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15655}{}\doxysubsubsubsubsection{\texorpdfstring{Get Latest Nightly (Do not use for production!)}{Get Latest Nightly (Do not use for production!)}}\label{README.md_autotoc_md15655}
Just exchange the version number from the URLs above with "{}master"{}, e.\+g.\+: "{}/flexsearch/\+\_\+\+\_\+0.\+7.\+31\+\_\+\+\_\+/dist/"{} into "{}/flexsearch/\+\_\+\+\_\+master\+\_\+\+\_\+/dist"{}.\hypertarget{README.md_autotoc_md15656}{}\doxysubsubsubsection{\texorpdfstring{Compare Web-\/\+Bundles}{Compare Web-\/\+Bundles}}\label{README.md_autotoc_md15656}
\begin{quote}
The Node.\+js package includes all features from {\ttfamily flexsearch.\+bundle.\+js}. \end{quote}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\multicolumn{4}{|l|}{}\\\cline{1-4}
Feature &flexsearch.\+bundle.\+js &flexsearch.\+compact.\+js &flexsearch.\+light.\+js  \\\cline{1-4}
\href{\#presets}{\texttt{ Presets}}  &✓ &✓ &-\/  \\\cline{1-4}
\\\cline{1-4}
\end{longtabu}


\href{\#async}{\texttt{ Async Search}}  

✓ 

✓ 

-\/  

\href{\#webworker}{\texttt{ Workers (Web + Node.\+js)}}  

✓ 

-\/ 

-\/  

\href{\#contextual}{\texttt{ Contextual Indexes}}  

✓ 

✓ 

✓  

\href{\#docs}{\texttt{ Index Documents (Field-\/\+Search)}}  

✓ 

✓ 

-\/  

\href{\#store}{\texttt{ Document Store}}  

✓ 

✓ 

-\/  

\href{\#tokenizer}{\texttt{ Partial Matching}}  

✓ 

✓ 

✓  

Relevance Scoring  

✓ 

✓ 

✓  

\href{\#cache}{\texttt{ Auto-\/\+Balanced Cache by Popularity}}  

✓ 

-\/ 

-\/  

\href{\#tags}{\texttt{ Tags}}  

✓ 

-\/ 

-\/  

\href{\#suggestions}{\texttt{ Suggestions}}  

✓ 

✓ 

-\/  

\href{\#phonetic}{\texttt{ Phonetic Matching}}  

✓ 

✓ 

-\/  

Customizable Charset/\+Language (Matcher, Encoder, Tokenizer, Stemmer, Filter, Split, RTL) 

✓ 

✓ 

✓  

\href{\#export}{\texttt{ Export / Import Indexes}} 

✓ 

-\/ 

-\/  

File Size (gzip) 

6.\+8 kb 

5.\+3 kb 

2.\+9 kb  

\label{README.md_compare}%
\Hypertarget{README.md_compare}%
 \hypertarget{README.md_autotoc_md15657}{}\doxysubsubsection{\texorpdfstring{Performance Benchmark (Ranking)}{Performance Benchmark (Ranking)}}\label{README.md_autotoc_md15657}
Run Comparison\+: \href{https://nextapps-de.github.io/flexsearch/bench/}{\texttt{ Performance Benchmark "{}\+Gulliver\textquotesingle{}s Travels"{}}}

Operation per seconds, higher is better, except the test "{}\+Memory"{} on which lower is better.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{8}{|X[-1]}|}
\hline
\multicolumn{8}{|l|}{}\\\cline{1-8}
Rank &Library &Memory &Query (Single Term) &Query (Multi Term) &Query (Long) &Query (Dupes) &Query (Not Found) ~\newline
  \\\cline{1-8}
1 &Flex\+Search &{\bfseries{17}} &{\bfseries{7084129}} &{\bfseries{1586856}} &{\bfseries{511585}} &{\bfseries{2017142}} &3202006  \\\cline{1-8}
\\\cline{1-8}
\end{longtabu}


2 

JSii 

27 

6564 

158149 

61290 

95098 

534109  

3 

Wade 

424 

20471 

78780 

16693 

225824 

213754  

4 

JS Search 

193 

8221 

64034 

10377 

95830 

167605  

5 

Elasticlunr.\+js 

646 

5412 

7573 

2865 

23786 

13982  

6 

Bulk\+Search 

1021 

3069 

3141 

3333 

3265 

{\bfseries{21825569}}  

7 

Mini\+Search 

24348 

4406 

10945 

72 

39989 

17624  

8 

bm25 

15719 

1429 

789 

366 

884 

1823  

9 

Lunr.\+js 

2219 

255 

271 

272 

266 

267  

10 

Fuzzy\+Search 

157373 

53 

38 

15 

32 

43  

11 

Fuse 

7641904 

6 

2 

1 

2 

3  

\label{README.md_contextual}%
\Hypertarget{README.md_contextual}%
 \hypertarget{README.md_autotoc_md15658}{}\doxysubsubsection{\texorpdfstring{Contextual Search}{Contextual Search}}\label{README.md_autotoc_md15658}
\begin{quote}
{\bfseries{Note\+:}} This feature is disabled by default because of its extended memory usage. Read \href{\#contextual_enable}{\texttt{ here}} get more information about and how to enable. \end{quote}


Flex\+Search introduce a new scoring mechanism called {\bfseries{Contextual Search}} which was invented by \href{https://github.com/ts-thomas}{\texttt{ Thomas Wilkerling}}, the author of this library. A Contextual Search \href{https://nextapps-de.github.io/flexsearch/bench/}{\texttt{ incredibly boost up queries to a complete new level}} but also requires some additional memory (depending on \+\_\+\+\_\+\+\_\+depth\+\_\+\+\_\+\+\_\+). The basic idea of this concept is to limit relevance by its context instead of calculating relevance through the whole distance of its corresponding document. This way contextual search also \href{https://nextapps-de.github.io/flexsearch/bench/match.html}{\texttt{ improves the results of relevance-\/based queries}} on a large amount of text data.

 

\label{README.md_installation}%
\Hypertarget{README.md_installation}%
 \hypertarget{README.md_autotoc_md15659}{}\doxysubsubsection{\texorpdfstring{Load Library}{Load Library}}\label{README.md_autotoc_md15659}
There are 3 types of indexes\+:


\begin{DoxyEnumerate}
\item {\ttfamily Index} is a flat high performance index which stores id-\/content-\/pairs.
\item {\ttfamily Worker} / {\ttfamily Worker\+Index} is also a flat index which stores id-\/content-\/pairs but runs in background as a dedicated worker thread.
\item {\ttfamily Document} is multi-\/field index which can store complex JSON documents (could also exist of worker indexes).
\end{DoxyEnumerate}

The most of you probably need just one of them according to your scenario.\hypertarget{README.md_autotoc_md15660}{}\doxysubsubsubsection{\texorpdfstring{ES6 Modules (Browser)\+:}{ES6 Modules (Browser)\+:}}\label{README.md_autotoc_md15660}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ Index\ from\ "{}./index.js"{};}
\DoxyCodeLine{import\ Document\ from\ "{}./document.js"{};}
\DoxyCodeLine{import\ WorkerIndex\ from\ "{}./worker/index.js"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ new\ Index(options);}
\DoxyCodeLine{const\ document\ =\ new\ Document(options);}
\DoxyCodeLine{const\ worker\ =\ new\ WorkerIndex(options);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15661}{}\doxysubsubsubsection{\texorpdfstring{Bundle (Browser)}{Bundle (Browser)}}\label{README.md_autotoc_md15661}

\begin{DoxyCode}{0}
\DoxyCodeLine{<html>}
\DoxyCodeLine{<head>}
\DoxyCodeLine{\ \ \ \ <script\ src="{}js/flexsearch.bundle.js"{}></script>}
\DoxyCodeLine{</head>}
\DoxyCodeLine{...}

\end{DoxyCode}


Or via CDN\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}https://cdn.jsdelivr.net/gh/nextapps-\/de/flexsearch@0.7.31/dist/flexsearch.bundle.js"{}></script>}

\end{DoxyCode}


AMD\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ FlexSearch\ =\ require("{}./flexsearch.js"{});}

\end{DoxyCode}


Load one of the builds from the folder \href{https://github.com/nextapps-de/flexsearch/tree/0.7.31/dist}{\texttt{ dist}} within your html as a script and use as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch.Index(options);}
\DoxyCodeLine{var\ document\ =\ new\ FlexSearch.Document(options);}
\DoxyCodeLine{var\ worker\ =\ new\ FlexSearch.Worker(options);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15662}{}\doxysubsubsubsection{\texorpdfstring{Node.\+js}{Node.\+js}}\label{README.md_autotoc_md15662}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ flexsearch}

\end{DoxyCode}


In your code include as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{\ Index,\ Document,\ Worker\ \}\ =\ require("{}flexsearch"{});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ new\ Index(options);}
\DoxyCodeLine{const\ document\ =\ new\ Document(options);}
\DoxyCodeLine{const\ worker\ =\ new\ Worker(options);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15663}{}\doxysubsubsection{\texorpdfstring{Basic Usage and Variants}{Basic Usage and Variants}}\label{README.md_autotoc_md15663}

\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(id,\ text);}
\DoxyCodeLine{index.search(text);}
\DoxyCodeLine{index.search(text,\ limit);}
\DoxyCodeLine{index.search(text,\ options);}
\DoxyCodeLine{index.search(text,\ limit,\ options);}
\DoxyCodeLine{index.search(options);}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{document.add(doc);}
\DoxyCodeLine{document.add(id,\ doc);}
\DoxyCodeLine{document.search(text);}
\DoxyCodeLine{document.search(text,\ limit);}
\DoxyCodeLine{document.search(text,\ options);}
\DoxyCodeLine{document.search(text,\ limit,\ options);}
\DoxyCodeLine{document.search(options);}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{worker.add(id,\ text);}
\DoxyCodeLine{worker.search(text);}
\DoxyCodeLine{worker.search(text,\ limit);}
\DoxyCodeLine{worker.search(text,\ options);}
\DoxyCodeLine{worker.search(text,\ limit,\ options);}
\DoxyCodeLine{worker.search(text,\ limit,\ options,\ callback);}
\DoxyCodeLine{worker.search(options);}

\end{DoxyCode}


The {\ttfamily worker} inherits from type {\ttfamily Index} and does not inherit from type {\ttfamily Document}. Therefore, a Worker\+Index basically works like a standard Flex\+Search Index. Worker-\/\+Support in documents needs to be enabled by just passing the appropriate option during creation {\ttfamily \{ worker\+: true \}}.

\begin{quote}
Every method called on a {\ttfamily Worker} index is treated as async. You will get back a {\ttfamily Promise} or you can provide a callback function as the last parameter alternatively. \end{quote}


\label{README.md_api}%
\Hypertarget{README.md_api}%
 \hypertarget{README.md_autotoc_md15664}{}\doxysubsubsection{\texorpdfstring{API Overview}{API Overview}}\label{README.md_autotoc_md15664}
Global methods\+:


\begin{DoxyItemize}
\item \href{\#flexsearch.register}{\texttt{ Flex\+Search.\+\_\+\+\_\+register\+Charset\+\_\+\+\_\+(name, charset)}}
\item \href{\#flexsearch.language}{\texttt{ Flex\+Search.\+\_\+\+\_\+register\+Language\+\_\+\+\_\+(name, language)}}
\end{DoxyItemize}

Index methods\+:


\begin{DoxyItemize}
\item \href{\#index.add}{\texttt{ Index.\+\_\+\+\_\+add\+\_\+\+\_\+(id, string)}} \texorpdfstring{$\ast$}{*}
\item \href{\#index.append}{\texttt{ Index.\+\_\+\+\_\+append\+\_\+\+\_\+(id, string)}} \texorpdfstring{$\ast$}{*}
\item \href{\#index.update}{\texttt{ Index.\+\_\+\+\_\+update\+\_\+\+\_\+(id, string)}} \texorpdfstring{$\ast$}{*}
\item \href{\#index.remove}{\texttt{ Index.\+\_\+\+\_\+remove\+\_\+\+\_\+(id)}} \texorpdfstring{$\ast$}{*}
\item \href{\#index.search}{\texttt{ Index.\+\_\+\+\_\+search\+\_\+\+\_\+(string, \texorpdfstring{$<$}{<}limit\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}options\texorpdfstring{$>$}{>})}} \texorpdfstring{$\ast$}{*}
\item \href{\#index.search}{\texttt{ Index.\+\_\+\+\_\+search\+\_\+\+\_\+(options)}} \texorpdfstring{$\ast$}{*}
\item {\itshape async} \href{\#index.export}{\texttt{ Index.\+\_\+\+\_\+export\+\_\+\+\_\+(handler)}}
\item {\itshape async} \href{\#index.import}{\texttt{ Index.\+\_\+\+\_\+import\+\_\+\+\_\+(key, data)}}
\end{DoxyItemize}

Worker\+Index methods\+:


\begin{DoxyItemize}
\item {\itshape async} \href{\#index.add}{\texttt{ Index.\+\_\+\+\_\+add\+\_\+\+\_\+(id, string)}}
\item {\itshape async} \href{\#index.append}{\texttt{ Index.\+\_\+\+\_\+append\+\_\+\+\_\+(id, string)}}
\item {\itshape async} \href{\#index.update}{\texttt{ Index.\+\_\+\+\_\+update\+\_\+\+\_\+(id, string)}}
\item {\itshape async} \href{\#index.remove}{\texttt{ Index.\+\_\+\+\_\+remove\+\_\+\+\_\+(id)}}
\item {\itshape async} \href{\#index.search}{\texttt{ Index.\+\_\+\+\_\+search\+\_\+\+\_\+(string, \texorpdfstring{$<$}{<}limit\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}options\texorpdfstring{$>$}{>})}}
\item {\itshape async} \href{\#index.search}{\texttt{ Index.\+\_\+\+\_\+search\+\_\+\+\_\+(options)}}
\item {\itshape async} \href{\#index.export}{\texttt{ \sout{Index.\+\_\+\+\_\+export\+\_\+\+\_\+(handler)}}} (WIP)
\item {\itshape async} \href{\#index.import}{\texttt{ \sout{Index.\+\_\+\+\_\+import\+\_\+\+\_\+(key, data)}}} (WIP)
\end{DoxyItemize}

Document methods\+:


\begin{DoxyItemize}
\item \href{\#document.add}{\texttt{ Document.\+\_\+\+\_\+add\+\_\+\+\_\+(\texorpdfstring{$<$}{<}id\texorpdfstring{$>$}{>}, document)}} \texorpdfstring{$\ast$}{*}
\item \href{\#document.append}{\texttt{ Document.\+\_\+\+\_\+append\+\_\+\+\_\+(\texorpdfstring{$<$}{<}id\texorpdfstring{$>$}{>}, document)}} \texorpdfstring{$\ast$}{*}
\item \href{\#document.update}{\texttt{ Document.\+\_\+\+\_\+update\+\_\+\+\_\+(\texorpdfstring{$<$}{<}id\texorpdfstring{$>$}{>}, document)}} \texorpdfstring{$\ast$}{*}
\item \href{\#document.remove}{\texttt{ Document.\+\_\+\+\_\+remove\+\_\+\+\_\+(id \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} document)}} \texorpdfstring{$\ast$}{*}
\item \href{\#document.search}{\texttt{ Document.\+\_\+\+\_\+search\+\_\+\+\_\+(string, \texorpdfstring{$<$}{<}limit\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}options\texorpdfstring{$>$}{>})}} \texorpdfstring{$\ast$}{*}
\item \href{\#document.search}{\texttt{ Document.\+\_\+\+\_\+search\+\_\+\+\_\+(options)}} \texorpdfstring{$\ast$}{*}
\item {\itshape async} \href{\#document.export}{\texttt{ Document.\+\_\+\+\_\+export\+\_\+\+\_\+(handler)}}
\item {\itshape async} \href{\#document.import}{\texttt{ Document.\+\_\+\+\_\+import\+\_\+\+\_\+(key, data)}}
\end{DoxyItemize}

\texorpdfstring{$\ast$}{*} For each of those methods there exist an asynchronous equivalent\+:

Async Version\+:


\begin{DoxyItemize}
\item {\itshape async} \href{\#addAsync}{\texttt{ .\+\_\+\+\_\+add\+Async\+\_\+\+\_\+( ... , \texorpdfstring{$<$}{<}callback\texorpdfstring{$>$}{>})}}
\item {\itshape async} \href{\#appendAsync}{\texttt{ .\+\_\+\+\_\+append\+Async\+\_\+\+\_\+( ... , \texorpdfstring{$<$}{<}callback\texorpdfstring{$>$}{>})}}
\item {\itshape async} \href{\#updateAsync}{\texttt{ .\+\_\+\+\_\+update\+Async\+\_\+\+\_\+( ... , \texorpdfstring{$<$}{<}callback\texorpdfstring{$>$}{>})}}
\item {\itshape async} \href{\#removeAsync}{\texttt{ .\+\_\+\+\_\+remove\+Async\+\_\+\+\_\+( ... , \texorpdfstring{$<$}{<}callback\texorpdfstring{$>$}{>})}}
\item {\itshape async} \href{\#searchAsync}{\texttt{ .\+\_\+\+\_\+search\+Async\+\_\+\+\_\+( ... , \texorpdfstring{$<$}{<}callback\texorpdfstring{$>$}{>})}}
\end{DoxyItemize}

Async methods will return a {\ttfamily Promise}, alternatively you can pass a callback function as the last parameter.

Methods {\ttfamily export} and also {\ttfamily import} are always async as well as every method you call on a Worker-\/based Index.

\label{README.md_options}%
\Hypertarget{README.md_options}%
 \hypertarget{README.md_autotoc_md15665}{}\doxysubsubsection{\texorpdfstring{Options}{Options}}\label{README.md_autotoc_md15665}
Flex\+Search is highly customizable. Make use of the right options can really improve your results as well as memory economy and query time.

\label{README.md_options-index}%
\Hypertarget{README.md_options-index}%
 \hypertarget{README.md_autotoc_md15666}{}\doxysubsubsubsection{\texorpdfstring{Index Options}{Index Options}}\label{README.md_autotoc_md15666}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\multicolumn{4}{|l|}{}\\\cline{1-4}
Option &Values &Description &Default  \\\cline{1-4}
preset &"{}memory"{}~\newline
 "{}performance"{}~\newline
 "{}match"{}~\newline
 "{}score"{}~\newline
 "{}default"{}  &The \href{\#presets}{\texttt{ configuration profile}} as a shortcut or as a base for your custom settings.~\newline
  &"{}default"{}  \\\cline{1-4}
\\\cline{1-4}
\end{longtabu}


tokenize 

"{}strict"{}~\newline
 "{}forward"{}~\newline
 "{}reverse"{}~\newline
 "{}full"{}  

The \href{\#tokenizer}{\texttt{ indexing mode (tokenizer)}}.~\newline
~\newline
Choose one of the \href{\#tokenizer}{\texttt{ built-\/ins}} or pass a \href{\#flexsearch.tokenizer}{\texttt{ custom tokenizer function}}.~\newline
  

"{}strict"{}  

cache 

Boolean~\newline
 Number  

Enable/\+Disable and/or set capacity of cached entries.~\newline
~\newline
When passing a number as a limit the {\bfseries{cache automatically balance stored entries related to their popularity}}.~\newline
~\newline
Note\+: When just using "{}true"{} the cache has no limits and growth unbounded. 

false  

resolution 

Number  

Sets the scoring resolution (default\+: 9). 

9  

context 

Boolean~\newline
 Context Options  

Enable/\+Disable \href{\#contextual}{\texttt{ contextual indexing}}. When passing "{}true"{} as value it will take the default values for the context. 

false  

optimize 

Boolean  

When enabled it uses a memory-\/optimized stack flow for the index. 

true  

boost 

function(arr, str, int) =\texorpdfstring{$>$}{>} float  

A custom boost function used when indexing contents to the index. The function has this signature\+: {\ttfamily Function(words\mbox{[}$\,$\mbox{]}, term, index) =\texorpdfstring{$>$}{>} Float}. It has 3 parameters where you get an array of all words, the current term and the current index where the term is placed in the word array. You can apply your own calculation e.\+g. the occurrences of a term and return this factor (\texorpdfstring{$<$}{<}1 means relevance is lowered, \texorpdfstring{$>$}{>}1 means relevance is increased).~\newline
~\newline
Note\+: this feature is currently limited by using the tokenizer "{}strict"{} only. 

null  

Language-\/specific Options and Encoding\+:   

charset~\newline
~\newline
 

Charset Payload~\newline
 String (key)  

Provide a custom charset payload or pass one of the keys of built-\/in charsets.  

"{}latin"{}  

language~\newline
~\newline
 

Language Payload~\newline
 String (key)  

Provide a custom language payload or pass in language shorthand flag (ISO-\/3166) of built-\/in languages.  

null  

encode~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 

false~\newline
 "{}default"{}~\newline
 "{}simple"{}~\newline
 "{}balance"{}~\newline
 "{}advanced"{}~\newline
 "{}extra"{}~\newline
 function(str) =\texorpdfstring{$>$}{>} \mbox{[}words\mbox{]}  

The encoding type.~\newline
~\newline
Choose one of the \href{\#phonetic}{\texttt{ built-\/ins}} or pass a \href{\#flexsearch.encoder}{\texttt{ custom encoding function}}. 

"{}default"{}  

stemmer~\newline
~\newline
~\newline
 

false~\newline
 String~\newline
 Function  

false  

filter~\newline
~\newline
~\newline
 

false~\newline
 String~\newline
 Function  

false  

matcher~\newline
~\newline
~\newline
 

false~\newline
 String~\newline
 Function  

false  

Additional Options for Document Indexes\+:   

worker~\newline
 

Boolean  

Enable/\+Disable and set count of running worker threads. 

false  

document~\newline
 

Document Descriptor 

Includes definitions for the document index and storage.  

\label{README.md_options-context}%
\Hypertarget{README.md_options-context}%
 \hypertarget{README.md_autotoc_md15667}{}\doxysubsubsubsection{\texorpdfstring{Context Options}{Context Options}}\label{README.md_autotoc_md15667}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\multicolumn{4}{|l|}{}\\\cline{1-4}
Option &Values &Description &Default  \\\cline{1-4}
resolution &Number  &Sets the scoring resolution for the context (default\+: 1). &1  \\\cline{1-4}
\\\cline{1-4}
\end{longtabu}


depth~\newline
~\newline
 

false~\newline
 Number  

Enable/\+Disable \href{\#contextual}{\texttt{ contextual indexing}} and also sets contextual distance of relevance. Depth is the maximum number of words/tokens away a term to be considered as relevant. 

1  

bidirectional 

Boolean  

Sets the scoring resolution (default\+: 9). 

true  

\label{README.md_options-document}%
\Hypertarget{README.md_options-document}%
 \hypertarget{README.md_autotoc_md15668}{}\doxysubsubsubsection{\texorpdfstring{Document Options}{Document Options}}\label{README.md_autotoc_md15668}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\multicolumn{4}{|l|}{}\\\cline{1-4}
Option &Values &Description &Default  \\\cline{1-4}
id~\newline
 &String &&"{}id"{}"{}$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$tag$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$false$<$br$>$\+String$<$/td$>$         $<$td vertical-\/align="{}top"{}$>$$<$/td$>$         $<$td$>$"{}tag"{}$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$index$<$br$>$$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$\+String$<$br$>$\+Array<\+String$>$$<$br$>$\+Array<\+Object$>$$<$/td$>$         $<$td vertical-\/align="{}top"{}$>$$<$/td$>$         $<$td$>$$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$store$<$br$>$$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$\+Boolean$<$br$>$\+String$<$br$>$\+Array<\+String$>$$<$/td$>$         $<$td vertical-\/align="{}top"{}$>$$<$/td$>$         $<$td$>$false$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor options-\/charset $<$a$>$$<$/a$>$ @subsubsection autotoc\+\_\+md15669 Charset Options  $<$table$>$     $<$tr$>$$<$td colspan="{}4"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Values$<$/td$>$         $<$td$>$\+Description$<$/td$>$         $<$td$>$\+Default$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$split$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$             false$<$br$>$             Reg\+Exp$<$br$>$             String         $<$/td$>$         $<$td vertical-\/align="{}top"{}$>$             The rule to split words when using non-\/custom tokenizer ($<$a href="{}\#tokenizer"{}$>$built-\/ins$<$/a$>$ e.\+g. "{}forward"{}). Use a string/char or use a regular expression (default\+: $<$code$>$/\textbackslash{}\+W+/$<$/code$>$).$<$br$>$         $<$/td$>$         $<$td$>$$<$code$>$/\mbox{[}\textbackslash{}\+W\+\_\+\mbox{]}+/$<$/code$>$$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$rtl$<$br$>$$<$/td$>$         $<$td$>$             Boolean         $<$/td$>$         $<$td$>$\+Enables Right-\/\+To-\/\+Left encoding.$<$/td$>$         $<$td$>$false$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$encode$<$br$>$$<$/td$>$         $<$td$>$             function(str) =$>$ \mbox{[}words\mbox{]}         $<$/td$>$         $<$td$>$\+The custom encoding function.$<$/td$>$         $<$td$>$/lang/latin/default.\+js$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor options-\/language $<$a$>$$<$/a$>$ @subsubsection autotoc\+\_\+md15670 Language Options  $<$table$>$     $<$tr$>$$<$td colspan="{}3"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Values$<$/td$>$         $<$td$>$\+Description$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$stemmer$<$br$>$$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$             false$<$br$>$             String$<$br$>$             Function         $<$/td$>$         $<$td$>$\+Disable or pass in language shorthand flag (\+ISO-\/3166) or a custom object.     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$filter$<$br$>$$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$             false$<$br$>$             String$<$br$>$             Function         $<$/td$>$         $<$td$>$\+Disable or pass in language shorthand flag (\+ISO-\/3166) or a custom array.$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$matcher$<$br$>$$<$br$>$$<$br$>$$<$/td$>$         $<$td$>$             false$<$br$>$             String$<$br$>$             Function         $<$/td$>$         $<$td$>$\+Disable or pass in language shorthand flag (\+ISO-\/3166) or a custom array.$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor options-\/search $<$a$>$$<$/a$>$ @subsubsection autotoc\+\_\+md15671 Search Options  $<$table$>$     $<$tr$>$$<$td colspan="{}4"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Values$<$/td$>$         $<$td$>$\+Description$<$/td$>$         $<$td$>$\+Default$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$limit$<$/td$>$         $<$td$>$number$<$/td$>$         $<$td$>$\+Sets the limit of results.$<$/td$>$         $<$td$>$100$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$offset$<$/td$>$         $<$td$>$number$<$/td$>$         $<$td$>$\+Apply offset (skip items).$<$/td$>$         $<$td$>$0$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$suggest$<$/td$>$         $<$td$>$\+Boolean$<$/td$>$         $<$td$>$\+Enables $<$a href="{}\#suggestions"{}$>$suggestions$<$/a$>$ in results.$<$/td$>$         $<$td$>$false$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor options-\/field-\/search $<$a$>$$<$/a$>$ @subsubsection autotoc\+\_\+md15672 Document Search Options  \texorpdfstring{$\ast$}{*} Additionally, to the Index search options above.  $<$table$>$     $<$tr$>$$<$td colspan="{}4"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Values$<$/td$>$         $<$td$>$\+Description$<$/td$>$         $<$td$>$\+Default$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$index$<$/td$>$         $<$td$>$\+String$<$br$>$\+Array<\+String>$<$br$>$\+Array<\+Object>$<$/td$>$         $<$td$>$\+Sets the $<$a href="{}\#docs"{}$>$document fields$<$/a$>$ which should be searched. When no field is set, all fields will be searched. $<$a href="{}\#options-\/field-\/search"{}$>$\+Custom options per field$<$/a$>$ are also supported.$<$/td$>$         $<$td$>$$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$tag$<$/td$>$         $<$td$>$\+String$<$br$>$\+Array<\+String$>$$<$/td$>$         $<$td$>$\+Sets the $<$a href="{}\#docs"{}$>$document fields$<$/a$>$ which should be searched. When no field is set, all fields will be searched. $<$a href="{}\#options-\/field-\/search"{}$>$\+Custom options per field$<$/a$>$ are also supported.$<$/td$>$         $<$td$>$false$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$enrich$<$/td$>$         $<$td$>$\+Boolean$<$/td$>$         $<$td$>$\+Enrich IDs from the results with the corresponding documents.$<$/td$>$         $<$td$>$false$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$bool$<$/td$>$         $<$td$>$"{}and"{}$<$br$>$"{}or"{}$<$/td$>$         $<$td$>$\+Sets the used $<$a href="{}\#operators"{}$>$logical operator$<$/a$>$ when searching through multiple fields or tags.$<$/td$>$         $<$td$>$"{}or"{}$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor tokenizer $<$a$>$$<$/a$>$ @subsection autotoc\+\_\+md15673 Tokenizer (\+Prefix Search)  \+Tokenizer affects the required memory also as query time and flexibility of partial matches. Try to choose the most upper of these tokenizer which fits your needs\+:  $<$table$>$     $<$tr$>$$<$td colspan="{}4"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Description$<$/td$>$         $<$td$>$\+Example$<$/td$>$         $<$td$>$\+Memory Factor (n = length of word)$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}strict"{}$<$/b$>$$<$/td$>$         $<$td$>$index whole words$<$/td$>$         $<$td$>$$<$code$>$foobar$<$/code$>$$<$/td$>$         $<$td$>$\texorpdfstring{$\ast$}{*} 1$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}forward"{}$<$/b$>$$<$/td$>$         $<$td$>$incrementally index words in forward direction$<$/td$>$         $<$td$>$$<$code$>$fo$<$/code$>$obar$<$br$>$$<$code$>$foob$<$/code$>$ar$<$br$>$$<$/td$>$         $<$td$>$\texorpdfstring{$\ast$}{*} n$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}reverse"{}$<$/b$>$$<$/td$>$         $<$td$>$incrementally index words in both directions$<$/td$>$         $<$td$>$foob$<$code$>$ar$<$/code$>$$<$br$>$fo$<$code$>$obar$<$/code$>$$<$/td$>$         $<$td$>$\texorpdfstring{$\ast$}{*} 2n -\/ 1$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}full"{}$<$/b$>$$<$/td$>$         $<$td$>$index every possible combination$<$/td$>$         $<$td$>$fo$<$code$>$oba$<$/code$>$r$<$br$>$f$<$code$>$oob$<$/code$>$ar$<$/td$>$         $<$td$>$\texorpdfstring{$\ast$}{*} n \texorpdfstring{$\ast$}{*} (n -\/ 1)$<$/td$>$     $<$/tr$>$ $<$/table$>$  @anchor phonetic $<$a$>$$<$/a$>$ @subsection autotoc\+\_\+md15674 Encoders  \+Encoding affects the required memory also as query time and phonetic matches. Try to choose the most upper of these encoders which fits your needs, or pass in a $<$a href="{}\#flexsearch.\+encoder"{}$>$custom encoder$<$/a$>$\+:  $<$table$>$     $<$tr$>$$<$td colspan="{}4"{}$>$$<$/td$>$$<$/tr$>$     $<$tr$>$         $<$td$>$\+Option$<$/td$>$         $<$td$>$\+Description$<$/td$>$         $<$td$>$\+False-\/\+Positives$<$/td$>$         $<$td$>$\+Compression$<$/td$>$     $<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$false$<$/b$>$$<$/td$>$         $<$td$>$\+Turn off encoding$<$/td$>$         $<$td$>$no$<$/td$>$         $<$td$>$0\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}default"{}$<$/b$>$$<$/td$>$         $<$td$>$\+Case in-\/sensitive encoding$<$/td$>$         $<$td$>$no$<$/td$>$         $<$td$>$0\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}simple"{}$<$/b$>$$<$/td$>$         $<$td$>$\+Case in-\/sensitive encoding$<$br$>$\+Charset normalizations$<$/td$>$         $<$td$>$no$<$/td$>$         $<$td$>$\texorpdfstring{$\sim$}{\string~} 3\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}balance"{}$<$/b$>$$<$/td$>$         $<$td$>$\+Case in-\/sensitive encoding$<$br$>$\+Charset normalizations$<$br$>$\+Literal transformations$<$/td$>$         $<$td$>$no$<$/td$>$         $<$td$>$\texorpdfstring{$\sim$}{\string~} 30\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}advanced"{}$<$/b$>$$<$/td$>$         $<$td$>$\+Case in-\/sensitive encoding$<$br$>$\+Charset normalizations$<$br$>$\+Literal transformations$<$br$>$\+Phonetic normalizations$<$/td$>$         $<$td$>$no$<$/td$>$         $<$td$>$\texorpdfstring{$\sim$}{\string~} 40\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$"{}extra"{}$<$/b$>$$<$/td$>$         $<$td$>$\+Case in-\/sensitive encoding$<$br$>$\+Charset normalizations$<$br$>$\+Literal transformations$<$br$>$\+Phonetic normalizations$<$br$>$\+Soundex transformations$<$/td$>$         $<$td$>$yes$<$/td$>$         $<$td$>$\texorpdfstring{$\sim$}{\string~} 65\%$<$/td$>$     $<$/tr$>$     $<$tr$>$$<$/tr$>$     $<$tr$>$         $<$td$>$$<$b$>$function()$<$/b$>$$<$/td$>$         $<$td$>$\+Pass custom encoding via $<$i$>$function(string)\+:\mbox{[}words\mbox{]}$<$/i$>$$<$/td$>$         $<$td$>$$<$/td$>$         $<$td$>$$<$/td$>$     $<$/tr$>$ $<$/table$>$  @subsection autotoc\+\_\+md15675 Usage  $<$a name="{}flexsearch.\+create"{}$>$$<$/a$>$ @paragraph autotoc\+\_\+md15676 Create a new index  @icode\{js\}  var index = new Index(); @endicode   \+Create a new index and choosing one of the presets\+:  @icode\{js\}  var index = new Index("{}performance"{}); @endicode   \+Create a new index with custom options\+:  @icode\{js\}  var index = new Index(\{     charset\+: "{}latin\+:extra"{},     tokenize\+: "{}reverse"{},     resolution\+: 9 \}); @endicode   \+Create a new index and extend a preset with custom options\+:  @icode\{js\}  var index = new Flex\+Search(\{     preset\+: "{}memory"{},     tokenize\+: "{}forward"{},     resolution\+: 5 \}); @endicode   $<$a href="{}\#options"{}$>$\+See all available custom options.$<$/a$>$  $<$a name="{}index.\+add"{}\texorpdfstring{$>$}{>} \\\cline{1-4}
\end{longtabu}
\hypertarget{README.md_autotoc_md15677}{}\doxysubsubsubsubsection{\texorpdfstring{Add text item to an index}{Add text item to an index}}\label{README.md_autotoc_md15677}
Every content which should be added to the index needs an ID. When your content has no ID, then you need to create one by passing an index or count or something else as an ID (a value from type {\ttfamily number} is highly recommended). Those IDs are unique references to a given content. This is important when you update or adding over content through existing IDs. When referencing is not a concern, you can simply use something simple like {\ttfamily count++}.

\begin{quote}
Index.\+\_\+\+\_\+add(id, string)\+\_\+\+\_\+ \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(0,\ "{}John\ Doe"{});}

\end{DoxyCode}


\label{_index.search}%
 \hypertarget{README.md_autotoc_md15678}{}\doxysubsubsubsubsection{\texorpdfstring{Search items}{Search items}}\label{README.md_autotoc_md15678}
\begin{quote}
Index.\+\_\+\+\_\+search(string \texorpdfstring{$\vert$}{|} options, \texorpdfstring{$<$}{<}limit\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}options\texorpdfstring{$>$}{>})\+\_\+\+\_\+ \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.search("{}John"{});}

\end{DoxyCode}


Limit the result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search("{}John"{},\ 10);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15679}{}\doxysubsubsubsubsection{\texorpdfstring{Check existence of already indexed IDs}{Check existence of already indexed IDs}}\label{README.md_autotoc_md15679}
You can check if an ID was already indexed by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{if(index.contain(1))\{}
\DoxyCodeLine{\ \ \ \ console.log("{}ID\ is\ already\ in\ index"{});}
\DoxyCodeLine{\}}

\end{DoxyCode}


\label{README.md_async_search}%
\Hypertarget{README.md_async_search}%
 \hypertarget{README.md_autotoc_md15680}{}\doxysubsubsection{\texorpdfstring{Async}{Async}}\label{README.md_autotoc_md15680}
You can call each method in its async version, e.\+g. {\ttfamily index.\+add\+Async} or {\ttfamily index.\+search\+Async}.

You can assign callbacks to each async function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.addAsync(id,\ content,\ function()\{}
\DoxyCodeLine{\ \ \ \ console.log("{}Task\ Done"{});}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.searchAsync(query,\ function(result)\{}
\DoxyCodeLine{\ \ \ \ console.log("{}Results:\ "{},\ result);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Or do not pass a callback function and getting back a {\ttfamily Promise} instead\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.addAsync(id,\ content).then(function()\{}
\DoxyCodeLine{\ \ \ \ console.log("{}Task\ Done"{});}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.searchAsync(query).then(function(result)\{}
\DoxyCodeLine{\ \ \ \ console.log("{}Results:\ "{},\ result);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Or use {\ttfamily async} and {\ttfamily await}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{async\ function\ add()\{}
\DoxyCodeLine{\ \ \ \ await\ index.addAsync(id,\ content);}
\DoxyCodeLine{\ \ \ \ console.log("{}Task\ Done"{});}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{async\ function\ search()\{}
\DoxyCodeLine{\ \ \ \ const\ results\ =\ await\ index.searchAsync(query);}
\DoxyCodeLine{\ \ \ \ console.log("{}Results:\ "{},\ result);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15681}{}\doxysubsubsection{\texorpdfstring{Append Contents}{Append Contents}}\label{README.md_autotoc_md15681}
You can append contents to an existing index like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.append(id,\ content);}

\end{DoxyCode}


This will not overwrite the old indexed contents as it will do when perform {\ttfamily index.\+update(id, content)}. Keep in mind that {\ttfamily index.\+add(id, content)} will also perform "{}update"{} under the hood when the id was already being indexed.

Appended contents will have their own context and also their own full {\ttfamily resolution}. Therefore, the relevance isn\textquotesingle{}t being stacked but gets its own context.

Let us take this example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(0,\ "{}some\ index"{});}
\DoxyCodeLine{index.append(0,\ "{}some\ appended\ content"{});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(1,\ "{}some\ text"{});}
\DoxyCodeLine{index.append(1,\ "{}index\ appended\ content"{});}

\end{DoxyCode}


When you query {\ttfamily index.\+search("{}index"{})} then you will get index id 1 as the first entry in the result, because the context starts from zero for the appended data (isn\textquotesingle{}t stacked to the old context) and here "{}index"{} is the first term.

If you didn\textquotesingle{}t want this behavior than just use the standard {\ttfamily index.\+add(id, content)} and provide the full length of content.

\label{_index.update}%
 \hypertarget{README.md_autotoc_md15682}{}\doxysubsubsubsubsection{\texorpdfstring{Update item from an index}{Update item from an index}}\label{README.md_autotoc_md15682}
\begin{quote}
Index.\+\_\+\+\_\+update(id, string)\+\_\+\+\_\+ \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.update(0,\ "{}Max\ Miller"{});}

\end{DoxyCode}


\label{_index.remove}%
 \hypertarget{README.md_autotoc_md15683}{}\doxysubsubsubsubsection{\texorpdfstring{Remove item from an index}{Remove item from an index}}\label{README.md_autotoc_md15683}
\begin{quote}
Index.\+\_\+\+\_\+remove(id)\+\_\+\+\_\+ \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.remove(0);}

\end{DoxyCode}


\label{_flexsearch.tokenizer}%
 \hypertarget{README.md_autotoc_md15684}{}\doxysubsubsubsubsection{\texorpdfstring{Add custom tokenizer}{Add custom tokenizer}}\label{README.md_autotoc_md15684}
\begin{quote}
A tokenizer split words/terms into components or partials. \end{quote}


Define a private custom tokenizer during creation/initialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch(\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tokenize:\ function(str)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ str.split(/\(\backslash\)s-\/\(\backslash\)//g);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
The tokenizer function gets a string as a parameter and has to return an array of strings representing a word or term. In some languages every char is a term and also not separated via whitespaces. \end{quote}


\label{_flexsearch.language}%
 \hypertarget{README.md_autotoc_md15685}{}\doxysubsubsubsubsection{\texorpdfstring{Add language-\/specific stemmer and/or filter}{Add language-\/specific stemmer and/or filter}}\label{README.md_autotoc_md15685}
\begin{quote}
{\bfseries{Stemmer\+:}} several linguistic mutations of the same word (e.\+g. "{}run"{} and "{}running"{}) \end{quote}


\begin{quote}
{\bfseries{Filter\+:}} a blacklist of words to be filtered out from indexing at all (e.\+g. "{}and"{}, "{}to"{} or "{}be"{}) \end{quote}


Assign a private custom stemmer or filter during creation/initialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch(\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ stemmer:\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ object\ \{key:\ replacement\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}ational"{}:\ "{}ate"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}tional"{}:\ "{}tion"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}enci"{}:\ "{}ence"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}ing"{}:\ "{}"{}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ filter:\ [}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ array\ blacklist}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}in"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}into"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}is"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}isn't"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}it"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}it's"{}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\});}

\end{DoxyCode}


Using a custom filter, e.\+g.\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch(\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ filter:\ function(value)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ just\ add\ values\ with\ length\ >\ 1\ to\ the\ index}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ value.length\ >\ 1;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


Or assign stemmer/filters globally to a language\+:

\begin{quote}
Stemmer are passed as a object (key-\/value-\/pair), filter as an array. \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{FlexSearch.registerLanguage("{}us"{},\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ stemmer:\ \{\ /*\ ...\ */\ \},}
\DoxyCodeLine{\ \ \ \ filter:\ \ [\ /*\ ...\ */\ ]}
\DoxyCodeLine{\});}

\end{DoxyCode}


Or use some pre-\/defined stemmer or filter of your preferred languages\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{<html>}
\DoxyCodeLine{<head>}
\DoxyCodeLine{\ \ \ \ <script\ src="{}js/flexsearch.bundle.js"{}></script>}
\DoxyCodeLine{\ \ \ \ <script\ src="{}js/lang/en.min.js"{}></script>}
\DoxyCodeLine{\ \ \ \ <script\ src="{}js/lang/de.min.js"{}></script>}
\DoxyCodeLine{</head>}
\DoxyCodeLine{...}

\end{DoxyCode}


Now you can assign built-\/in stemmer during creation/initialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\_en\ =\ new\ FlexSearch.Index(\{}
\DoxyCodeLine{\ \ \ \ language:\ "{}en"{}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ index\_de\ =\ new\ FlexSearch.Index(\{}
\DoxyCodeLine{\ \ \ \ language:\ "{}de"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


In Node.\+js all built-\/in language packs files are available\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{\ Index\ \}\ =\ require("{}flexsearch"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ index\_en\ =\ new\ Index(\{}
\DoxyCodeLine{\ \ \ \ language:\ "{}en"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\label{README.md_rtl}%
\Hypertarget{README.md_rtl}%
 \hypertarget{README.md_autotoc_md15686}{}\doxysubsubsubsection{\texorpdfstring{Right-\/\+To-\/\+Left Support}{Right-\/\+To-\/\+Left Support}}\label{README.md_autotoc_md15686}
\begin{quote}
Set the tokenizer at least to "{}reverse"{} or "{}full"{} when using RTL. \end{quote}


Just set the field "{}rtl"{} to {\itshape true} and use a compatible tokenizer\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ Index(\{}
\DoxyCodeLine{\ \ \ \ encode:\ str\ =>\ str.toLowerCase().split(/[\string^a-\/z]+/),}
\DoxyCodeLine{\ \ \ \ tokenize:\ "{}reverse"{},}
\DoxyCodeLine{\ \ \ \ rtl:\ true}
\DoxyCodeLine{\});}

\end{DoxyCode}


\label{README.md_cjk}%
\Hypertarget{README.md_cjk}%
 \hypertarget{README.md_autotoc_md15687}{}\doxysubsubsubsection{\texorpdfstring{CJK Word Break (Chinese, Japanese, Korean)}{CJK Word Break (Chinese, Japanese, Korean)}}\label{README.md_autotoc_md15687}
Set a custom tokenizer which fits your needs, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ FlexSearch.create(\{}
\DoxyCodeLine{\ \ \ \ encode:\ str\ =>\ str.replace(/[\(\backslash\)x00-\/\(\backslash\)x7F]/g,\ "{}"{}).split("{}"{})}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can also pass a custom encoder function to apply some linguistic transformations.


\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(0,\ "{}一个单词"{});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{var\ results\ =\ index.search("{}单词"{});}

\end{DoxyCode}


\label{README.md_docs}%
\Hypertarget{README.md_docs}%
 \hypertarget{README.md_autotoc_md15688}{}\doxysubsubsection{\texorpdfstring{Index Documents (Field-\/\+Search)}{Index Documents (Field-\/\+Search)}}\label{README.md_autotoc_md15688}
\hypertarget{README.md_autotoc_md15689}{}\doxysubsubsubsection{\texorpdfstring{The Document Descriptor}{The Document Descriptor}}\label{README.md_autotoc_md15689}
Assuming our document has a data structure like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\ }
\DoxyCodeLine{\ \ \ \ "{}id"{}:\ 0,\ }
\DoxyCodeLine{\ \ \ \ "{}content"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Old syntax Flex\+Search v0.\+6.\+3 (\+\_\+\+\_\+\+\_\+not supported anymore!\+\_\+\+\_\+\+\_\+)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ doc:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ field:\ ["{}content"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
The document descriptor has slightly changed, there is no {\ttfamily field} branch anymore, instead just apply one level higher, so {\ttfamily key} becomes a main member of options. \end{quote}


For the new syntax the field "{}doc"{} was renamed to {\ttfamily document} and the field "{}field"{} was renamed to {\ttfamily index}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ ["{}content"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(\{\ }
\DoxyCodeLine{\ \ \ \ id:\ 0,\ }
\DoxyCodeLine{\ \ \ \ content:\ "{}some\ text"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


The field {\ttfamily id} describes where the ID or unique key lives inside your documents. The default key gets the value {\ttfamily id} by default when not passed, so you can shorten the example from above to\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ ["{}content"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


The member {\ttfamily index} has a list of fields which you want to be indexed from your documents. When just selecting one field, then you can pass a string. When also using default key {\ttfamily id} then this shortens to just\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{\ document:\ "{}content"{}\ \});}
\DoxyCodeLine{index.add(\{\ id:\ 0,\ content:\ "{}some\ text"{}\ \});}

\end{DoxyCode}


Assuming you have several fields, you can add multiple fields to the index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ docs\ =\ [\{}
\DoxyCodeLine{\ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ title:\ "{}Title\ A"{},}
\DoxyCodeLine{\ \ \ \ content:\ "{}Body\ A"{}}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ id:\ 1,}
\DoxyCodeLine{\ \ \ \ title:\ "{}Title\ B"{},}
\DoxyCodeLine{\ \ \ \ content:\ "{}Body\ B"{}}
\DoxyCodeLine{\}];}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ index:\ ["{}title"{},\ "{}content"{}]}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can pass custom options for each field\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ index:\ [\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ field:\ "{}title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tokenize:\ "{}forward"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ optimize:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ resolution:\ 9}
\DoxyCodeLine{\ \ \ \ \},\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ field:\ \ "{}content"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tokenize:\ "{}strict"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ optimize:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ resolution:\ 5,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ minlength:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ context:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ depth:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ resolution:\ 3}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}]}
\DoxyCodeLine{\});}

\end{DoxyCode}


Field options gets inherited when also global options was passed, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ tokenize:\ "{}strict"{},}
\DoxyCodeLine{\ \ \ \ optimize:\ true,}
\DoxyCodeLine{\ \ \ \ resolution:\ 9,}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:[\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ field:\ "{}title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ tokenize:\ "{}forward"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ minlength:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ context:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ depth:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ resolution:\ 3}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


Note\+: The context options from the field "{}content"{} also gets inherited by the corresponding field options, whereas this field options was inherited by the global option.\hypertarget{README.md_autotoc_md15690}{}\doxysubsubsubsection{\texorpdfstring{Nested Data Fields (Complex Objects)}{Nested Data Fields (Complex Objects)}}\label{README.md_autotoc_md15690}
Assume the document array looks more complex (has nested branches etc.), e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}record"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}id"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ "{}title"{}:\ "{}some\ title"{},}
\DoxyCodeLine{\ \ \ \ "{}content"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}header"{}:\ "{}some\ text"{},}
\DoxyCodeLine{\ \ \ \ \ \ "{}footer"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Then use the colon separated notation {\ttfamily root\+:child\+:child} to define hierarchy within the document descriptor\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}record:id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:content:header"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:content:footer"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}
 \begin{quote}
Just add fields you want to query against. Do not add fields to the index, you just need in the result (but did not query against). For this purpose you can store documents independently of its index (read below). \end{quote}


When you want to query through a field you have to pass the exact key of the field you have defined in the {\ttfamily doc} as a field name (with colon syntax)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{}
\DoxyCodeLine{\ \ \ \ index:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}record:title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}record:content:header"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}record:content:footer"{}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\});}

\end{DoxyCode}


Same as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ [}
\DoxyCodeLine{\ \ \ \ "{}record:title"{},}
\DoxyCodeLine{\ \ \ \ "{}record:content:header"{},}
\DoxyCodeLine{\ \ \ \ "{}record:content:footer"{}}
\DoxyCodeLine{]);}

\end{DoxyCode}


Using field-\/specific options\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search([\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}record:title"{},}
\DoxyCodeLine{\ \ \ \ query:\ "{}some\ query"{},}
\DoxyCodeLine{\ \ \ \ limit:\ 100,}
\DoxyCodeLine{\ \ \ \ suggest:\ true}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}record:title"{},}
\DoxyCodeLine{\ \ \ \ query:\ "{}some\ other\ query"{},}
\DoxyCodeLine{\ \ \ \ limit:\ 100,}
\DoxyCodeLine{\ \ \ \ suggest:\ true}
\DoxyCodeLine{\}]);}

\end{DoxyCode}


You can perform a search through the same field with different queries.

\begin{quote}
When passing field-\/specific options you need to provide the full configuration for each field. They get not inherited like the document descriptor. \end{quote}
\hypertarget{README.md_autotoc_md15691}{}\doxysubsubsubsection{\texorpdfstring{Complex Documents}{Complex Documents}}\label{README.md_autotoc_md15691}
You need to follow 2 rules for your documents\+:


\begin{DoxyEnumerate}
\item The document cannot start with an Array at the root index. This will introduce sequential data and isn\textquotesingle{}t supported yet. See below for a workaround for such data.
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{[\ //\ <-\/-\/\ not\ allowed\ as\ document\ start!}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ "{}id"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ "{}title"{}:\ "{}title"{}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{]}

\end{DoxyCode}



\begin{DoxyEnumerate}
\item The id can\textquotesingle{}t be nested inside an array (also none of the parent fields can\textquotesingle{}t be an array). This will introduce sequential data and isn\textquotesingle{}t supported yet. See below for a workaround for such data.
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}records"{}:\ [\ //\ <-\/-\/\ not\ allowed\ when\ ID\ or\ tag\ lives\ inside!}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}id"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ "{}title"{}:\ "{}title"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


Here an example for a supported complex document\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}meta"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}tag"{}:\ "{}cat"{},}
\DoxyCodeLine{\ \ \ \ "{}id"{}:\ 0}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ "{}contents"{}:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}body"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}title"{}:\ "{}some\ title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}footer"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ "{}keywords"{}:\ ["{}some"{},\ "{}key"{},\ "{}words"{}]}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}body"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}title"{}:\ "{}some\ title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}footer"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ "{}keywords"{}:\ ["{}some"{},\ "{}key"{},\ "{}words"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


The corresponding document descriptor (when all fields should be indexed) looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}meta:id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tag:\ "{}meta:tag"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}contents[]:body:title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}contents[]:body:footer"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}contents[]:keywords"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


Again, when searching you have to use the same colon-\/separated-\/string from your field definition.


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ }
\DoxyCodeLine{\ \ \ \ index:\ "{}contents[]:body:title"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15692}{}\doxysubsubsubsection{\texorpdfstring{Not Supported Documents (Sequential Data)}{Not Supported Documents (Sequential Data)}}\label{README.md_autotoc_md15692}
This example breaks both rules from above\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\ //\ <-\/-\/\ not\ allowed\ as\ document\ start!}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ "{}tag"{}:\ "{}cat"{},}
\DoxyCodeLine{\ \ \ \ "{}records"{}:\ [\ //\ <-\/-\/\ not\ allowed\ when\ ID\ or\ tag\ lives\ inside!}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}id"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}body"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}title"{}:\ "{}some\ title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}footer"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}keywords"{}:\ ["{}some"{},\ "{}key"{},\ "{}words"{}]}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}id"{}:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}body"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}title"{}:\ "{}some\ title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}footer"{}:\ "{}some\ text"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}keywords"{}:\ ["{}some"{},\ "{}key"{},\ "{}words"{}]}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{]}

\end{DoxyCode}


You need to apply some kind of structure normalization.

A workaround to such a data structure looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}record:id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tag:\ "{}tag"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:body:title"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:body:footer"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}record:body:keywords"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{function\ add(sequential\_data)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ for(let\ x\ =\ 0,\ data;\ x\ <\ sequential\_data.length;\ x++)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ data\ =\ sequential\_data[x];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ for(let\ y\ =\ 0,\ record;\ y\ <\ data.records.length;\ y++)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ record\ =\ data.records[y];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ index.add(\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ id:\ record.id,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tag:\ data.tag,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ record:\ record}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}\ \ }
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ now\ just\ use\ add()\ helper\ method\ as\ usual:}
\DoxyCodeLine{}
\DoxyCodeLine{add([\{}
\DoxyCodeLine{\ \ \ \ //\ sequential\ structured\ data}
\DoxyCodeLine{\ \ \ \ //\ take\ the\ data\ example\ above}
\DoxyCodeLine{\}]);}

\end{DoxyCode}


You can skip the first loop when your document data has just one index as the outer array.\hypertarget{README.md_autotoc_md15693}{}\doxysubsubsubsection{\texorpdfstring{Add/\+Update/\+Remove Documents to/from the Index}{Add/\+Update/\+Remove Documents to/from the Index}}\label{README.md_autotoc_md15693}
Just pass the document array (or a single object) to the index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(docs);}

\end{DoxyCode}


Update index with a single object or an array of objects\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.update(\{}
\DoxyCodeLine{\ \ \ \ data:\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ title:\ "{}Foo"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ body:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ content:\ "{}Bar"{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


Remove a single object or an array of objects from the index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.remove(docs);}

\end{DoxyCode}


When the id is known, you can also simply remove by (faster)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.remove(id);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15694}{}\doxysubsubsubsection{\texorpdfstring{Join / Append Arrays}{Join / Append Arrays}}\label{README.md_autotoc_md15694}
On the complex example above, the field {\ttfamily keywords} is an array but here the markup did not have brackets like {\ttfamily keywords\mbox{[}\mbox{]}}. That will also detect the array but instead of appending each entry to a new context, the array will be joined into on large string and added to the index.

The difference of both kinds of adding array contents is the relevance when searching. When adding each item of an array via {\ttfamily append()} to its own context by using the syntax {\ttfamily field\mbox{[}\mbox{]}}, then the relevance of the last entry concurrent with the first entry. When you left the brackets in the notation, it will join the array to one whitespace-\/separated string. Here the first entry has the highest relevance, whereas the last entry has the lowest relevance.

So assuming the keyword from the example above are pre-\/sorted by relevance to its popularity, then you want to keep this order (information of relevance). For this purpose do not add brackets to the notation. Otherwise, it would take the entries in a new scoring context (the old order is getting lost).

Also you can left bracket notation for better performance and smaller memory footprint. Use it when you did not need the granularity of relevance by the entries.\hypertarget{README.md_autotoc_md15695}{}\doxysubsubsubsection{\texorpdfstring{Field-\/\+Search}{Field-\/\+Search}}\label{README.md_autotoc_md15695}
Search through all fields\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query);}

\end{DoxyCode}


Search through a specific field\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ index:\ "{}title"{}\ \});}

\end{DoxyCode}


Search through a given set of fields\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ index:\ ["{}title"{},\ "{}content"{}]\ \});}

\end{DoxyCode}


Same as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ ["{}title"{},\ "{}content"{}]);}

\end{DoxyCode}


Pass custom modifiers and queries to each field\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search([\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ query:\ "{}some\ query"{},}
\DoxyCodeLine{\ \ \ \ limit:\ 100,}
\DoxyCodeLine{\ \ \ \ suggest:\ true}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ query:\ "{}some\ other\ query"{},}
\DoxyCodeLine{\ \ \ \ limit:\ 100,}
\DoxyCodeLine{\ \ \ \ suggest:\ true}
\DoxyCodeLine{\}]);}

\end{DoxyCode}


You can perform a search through the same field with different queries.

\href{\#options-field-search}{\texttt{ See all available field-\/search options.}}\hypertarget{README.md_autotoc_md15696}{}\doxysubsubsubsection{\texorpdfstring{The Result Set}{The Result Set}}\label{README.md_autotoc_md15696}
Schema of the result-\/set\+:

\begin{quote}
{\ttfamily fields\mbox{[}\mbox{]} =\texorpdfstring{$>$}{>} \{ field, result\mbox{[}\mbox{]} =\texorpdfstring{$>$}{>} \{ document \}\}} \end{quote}


The first index is an array of fields the query was applied to. Each of this field has a record (object) with 2 properties "{}field"{} and "{}result"{}. The "{}result"{} is also an array and includes the result for this specific field. The result could be an array of IDs or as enriched with stored document data.

A non-\/enriched result set now looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}title"{},}
\DoxyCodeLine{\ \ \ \ result:\ [0,\ 1,\ 2]}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ result:\ [3,\ 4,\ 5]}
\DoxyCodeLine{\}]}

\end{DoxyCode}


An enriched result set now looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}title"{},}
\DoxyCodeLine{\ \ \ \ result:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 0,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 1,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 2,\ doc:\ \{\ /*\ document\ */\ \}\}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ result:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 3,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 4,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ id:\ 5,\ doc:\ \{\ /*\ document\ */\ \}\}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\}]}

\end{DoxyCode}


When using {\ttfamily pluck} instead of "{}field"{} you can explicitly select just one field and get back a flat representation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ pluck:\ "{}title"{},\ enrich:\ true\ \});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \ \ \{\ id:\ 0,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \{\ id:\ 1,\ doc:\ \{\ /*\ document\ */\ \}\},}
\DoxyCodeLine{\ \ \ \ \{\ id:\ 2,\ doc:\ \{\ /*\ document\ */\ \}\}}
\DoxyCodeLine{]}

\end{DoxyCode}


This result set is a replacement of "{}boolean search"{}. Instead of applying your bool logic to a nested object, you can apply your logic by yourself on top of the result-\/set dynamically. This opens hugely capabilities on how you process the results. Therefore, the results from the fields aren\textquotesingle{}t squashed into one result anymore. That keeps some important information, like the name of the field as well as the relevance of each field results which didn\textquotesingle{}t get mixed anymore.

\begin{quote}
A field search will apply a query with the boolean "{}or"{} logic by default. Each field has its own result to the given query. \end{quote}


There is one situation where the {\ttfamily bool} property is being still supported. When you like to switch the default "{}or"{} logic from the field search into "{}and"{}, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ }
\DoxyCodeLine{\ \ \ \ index:\ ["{}title"{},\ "{}content"{}],}
\DoxyCodeLine{\ \ \ \ bool:\ "{}and"{}\ }
\DoxyCodeLine{\});}

\end{DoxyCode}


You will just get results which contains the query in both fields. That\textquotesingle{}s it.\hypertarget{README.md_autotoc_md15697}{}\doxysubsubsubsection{\texorpdfstring{Tags}{Tags}}\label{README.md_autotoc_md15697}
Like the {\ttfamily key} for the ID just define the path to the tag\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ "{}id"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tag:\ "{}tag"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ "{}content"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(\{}
\DoxyCodeLine{\ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ tag:\ "{}cat"{},}
\DoxyCodeLine{\ \ \ \ content:\ "{}Some\ content\ ..."{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


Your data also can have multiple tags as an array\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(\{}
\DoxyCodeLine{\ \ \ \ id:\ 1,}
\DoxyCodeLine{\ \ \ \ tag:\ ["{}animal"{},\ "{}dog"{}],}
\DoxyCodeLine{\ \ \ \ content:\ "{}Some\ content\ ..."{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can perform a tag-\/specific search by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ }
\DoxyCodeLine{\ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ tag:\ "{}animal"{}\ }
\DoxyCodeLine{\});}

\end{DoxyCode}


This just gives you result which was tagged with the given tag.

Use multiple tags when searching\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ }
\DoxyCodeLine{\ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ tag:\ ["{}cat"{},\ "{}dog"{}]}
\DoxyCodeLine{\});}

\end{DoxyCode}


This gives you result which are tagged with one of the given tag.

\begin{quote}
Multiple tags will apply as the boolean "{}or"{} by default. It just needs one of the tags to be existing. \end{quote}


This is another situation where the {\ttfamily bool} property is still supported. When you like to switch the default "{}or"{} logic from the tag search into "{}and"{}, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ }
\DoxyCodeLine{\ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ tag:\ ["{}dog"{},\ "{}animal"{}],}
\DoxyCodeLine{\ \ \ \ bool:\ "{}and"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


You will just get results which contains both tags (in this example there is just one records which has the tag "{}dog"{} and "{}animal"{}).\hypertarget{README.md_autotoc_md15698}{}\doxysubsubsubsection{\texorpdfstring{Tag Search}{Tag Search}}\label{README.md_autotoc_md15698}
You can also fetch results from one or more tags when no query was passed\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(\{\ tag:\ ["{}cat"{},\ "{}dog"{}]\ \});}

\end{DoxyCode}


In this case the result-\/set looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{}
\DoxyCodeLine{\ \ \ \ tag:\ "{}cat"{},}
\DoxyCodeLine{\ \ \ \ result:\ [\ /*\ all\ cats\ */\ ]}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ tag:\ "{}dog"{},}
\DoxyCodeLine{\ \ \ \ result:\ [\ /*\ all\ dogs\ */\ ]}
\DoxyCodeLine{\}]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15699}{}\doxysubsubsubsection{\texorpdfstring{Limit \& Offset}{Limit \& Offset}}\label{README.md_autotoc_md15699}
\begin{quote}
By default, every query is limited to 100 entries. Unbounded queries leads into issues. You need to set the limit as an option to adjust the size. \end{quote}


You can set the limit and the offset for each query\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ limit:\ 20,\ offset:\ 100\ \});}

\end{DoxyCode}


\begin{quote}
You cannot pre-\/count the size of the result-\/set. That\textquotesingle{}s a limit by the design of Flex\+Search. When you really need a count of all results you are able to page through, then just assign a high enough limit and get back all results and apply your paging offset manually (this works also on server-\/side). Flex\+Search is fast enough that this isn\textquotesingle{}t an issue. \end{quote}
\hypertarget{README.md_autotoc_md15700}{}\doxysubsubsection{\texorpdfstring{Document Store}{Document Store}}\label{README.md_autotoc_md15700}
Only a document index can have a store. You can use a document index instead of a flat index to get this functionality also when only storing ID-\/content-\/pairs.

You can define independently which fields should be indexed and which fields should be stored. This way you can index fields which should not be included in the search result.

\begin{quote}
Do not use a store when\+: 1. an array of IDs as the result is good enough, or 2. you already have the contents/documents stored elsewhere (outside the index). \end{quote}


\begin{quote}
When the {\ttfamily store} attribute was set, you have to include all fields which should be stored explicitly (acts like a whitelist). \end{quote}


\begin{quote}
When the {\ttfamily store} attribute was not set, the original document is stored as a fallback. \end{quote}


This will add the whole original content to the store\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ store:\ true}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(\{\ id:\ 0,\ content:\ "{}some\ text"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15701}{}\doxysubsubsubsection{\texorpdfstring{Access documents from internal store}{Access documents from internal store}}\label{README.md_autotoc_md15701}
You can get indexed documents from the store\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ data\ =\ index.get(1);}

\end{DoxyCode}


You can update/change store contents directly without changing the index by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.set(1,\ data);}

\end{DoxyCode}


To update the store and also update the index then just use {\ttfamily index.\+update}, {\ttfamily index.\+add} or {\ttfamily index.\+append}.

When you perform a query, weather it is a document index or a flat index, then you will always get back an array of IDs.

Optionally you can enrich the query results automatically with stored contents by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search(query,\ \{\ enrich:\ true\ \});}

\end{DoxyCode}


Your results look now like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{}
\DoxyCodeLine{\ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ doc:\ \{\ /*\ content\ from\ store\ */\ \}}
\DoxyCodeLine{\},\{}
\DoxyCodeLine{\ \ \ \ id:\ 1,}
\DoxyCodeLine{\ \ \ \ doc:\ \{\ /*\ content\ from\ store\ */\ \}}
\DoxyCodeLine{\}]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15702}{}\doxysubsubsubsection{\texorpdfstring{Configure Storage (Recommended)}{Configure Storage (Recommended)}}\label{README.md_autotoc_md15702}
This will add just specific fields from a document to the store (the ID isn\textquotesingle{}t necessary to keep in store)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ store:\ ["{}author"{},\ "{}email"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(id,\ content);}

\end{DoxyCode}


You can configure independently what should being indexed and what should being stored. It is highly recommended to make use of this whenever you can.

Here a useful example of configuring doc and store\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ document:\ \{\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ index:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ store:\ ["{}author"{},\ "{}email"{}]\ }
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(\{}
\DoxyCodeLine{\ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ author:\ "{}Jon\ Doe"{},}
\DoxyCodeLine{\ \ \ \ email:\ "{}john@mail.com"{},}
\DoxyCodeLine{\ \ \ \ content:\ "{}Some\ content\ for\ the\ index\ ..."{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can query through the contents and will get back the stored values instead\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.search("{}some\ content"{},\ \{\ enrich:\ true\ \});}

\end{DoxyCode}


Your results are now looking like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{}
\DoxyCodeLine{\ \ \ \ field:\ "{}content"{},}
\DoxyCodeLine{\ \ \ \ result:\ [\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ id:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ doc:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ author:\ "{}Jon\ Doe"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ email:\ "{}john@mail.com"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}]}
\DoxyCodeLine{\}]}

\end{DoxyCode}


Both field "{}author"{} and "{}email"{} are not indexed.

\label{README.md_chaining}%
\Hypertarget{README.md_chaining}%
 \hypertarget{README.md_autotoc_md15703}{}\doxysubsubsubsection{\texorpdfstring{Chaining}{Chaining}}\label{README.md_autotoc_md15703}
Simply chain methods like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ FlexSearch.create()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .addMatcher(\{'â':\ 'a'\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .add(0,\ 'foo')}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .add(1,\ 'bar');}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{index.remove(0).update(1,\ 'foo').add(2,\ 'foobar');}

\end{DoxyCode}


\label{README.md_contextual_enable}%
\Hypertarget{README.md_contextual_enable}%
 \hypertarget{README.md_autotoc_md15704}{}\doxysubsubsection{\texorpdfstring{Enable Contextual Scoring}{Enable Contextual Scoring}}\label{README.md_autotoc_md15704}
Create an index and use the default context\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch(\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tokenize:\ "{}strict"{},}
\DoxyCodeLine{\ \ \ \ context:\ true}
\DoxyCodeLine{\});}

\end{DoxyCode}


Create an index and apply custom options for the context\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch(\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tokenize:\ "{}strict"{},}
\DoxyCodeLine{\ \ \ \ context:\ \{\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ resolution:\ 5,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ depth:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bidirectional:\ true}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
Only the tokenizer "{}strict"{} is actually supported by the contextual index. \end{quote}


\begin{quote}
The contextual index requires \href{\#memory}{\texttt{ additional amount of memory}} depending on depth. \end{quote}


\label{README.md_cache}%
\Hypertarget{README.md_cache}%
 \hypertarget{README.md_autotoc_md15705}{}\doxysubsubsubsection{\texorpdfstring{Auto-\/\+Balanced Cache (By Popularity)}{Auto-\/\+Balanced Cache (By Popularity)}}\label{README.md_autotoc_md15705}
You need to initialize the cache and its limit during the creation of the index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Index(\{\ cache:\ 100\ \});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ results\ =\ index.searchCache(query);}

\end{DoxyCode}


A common scenario for using a cache is an autocomplete or instant search when typing.

\begin{quote}
When passing a number as a limit the cache automatically balance stored entries related to their popularity. \end{quote}


\begin{quote}
When just using "{}true"{} the cache is unbounded and perform actually 2-\/3 times faster (because the balancer do not have to run). \end{quote}


\label{README.md_webworker}%
\Hypertarget{README.md_webworker}%
 \hypertarget{README.md_autotoc_md15706}{}\doxysubsubsection{\texorpdfstring{Worker Parallelism (Browser + Node.\+js)}{Worker Parallelism (Browser + Node.\+js)}}\label{README.md_autotoc_md15706}
The new worker model from v0.\+7.\+0 is divided into "{}fields"{} from the document (1 worker = 1 field index). This way the worker becomes able to solve tasks (subtasks) completely. The downside of this paradigm is they might not have been perfect balanced in storing contents (fields may have different length of contents). On the other hand there is no indication that balancing the storage gives any advantage (they all require the same amount in total).

When using a document index, then just apply the option "{}worker"{}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ index:\ ["{}tag"{},\ "{}name"{},\ "{}title"{},\ "{}text"{}],}
\DoxyCodeLine{\ \ \ \ worker:\ true}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{index.add(\{\ }
\DoxyCodeLine{\ \ \ \ id:\ 1,\ tag:\ "{}cat"{},\ name:\ "{}Tom"{},\ title:\ "{}some"{},\ text:\ "{}some"{}\ }
\DoxyCodeLine{\}).add(\{}
\DoxyCodeLine{\ \ \ \ id:\ 2,\ tag:\ "{}dog"{},\ name:\ "{}Ben"{},\ title:\ "{}title"{},\ text:\ "{}content"{}\ }
\DoxyCodeLine{\}).add(\{\ }
\DoxyCodeLine{\ \ \ \ id:\ 3,\ tag:\ "{}cat"{},\ name:\ "{}Max"{},\ title:\ "{}to"{},\ text:\ "{}to"{}\ }
\DoxyCodeLine{\}).add(\{\ }
\DoxyCodeLine{\ \ \ \ id:\ 4,\ tag:\ "{}dog"{},\ name:\ "{}Tim"{},\ title:\ "{}index"{},\ text:\ "{}index"{}\ }
\DoxyCodeLine{\});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{Worker\ 1:\ \{\ 1:\ "{}cat"{},\ 2:\ "{}dog"{},\ 3:\ "{}cat"{},\ 4:\ "{}dog"{}\ \}}
\DoxyCodeLine{Worker\ 2:\ \{\ 1:\ "{}Tom"{},\ 2:\ "{}Ben"{},\ 3:\ "{}Max"{},\ 4:\ "{}Tim"{}\ \}}
\DoxyCodeLine{Worker\ 3:\ \{\ 1:\ "{}some"{},\ 2:\ "{}title"{},\ 3:\ "{}to"{},\ 4:\ "{}index"{}\ \}}
\DoxyCodeLine{Worker\ 4:\ \{\ 1:\ "{}some"{},\ 2:\ "{}content"{},\ 3:\ "{}to"{},\ 4:\ "{}index"{}\ \}}

\end{DoxyCode}


When you perform a field search through all fields then this task is being balanced perfectly through all workers, which can solve their subtasks independently.\hypertarget{README.md_autotoc_md15707}{}\doxysubsubsubsection{\texorpdfstring{Worker Index}{Worker Index}}\label{README.md_autotoc_md15707}
Above we have seen that documents will create worker automatically for each field. You can also create a Worker\+Index directly (same like using {\ttfamily Index} instead of {\ttfamily Document}).

Use as ES6 module\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ WorkerIndex\ from\ "{}./worker/index.js"{};}
\DoxyCodeLine{const\ index\ =\ new\ WorkerIndex(options);}
\DoxyCodeLine{index.add(1,\ "{}some"{})}
\DoxyCodeLine{\ \ \ \ \ .add(2,\ "{}content"{})}
\DoxyCodeLine{\ \ \ \ \ .add(3,\ "{}to"{})}
\DoxyCodeLine{\ \ \ \ \ .add(4,\ "{}index"{});}

\end{DoxyCode}


Or when bundled version was used instead\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ FlexSearch.Worker(options);}
\DoxyCodeLine{index.add(1,\ "{}some"{})}
\DoxyCodeLine{\ \ \ \ \ .add(2,\ "{}content"{})}
\DoxyCodeLine{\ \ \ \ \ .add(3,\ "{}to"{})}
\DoxyCodeLine{\ \ \ \ \ .add(4,\ "{}index"{});}

\end{DoxyCode}


Such a Worker\+Index works pretty much the same as a created instance of {\ttfamily Index}.

\begin{quote}
A Worker\+Index only support the {\ttfamily async} variant of all methods. That means when you call {\ttfamily index.\+search()} on a Worker\+Index this will perform also in async the same way as {\ttfamily index.\+search\+Async()} will do. \end{quote}
\hypertarget{README.md_autotoc_md15708}{}\doxysubsubsubsection{\texorpdfstring{Worker Threads (Node.\+js)}{Worker Threads (Node.\+js)}}\label{README.md_autotoc_md15708}
The worker model for Node.\+js is based on "{}worker threads"{} and works exactly the same way\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{\ Document\ \}\ =\ require("{}flexsearch"{});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ index:\ ["{}tag"{},\ "{}name"{},\ "{}title"{},\ "{}text"{}],}
\DoxyCodeLine{\ \ \ \ worker:\ true}
\DoxyCodeLine{\});}

\end{DoxyCode}


Or create a single worker instance for a non-\/document index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{\ Worker\ \}\ =\ require("{}flexsearch"{});}
\DoxyCodeLine{const\ index\ =\ new\ Worker(\{\ options\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15709}{}\doxysubsubsubsection{\texorpdfstring{The Worker Async Model (Best Practices)}{The Worker Async Model (Best Practices)}}\label{README.md_autotoc_md15709}
A worker will always perform as async. On a query method call you always should handle the returned promise (e.\+g. use {\ttfamily await}) or pass a callback function as the last parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ new\ Document(\{}
\DoxyCodeLine{\ \ \ \ index:\ ["{}tag"{},\ "{}name"{},\ "{}title"{},\ "{}text"{}],}
\DoxyCodeLine{\ \ \ \ worker:\ true}
\DoxyCodeLine{\});}

\end{DoxyCode}


All requests and sub-\/tasks will run in parallel (prioritize "{}all tasks completed"{})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.searchAsync(query,\ callback);}
\DoxyCodeLine{index.searchAsync(query,\ callback);}
\DoxyCodeLine{index.searchAsync(query,\ callback);}

\end{DoxyCode}


Also (prioritize "{}all tasks completed"{})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.searchAsync(query).then(callback);}
\DoxyCodeLine{index.searchAsync(query).then(callback);}
\DoxyCodeLine{index.searchAsync(query).then(callback);}

\end{DoxyCode}


Or when you have just one callback when all requests are done, simply use {\ttfamily Promise.\+all()} which also prioritize "{}all tasks completed"{}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Promise.all([}
\DoxyCodeLine{\ \ \ \ index.searchAsync(query),}
\DoxyCodeLine{\ \ \ \ index.searchAsync(query),}
\DoxyCodeLine{\ \ \ \ index.searchAsync(query)}
\DoxyCodeLine{]).then(callback);}

\end{DoxyCode}


Inside the callback of {\ttfamily Promise.\+all()} you will also get an array of results as the first parameter respectively for each query you put into.

When using {\ttfamily await} you can prioritize the order (prioritize "{}first task completed"{}) and solve requests one by one and just process the sub-\/tasks in parallel\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{await\ index.searchAsync(query);}
\DoxyCodeLine{await\ index.searchAsync(query);}
\DoxyCodeLine{await\ index.searchAsync(query);}

\end{DoxyCode}


Same for {\ttfamily index.\+add()}, {\ttfamily index.\+append()}, {\ttfamily index.\+remove()} or {\ttfamily index.\+update()}. Here there is a special case which isn\textquotesingle{}t disabled by the library, but you need to keep in mind when using Workers.

When you call the "{}synced"{} version on a worker index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.add(doc);}
\DoxyCodeLine{index.add(doc);}
\DoxyCodeLine{index.add(doc);}
\DoxyCodeLine{//\ contents\ aren't\ indexed\ yet,}
\DoxyCodeLine{//\ they\ just\ queued\ on\ the\ message\ channel\ }

\end{DoxyCode}


Of course, you can do that but keep in mind that the main thread does not have an additional queue for distributed worker tasks. Running these in a long loop fires content massively to the message channel via {\ttfamily worker.\+post\+Message()} internally. Luckily the browser and Node.\+js will handle such incoming tasks for you automatically (as long enough free RAM is available). When using the "{}synced"{} version on a worker index, the content isn\textquotesingle{}t indexed one line below, because all calls are treated as async by default.

\begin{quote}
When adding/updating/removing large bulks of content to the index (or high frequency), it is recommended to use the async version along with {\ttfamily async/await} to keep a low memory footprint during long processes. \end{quote}


\label{README.md_export}%
\Hypertarget{README.md_export}%
 \hypertarget{README.md_autotoc_md15710}{}\doxysubsubsection{\texorpdfstring{Export / Import}{Export / Import}}\label{README.md_autotoc_md15710}
\hypertarget{README.md_autotoc_md15711}{}\doxysubsubsubsection{\texorpdfstring{Export}{Export}}\label{README.md_autotoc_md15711}
The export has slightly changed. The export now consist of several smaller parts, instead of just one large bulk. You need to pass a callback function which has 2 arguments "{}key"{} and "{}data"{}. This callback function is called by each part, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.export(function(key,\ data)\{\ }
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ you\ need\ to\ store\ both\ the\ key\ and\ the\ data!}
\DoxyCodeLine{\ \ \ \ //\ e.g.\ use\ the\ key\ for\ the\ filename\ and\ save\ your\ data}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ localStorage.setItem(key,\ data);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Exporting data to the local\+Storage isn\textquotesingle{}t really a good practice, but if size is not a concern than use it if you like. The export primarily exists for the usage in Node.\+js or to store indexes you want to delegate from a server to the client.

\begin{quote}
The size of the export corresponds to the memory consumption of the library. To reduce export size you have to use a configuration which has less memory footprint (use the table at the bottom to get information about configs and its memory allocation). \end{quote}


When your save routine runs asynchronously you have to return a promise\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.export(function(key,\ data)\{\ }
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ return\ new\ Promise(function(resolve)\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ do\ the\ saving\ as\ async}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ resolve();}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
You cannot export the additional table for the "{}fastupdate"{} feature. These table exists of references and when stored they fully get serialized and becomes too large. The lib will handle these automatically for you. When importing data, the index automatically disables "{}fastupdate"{}. \end{quote}
\hypertarget{README.md_autotoc_md15712}{}\doxysubsubsubsection{\texorpdfstring{Import}{Import}}\label{README.md_autotoc_md15712}
Before you can import data, you need to create your index first. For document indexes provide the same document descriptor you used when export the data. This configuration isn\textquotesingle{}t stored in the export.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ new\ Index(\{\ ...\ \});}

\end{DoxyCode}


To import the data just pass a key and data\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{index.import(key,\ localStorage.getItem(key));}

\end{DoxyCode}


You need to import every key! Otherwise, your index does not work. You need to store the keys from the export and use this keys for the import (the order of the keys can differ).

This is just for demonstration and is not recommended, because you might have other keys in your local\+Storage which aren\textquotesingle{}t supported as an import\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ keys\ =\ Object.keys(localStorage);}
\DoxyCodeLine{}
\DoxyCodeLine{for(let\ i\ =\ 0,\ key;\ i\ <\ keys.length;\ i++)\{}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ key\ =\ keys[i];}
\DoxyCodeLine{\ \ \ \ index.import(key,\ localStorage.getItem(key));}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15713}{}\doxysubsubsection{\texorpdfstring{Languages}{Languages}}\label{README.md_autotoc_md15713}
Language-\/specific definitions are being divided into two groups\+:


\begin{DoxyEnumerate}
\item Charset
\begin{DoxyEnumerate}
\item \+\_\+\+\_\+\+\_\+encode\+\_\+\+\_\+\+\_\+, type\+: {\ttfamily function(string)\+:string\mbox{[}\mbox{]}}
\item \+\_\+\+\_\+\+\_\+rtl\+\_\+\+\_\+\+\_\+, type\+: {\ttfamily boolean}
\end{DoxyEnumerate}
\item Language
\begin{DoxyEnumerate}
\item \+\_\+\+\_\+\+\_\+matcher\+\_\+\+\_\+\+\_\+, type\+: {\ttfamily \{string\+: string\}}
\item \+\_\+\+\_\+\+\_\+stemmer\+\_\+\+\_\+\+\_\+, type\+: {\ttfamily \{string\+: string\}}
\item \+\_\+\+\_\+\+\_\+filter\+\_\+\+\_\+\+\_\+, type\+: {\ttfamily string\mbox{[}\mbox{]}}
\end{DoxyEnumerate}
\end{DoxyEnumerate}

The charset contains the encoding logic, the language contains stemmer, stopword filter and matchers. Multiple language definitions can use the same charset encoder. Also this separation let you manage different language definitions for special use cases (e.\+g. names, cities, dialects/slang, etc.).

To fully describe a custom language {\bfseries{on the fly}} you need to pass\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ //\ mandatory:}
\DoxyCodeLine{\ \ \ \ encode:\ (content)\ =>\ [words],}
\DoxyCodeLine{\ \ \ \ //\ optionally:}
\DoxyCodeLine{\ \ \ \ rtl:\ false,}
\DoxyCodeLine{\ \ \ \ stemmer:\ \{\},}
\DoxyCodeLine{\ \ \ \ matcher:\ \{\},}
\DoxyCodeLine{\ \ \ \ filter:\ []}
\DoxyCodeLine{\});}

\end{DoxyCode}


When passing no parameter it uses the {\ttfamily latin\+:default} schema by default.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{0}{|X[-1]}|}
\hline
\\
\end{longtabu}


Field 

Category 

Description  

{\bfseries{encode}} 

charset 

The encoder function. Has to return an array of separated words (or an empty string).  

{\bfseries{rtl}} 

charset 

A boolean property which indicates right-\/to-\/left encoding.  

{\bfseries{filter}} 

language 

Filter are also known as "{}stopwords"{}, they completely filter out words from being indexed.  

{\bfseries{stemmer}} 

language 

Stemmer removes word endings and is a kind of "{}partial normalization"{}. A word ending just matched when the word length is bigger than the matched partial.  

{\bfseries{matcher}} 

language 

Matcher replaces all occurrences of a given string regardless of its position and is also a kind of "{}partial normalization"{}.  \hypertarget{README.md_autotoc_md15714}{}\doxysubsubsubsection{\texorpdfstring{1. Language Packs\+: ES6 Modules}{1. Language Packs\+: ES6 Modules}}\label{README.md_autotoc_md15714}
The most simple way to assign charset/language specific encoding via modules is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ charset\ from\ "{}./dist/module/lang/latin/advanced.js"{};}
\DoxyCodeLine{import\ lang\ from\ "{}./dist/module/lang/en.js"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ charset:\ charset,}
\DoxyCodeLine{\ \ \ \ lang:\ lang}
\DoxyCodeLine{\});}

\end{DoxyCode}


Just import the {\bfseries{default export}} by each module and assign them accordingly.

The full qualified example from above is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ encode,\ rtl\ \}\ from\ "{}./dist/module/lang/latin/advanced.js"{};}
\DoxyCodeLine{import\ \{\ stemmer,\ filter,\ matcher\ \}\ from\ "{}./dist/module/lang/en.js"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ encode:\ encode,}
\DoxyCodeLine{\ \ \ \ rtl:\ rtl,}
\DoxyCodeLine{\ \ \ \ stemmer:\ stemmer,}
\DoxyCodeLine{\ \ \ \ matcher:\ matcher,}
\DoxyCodeLine{\ \ \ \ filter:\ filter}
\DoxyCodeLine{\});}

\end{DoxyCode}


The example above is the standard interface which is at least exported from each charset/language.

You can also define the encoder directly and left all other options\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ simple\ from\ "{}./dist/module/lang/latin/simple.js"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ encode:\ simple}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15715}{}\doxysubsubsubsubsection{\texorpdfstring{Available Latin Encoders}{Available Latin Encoders}}\label{README.md_autotoc_md15715}

\begin{DoxyEnumerate}
\item default
\item simple
\item balance
\item advanced
\item extra
\end{DoxyEnumerate}

You can assign a charset by passing the charset during initialization, e.\+g. {\ttfamily charset\+: "{}latin"{}} for the default charset encoder or {\ttfamily charset\+: "{}latin\+:soundex"{}} for a encoder variant.\hypertarget{README.md_autotoc_md15716}{}\doxysubsubsubsubsection{\texorpdfstring{Dialect / Slang}{Dialect / Slang}}\label{README.md_autotoc_md15716}
Language definitions (especially matchers) also could be used to normalize dialect and slang of a specific language.\hypertarget{README.md_autotoc_md15717}{}\doxysubsubsubsection{\texorpdfstring{2. Language Packs\+: ES5 (Language Packs)}{2. Language Packs\+: ES5 (Language Packs)}}\label{README.md_autotoc_md15717}
You need to make the charset and/or language definitions available by\+:


\begin{DoxyEnumerate}
\item All charset definitions are included in the {\ttfamily flexsearch.\+bundle.\+js} build by default, but no language-\/specific definitions are included
\item You can load packages located in {\ttfamily /dist/lang/} (files refers to languages, folders are charsets)
\item You can make a custom build
\end{DoxyEnumerate}

When loading language packs, make sure that the library was loaded before\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}dist/flexsearch.light.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/latin/default.min.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/en.min.js"{}></script>}

\end{DoxyCode}


When using the full "{}bundle"{} version the built-\/in latin encoders are already included and you just have to load the language file\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}dist/flexsearch.bundle.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/en.min.js"{}></script>}

\end{DoxyCode}


Because you loading packs as external packages (non-\/\+ES6-\/modules) you have to initialize them by shortcuts\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ charset:\ "{}latin:soundex"{},}
\DoxyCodeLine{\ \ \ \ lang:\ "{}en"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
Use the {\ttfamily charset\+:variant} notation to assign charset and its variants. When just passing the charset without a variant will automatically resolve as {\ttfamily charset\+:default}. \end{quote}


You can also override existing definitions, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ charset:\ "{}latin"{},}
\DoxyCodeLine{\ \ \ \ lang:\ "{}en"{},}
\DoxyCodeLine{\ \ \ \ matcher:\ \{\}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
Passed definitions will {\bfseries{not}} extend default definitions, they will replace them. \end{quote}


When you like to extend a definition just create a new language file and put in all the logic.\hypertarget{README.md_autotoc_md15718}{}\doxysubsubsubsubsection{\texorpdfstring{Encoder Variants}{Encoder Variants}}\label{README.md_autotoc_md15718}
It is pretty straight forward when using an encoder variant\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}dist/flexsearch.light.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/latin/advanced.min.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/latin/extra.min.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/en.min.js"{}></script>}

\end{DoxyCode}


When using the full "{}bundle"{} version the built-\/in latin encoders are already included and you just have to load the language file\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}dist/flexsearch.bundle.js"{}></script>}
\DoxyCodeLine{<script\ src="{}dist/lang/en.min.js"{}></script>}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ index\_advanced\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ charset:\ "{}latin:advanced"{}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ index\_extra\ =\ FlexSearch(\{}
\DoxyCodeLine{\ \ \ \ charset:\ "{}latin:extra"{}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15719}{}\doxysubsubsubsection{\texorpdfstring{Partial Tokenizer}{Partial Tokenizer}}\label{README.md_autotoc_md15719}
In Flex\+Search you can\textquotesingle{}t provide your own partial tokenizer, because it is a direct dependency to the core unit. The built-\/in tokenizer of Flex\+Search splits each word into fragments by different patterns\+:


\begin{DoxyEnumerate}
\item strict (supports contextual index)
\item forward
\item reverse (including forward)
\item full
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md15720}{}\doxysubsubsubsection{\texorpdfstring{Language Processing Pipeline}{Language Processing Pipeline}}\label{README.md_autotoc_md15720}
This is the default pipeline provided by Flex\+Search\+:

 \hypertarget{README.md_autotoc_md15721}{}\doxysubsubsubsubsection{\texorpdfstring{Custom Pipeline}{Custom Pipeline}}\label{README.md_autotoc_md15721}
At first take a look into the default pipeline in {\ttfamily src/common.\+js}. It is very simple and straight forward. The pipeline will process as some sort of inversion of control, the final encoder implementation has to handle charset and also language specific transformations. This workaround has left over from many tests.

Inject the default pipeline by e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{this.pipeline(}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ /*\ string:\ */\ str.toLowerCase(),}
\DoxyCodeLine{\ \ \ \ /*\ normalize:\ */\ false,}
\DoxyCodeLine{\ \ \ \ /*\ split:\ */\ split,}
\DoxyCodeLine{\ \ \ \ /*\ collapse:\ */\ false}
\DoxyCodeLine{);}

\end{DoxyCode}


Use the pipeline schema from above to understand the iteration and the difference of pre-\/encoding and post-\/encoding. Stemmer and matchers needs to be applied after charset normalization but before language transformations, filters also.

Here is a good example of extending pipelines\+: {\ttfamily src/lang/latin/extra.\+js} → {\ttfamily src/lang/latin/advanced.\+js} → {\ttfamily src/lang/latin/simple.\+js}.\hypertarget{README.md_autotoc_md15722}{}\doxysubsubsubsection{\texorpdfstring{How to contribute?}{How to contribute?}}\label{README.md_autotoc_md15722}
Search for your language in {\ttfamily src/lang/}, if it exists you can extend or provide variants (like dialect/slang). If the language doesn\textquotesingle{}t exist create a new file and check if any of the existing charsets (e.\+g. latin) fits to your language. When no charset exist, you need to provide a charset as a base for the language.

A new charset should provide at least\+:


\begin{DoxyEnumerate}
\item {\ttfamily encode} A function which normalize the charset of a passed text content (remove special chars, lingual transformations, etc.) and {\bfseries{returns an array of separated words}}. Also stemmer, matcher or stopword filter needs to be applied here. When the language has no words make sure to provide something similar, e.\+g. each chinese sign could also be a "{}word"{}. Don\textquotesingle{}t return the whole text content without split.
\item {\ttfamily rtl} A boolean flag which indicates right-\/to-\/left encoding
\end{DoxyEnumerate}

Basically the charset needs just to provide an encoder function along with an indicator for right-\/to-\/left encoding\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{export\ function\ encode(str)\{\ return\ [str]\ \}}
\DoxyCodeLine{export\ const\ rtl\ =\ false;}

\end{DoxyCode}


\label{README.md_compare}%
\Hypertarget{README.md_compare}%
 \hypertarget{README.md_autotoc_md15723}{}\doxysubsubsection{\texorpdfstring{Encoder Matching Comparison}{Encoder Matching Comparison}}\label{README.md_autotoc_md15723}
\begin{quote}
Reference String\+: {\bfseries{"{}\+Björn-\/\+Phillipp Mayer"{}}} \end{quote}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\multicolumn{5}{|l|}{}\\\cline{1-5}
Query &default &simple &advanced &extra  \\\cline{1-5}
björn &{\bfseries{yes}} &{\bfseries{yes}} &{\bfseries{yes}} &{\bfseries{yes}}  \\\cline{1-5}
\\\cline{1-5}
\end{longtabu}


björ 

{\bfseries{yes}} 

{\bfseries{yes}} 

{\bfseries{yes}} 

{\bfseries{yes}}  

bjorn 

no 

{\bfseries{yes}} 

{\bfseries{yes}} 

{\bfseries{yes}}  

bjoern 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

philipp 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

filip 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

björnphillip 

no 

{\bfseries{yes}} 

{\bfseries{yes}} 

{\bfseries{yes}}  

meier 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

björn meier 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

meier fhilip 

no 

no 

{\bfseries{yes}} 

{\bfseries{yes}}  

byorn mair 

no 

no 

no 

{\bfseries{yes}}  

{\itshape (false positives)} 

{\bfseries{no}} 

{\bfseries{no}} 

{\bfseries{no}} 

yes  

\label{README.md_memory}%
\Hypertarget{README.md_memory}%
 \hypertarget{README.md_autotoc_md15724}{}\doxysubsubsection{\texorpdfstring{Memory Allocation}{Memory Allocation}}\label{README.md_autotoc_md15724}
The book "{}\+Gulliver\textquotesingle{}s Travels Swift Jonathan 1726"{} was fully indexed for the examples below.

The most memory-\/optimized meaningful setting will allocate just 1.\+2 Mb for the whole book indexed! This is probably the most tiny memory footprint you will get from a search library.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ encode\ \}\ from\ "{}./lang/latin/extra.js"{};}
\DoxyCodeLine{}
\DoxyCodeLine{index\ =\ new\ Index(\{}
\DoxyCodeLine{\ \ \ \ encode:\ encode,}
\DoxyCodeLine{\ \ \ \ tokenize:\ "{}strict"{},}
\DoxyCodeLine{\ \ \ \ optimize:\ true,}
\DoxyCodeLine{\ \ \ \ resolution:\ 1,}
\DoxyCodeLine{\ \ \ \ minlength:\ 3,}
\DoxyCodeLine{\ \ \ \ fastupdate:\ false,}
\DoxyCodeLine{\ \ \ \ context:\ false}
\DoxyCodeLine{\});}

\end{DoxyCode}


\label{README.md_consumption}%
\Hypertarget{README.md_consumption}%
 \hypertarget{README.md_autotoc_md15725}{}\doxysubsubsubsection{\texorpdfstring{Memory Consumption}{Memory Consumption}}\label{README.md_autotoc_md15725}
The book "{}\+Gulliver\textquotesingle{}s Travels"{} (Swift Jonathan 1726) was completely indexed for this test\+:

~\newline
 \hypertarget{README.md_autotoc_md15726}{}\doxysubsubsubsection{\texorpdfstring{Compare Impact of Memory Allocation}{Compare Impact of Memory Allocation}}\label{README.md_autotoc_md15726}
by default a lexical index is very small\+:~\newline
 {\ttfamily depth\+: 0, bidirectional\+: 0, resolution\+: 3, minlength\+: 0} =\texorpdfstring{$>$}{>} 2.\+1 Mb

a higher resolution will increase the memory allocation\+:~\newline
 {\ttfamily depth\+: 0, bidirectional\+: 0, resolution\+: 9, minlength\+: 0} =\texorpdfstring{$>$}{>} 2.\+9 Mb

using the contextual index will increase the memory allocation\+:~\newline
 {\ttfamily depth\+: 1, bidirectional\+: 0, resolution\+: 9, minlength\+: 0} =\texorpdfstring{$>$}{>} 12.\+5 Mb

a higher contextual depth will increase the memory allocation\+:~\newline
 {\ttfamily depth\+: 2, bidirectional\+: 0, resolution\+: 9, minlength\+: 0} =\texorpdfstring{$>$}{>} 21.\+5 Mb

a higher minlength will decrease memory allocation\+:~\newline
 {\ttfamily depth\+: 2, bidirectional\+: 0, resolution\+: 9, minlength\+: 3} =\texorpdfstring{$>$}{>} 19.\+0 Mb

using bidirectional will decrease memory allocation\+:~\newline
 {\ttfamily depth\+: 2, bidirectional\+: 1, resolution\+: 9, minlength\+: 3} =\texorpdfstring{$>$}{>} 17.\+9 Mb

enable the option "{}fastupdate"{} will increase memory allocation\+:~\newline
 {\ttfamily depth\+: 2, bidirectional\+: 1, resolution\+: 9, minlength\+: 3} =\texorpdfstring{$>$}{>} 6.\+3 Mb\hypertarget{README.md_autotoc_md15727}{}\doxysubsubsubsection{\texorpdfstring{Full Comparison Table}{Full Comparison Table}}\label{README.md_autotoc_md15727}
Every search library is constantly in competition with these 4 properties\+:


\begin{DoxyEnumerate}
\item Memory Allocation
\item Performance
\item Matching Capabilities
\item Relevance Order (Scoring)
\end{DoxyEnumerate}

Flex\+Search provides you many parameters you can use to adjust the optimal balance for your specific use-\/case.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\multicolumn{5}{|l|}{}\\\cline{1-5}
Modifier &Memory Impact \texorpdfstring{$\ast$}{*} &Performance Impact \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} &Matching Impact \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} &Scoring Impact \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}  \\\cline{1-5}
resolution &+1 (per level) &+1 (per level) &0 &+2 (per level)  \\\cline{1-5}
\\\cline{1-5}
\end{longtabu}


depth 

+4 (per level) 

-\/1 (per level) 

-\/10 + depth 

+10  

minlength 

-\/2 (per level) 

+2 (per level) 

-\/3 (per level) 

+2 (per level)  

bidirectional 

-\/2 

0 

+3 

-\/1  

fastupdate 

+1 

+10 (update, remove) 

0 

0  

optimize\+: true 

-\/7 

-\/1 

0 

-\/3  

encoder\+: "{}icase"{} 

0 

0 

0 

0  

encoder\+: "{}simple"{} 

-\/2 

-\/1 

+2 

0  

encoder\+: "{}advanced"{} 

-\/3 

-\/2 

+4 

0  

encoder\+: "{}extra"{} 

-\/5 

-\/5 

+6 

0  

encoder\+: "{}soundex"{} 

-\/6 

-\/2 

+8 

0  

tokenize\+: "{}strict"{} 

0 

0 

0 

0  

tokenize\+: "{}forward"{} 

+3 

-\/2 

+5 

0  

tokenize\+: "{}reverse"{} 

+5 

-\/4 

+7 

0  

tokenize\+: "{}full"{} 

+8 

-\/5 

+10 

0  

document index 

+3 (per field) 

-\/1 (per field) 

0 

0  

document tags 

+1 (per tag) 

-\/1 (per tag) 

0 

0  

store\+: true 

+5 (per document) 

0 

0 

0  

store\+: \mbox{[}fields\mbox{]} 

+1 (per field) 

0 

0 

0  

cache\+: true 

+10 

+10 

0 

0  

cache\+: 100 

+1 

+9 

0 

0  

type of ids\+: number 

0 

0 

0 

0  

type of ids\+: string 

+3 

-\/3 

0 

0  


\begin{DoxyItemize}
\item range from -\/10 to 10, lower is better (-\/10 =\texorpdfstring{$>$}{>} big decrease, 0 =\texorpdfstring{$>$}{>} unchanged, +10 =\texorpdfstring{$>$}{>} big increase)~\newline
 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} range from -\/10 to 10, higher is better
\end{DoxyItemize}

\label{README.md_presets}%
\Hypertarget{README.md_presets}%
 \hypertarget{README.md_autotoc_md15728}{}\doxysubsubsection{\texorpdfstring{Presets}{Presets}}\label{README.md_autotoc_md15728}

\begin{DoxyEnumerate}
\item {\ttfamily memory} (primary optimize for memory)
\item {\ttfamily performance} (primary optimize for performance)
\item {\ttfamily match} (primary optimize for matching)
\item {\ttfamily score} (primary optimize for scoring)
\item {\ttfamily default} (the default balanced profile)
\end{DoxyEnumerate}

These profiles are covering standard use cases. It is recommended to apply custom configuration instead of using profiles to get the best out for your situation. Every profile could be optimized further to its specific task, e.\+g. extreme performance optimized configuration or extreme memory and so on.

You can pass a preset during creation/initialization of the index.\hypertarget{README.md_autotoc_md15729}{}\doxysubsubsection{\texorpdfstring{Best Practices}{Best Practices}}\label{README.md_autotoc_md15729}
\hypertarget{README.md_autotoc_md15730}{}\doxysubsubsubsubsubsection{\texorpdfstring{Use numeric IDs}{Use numeric IDs}}\label{README.md_autotoc_md15730}
It is recommended to use numeric id values as reference when adding content to the index. The byte length of passed ids influences the memory consumption significantly. If this is not possible you should consider to use a index table and map the ids with indexes, this becomes important especially when using contextual indexes on a large amount of content.\hypertarget{README.md_autotoc_md15731}{}\doxysubsubsubsubsubsection{\texorpdfstring{Split Complexity}{Split Complexity}}\label{README.md_autotoc_md15731}
Whenever you can, try to divide content by categories and add them to its own index, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ action\ =\ new\ FlexSearch();}
\DoxyCodeLine{var\ adventure\ =\ new\ FlexSearch();}
\DoxyCodeLine{var\ comedy\ =\ new\ FlexSearch();}

\end{DoxyCode}


This way you can also provide different settings for each category. This is actually the fastest way to perform a fuzzy search.

To make this workaround more extendable you can use a short helper\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ index\ =\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{function\ add(id,\ cat,\ content)\{}
\DoxyCodeLine{\ \ \ \ (index[cat]\ ||\ (}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index[cat]\ =\ new\ FlexSearch}
\DoxyCodeLine{\ \ \ \ )).add(id,\ content);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{function\ search(cat,\ query)\{}
\DoxyCodeLine{\ \ \ \ return\ index[cat]\ ?}
\DoxyCodeLine{\ \ \ \ \ \ \ \ index[cat].search(query)\ :\ [];}
\DoxyCodeLine{\}}

\end{DoxyCode}


Add content to the index\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{add(1,\ "{}action"{},\ "{}Movie\ Title"{});}
\DoxyCodeLine{add(2,\ "{}adventure"{},\ "{}Movie\ Title"{});}
\DoxyCodeLine{add(3,\ "{}comedy"{},\ "{}Movie\ Title"{});}

\end{DoxyCode}


Perform queries\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var\ results\ =\ search("{}action"{},\ "{}movie\ title"{});\ //\ -\/-\/>\ [1]}

\end{DoxyCode}


Split indexes by categories improves performance significantly.

\DoxyHorRuler{0}


Copyright 2018-\/2021 Nextapps GmbH~\newline
 Released under the \href{http://www.apache.org/licenses/LICENSE-2.0.html}{\texttt{ Apache 2.\+0 License}}~\newline
 