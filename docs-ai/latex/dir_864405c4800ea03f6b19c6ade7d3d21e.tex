\doxysection{node\+\_\+modules/bottleneck Directory Reference}
\hypertarget{dir_864405c4800ea03f6b19c6ade7d3d21e}{}\label{dir_864405c4800ea03f6b19c6ade7d3d21e}\index{node\_modules/bottleneck Directory Reference@{node\_modules/bottleneck Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://www.npmjs.com/package/bottleneck}{\texttt{ }} \href{https://www.npmjs.com/package/bottleneck}{\texttt{ }} \href{https://github.com/SGrondin/bottleneck/blob/master/LICENSE}{\texttt{ }}

Bottleneck is a lightweight and zero-\/dependency Task Scheduler and Rate Limiter for Node.\+js and the browser.

Bottleneck is an easy solution as it adds very little complexity to your code. It is battle-\/hardened, reliable and production-\/ready and used on a large scale in private companies and open source software.

It supports {\bfseries{Clustering}}\+: it can rate limit jobs across multiple Node.\+js instances. It uses Redis and strictly atomic operations to stay reliable in the presence of unreliable clients and networks. It also supports {\itshape Redis Cluster} and {\itshape Redis Sentinel}.

{\bfseries{Upgrading from version 1?}}


\begin{DoxyItemize}
\item Install
\item Quick Start
\begin{DoxyItemize}
\item Gotchas \& Common Mistakes
\end{DoxyItemize}
\item Constructor
\item Reservoir Intervals
\item \`{}submit()\`{}
\item \`{}schedule()\`{}
\item \`{}wrap()\`{}
\item Job Options
\item Jobs Lifecycle
\item Events
\item Retries
\item \`{}update\+Settings()\`{}
\item \`{}increment\+Reservoir()\`{}
\item \`{}current\+Reservoir()\`{}
\item \`{}stop()\`{}
\item \`{}chain()\`{}
\item \doxylink{README.md_group}{Group}
\item Batching
\item Clustering
\item Debugging Your Application
\item Upgrading To v2
\item \doxylink{md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g_contributing}{Contributing}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md9440}{}\doxysubsection{\texorpdfstring{Install}{Install}}\label{README.md_autotoc_md9440}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ -\/-\/save\ bottleneck}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{import\ Bottleneck\ from\ "{}bottleneck"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Note:\ To\ support\ older\ browsers\ and\ Node\ <6.0,\ you\ must\ import\ the\ ES5\ bundle\ instead.}
\DoxyCodeLine{var\ Bottleneck\ =\ require("{}bottleneck/es5"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9441}{}\doxysubsection{\texorpdfstring{Quick Start}{Quick Start}}\label{README.md_autotoc_md9441}
\hypertarget{README.md_autotoc_md9442}{}\doxysubsubsection{\texorpdfstring{Step 1 of 3}{Step 1 of 3}}\label{README.md_autotoc_md9442}
Most APIs have a rate limit. For example, to execute 3 requests per second\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ minTime:\ 333}
\DoxyCodeLine{\});}

\end{DoxyCode}


If there\textquotesingle{}s a chance some requests might take longer than 333ms and you want to prevent more than 1 request from running at a time, add {\ttfamily max\+Concurrent\+: 1}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ maxConcurrent:\ 1,}
\DoxyCodeLine{\ \ minTime:\ 333}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\ttfamily min\+Time} and {\ttfamily max\+Concurrent} are enough for the majority of use cases. They work well together to ensure a smooth rate of requests. If your use case requires executing requests in {\bfseries{bursts}} or every time a quota resets, look into Reservoir Intervals.\hypertarget{README.md_autotoc_md9443}{}\doxysubsubsection{\texorpdfstring{Step 2 of 3}{Step 2 of 3}}\label{README.md_autotoc_md9443}
\hypertarget{README.md_autotoc_md9444}{}\doxysubsubsubsection{\texorpdfstring{➤ Using promises?}{➤ Using promises?}}\label{README.md_autotoc_md9444}
Instead of this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{myFunction(arg1,\ arg2)}
\DoxyCodeLine{.then((result)\ =>\ \{}
\DoxyCodeLine{\ \ /*\ handle\ result\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}
 Do this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.schedule(()\ =>\ myFunction(arg1,\ arg2))}
\DoxyCodeLine{.then((result)\ =>\ \{}
\DoxyCodeLine{\ \ /*\ handle\ result\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}
 Or this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ wrapped\ =\ limiter.wrap(myFunction);}
\DoxyCodeLine{}
\DoxyCodeLine{wrapped(arg1,\ arg2)}
\DoxyCodeLine{.then((result)\ =>\ \{}
\DoxyCodeLine{\ \ /*\ handle\ result\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9445}{}\doxysubsubsubsection{\texorpdfstring{➤ Using async/await?}{➤ Using async/await?}}\label{README.md_autotoc_md9445}
Instead of this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ await\ myFunction(arg1,\ arg2);}

\end{DoxyCode}
 Do this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ await\ limiter.schedule(()\ =>\ myFunction(arg1,\ arg2));}

\end{DoxyCode}
 Or this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ wrapped\ =\ limiter.wrap(myFunction);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ result\ =\ await\ wrapped(arg1,\ arg2);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9446}{}\doxysubsubsubsection{\texorpdfstring{➤ Using callbacks?}{➤ Using callbacks?}}\label{README.md_autotoc_md9446}
Instead of this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{someAsyncCall(arg1,\ arg2,\ callback);}

\end{DoxyCode}
 Do this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.submit(someAsyncCall,\ arg1,\ arg2,\ callback);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9447}{}\doxysubsubsection{\texorpdfstring{Step 3 of 3}{Step 3 of 3}}\label{README.md_autotoc_md9447}
Remember...

Bottleneck builds a queue of jobs and executes them as soon as possible. By default, the jobs will be executed in the order they were received.

{\bfseries{Read the \textquotesingle{}Gotchas\textquotesingle{} and you\textquotesingle{}re good to go}}. Or keep reading to learn about all the fine tuning and advanced options available. If your rate limits need to be enforced across a cluster of computers, read the Clustering docs.

Need help debugging your application?

Instead of throttling maybe you want to batch up requests into fewer calls?\hypertarget{README.md_autotoc_md9448}{}\doxysubsubsection{\texorpdfstring{Gotchas \& Common Mistakes}{Gotchas \& Common Mistakes}}\label{README.md_autotoc_md9448}

\begin{DoxyItemize}
\item Make sure the function you pass to {\ttfamily schedule()} or {\ttfamily wrap()} only returns once {\bfseries{all the work it does}} has completed.
\end{DoxyItemize}

Instead of this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.schedule(()\ =>\ \{}
\DoxyCodeLine{\ \ tasksArray.forEach(x\ =>\ processTask(x));}
\DoxyCodeLine{\ \ //\ BAD,\ we\ return\ before\ our\ processTask()\ functions\ are\ finished\ processing!}
\DoxyCodeLine{\});}

\end{DoxyCode}
 Do this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.schedule(()\ =>\ \{}
\DoxyCodeLine{\ \ const\ allTasks\ =\ tasksArray.map(x\ =>\ processTask(x));}
\DoxyCodeLine{\ \ //\ GOOD,\ we\ wait\ until\ all\ tasks\ are\ done.}
\DoxyCodeLine{\ \ return\ Promise.all(allTasks);}
\DoxyCodeLine{\});}

\end{DoxyCode}



\begin{DoxyItemize}
\item If you\textquotesingle{}re passing an object\textquotesingle{}s method as a job, you\textquotesingle{}ll probably need to {\ttfamily bind()} the object\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{//\ instead\ of\ this:}
\DoxyCodeLine{limiter.schedule(object.doSomething);}
\DoxyCodeLine{//\ do\ this:}
\DoxyCodeLine{limiter.schedule(object.doSomething.bind(object));}
\DoxyCodeLine{//\ or,\ wrap\ it\ in\ an\ arrow\ function\ instead:}
\DoxyCodeLine{limiter.schedule(()\ =>\ object.doSomething());}

\end{DoxyCode}

\item Bottleneck requires Node 6+ to function. However, an ES5 build is included\+: {\ttfamily var Bottleneck = require("{}bottleneck/es5"{});}.
\item Make sure you\textquotesingle{}re catching {\ttfamily "{}error"{}} events emitted by your limiters!
\item Consider setting a {\ttfamily max\+Concurrent} value instead of leaving it {\ttfamily null}. This can help your application\textquotesingle{}s performance, especially if you think the limiter\textquotesingle{}s queue might become very long.
\item If you plan on using {\ttfamily priorities}, make sure to set a {\ttfamily max\+Concurrent} value.
\item {\bfseries{When using {\ttfamily submit()}}}, if a callback isn\textquotesingle{}t necessary, you must pass {\ttfamily null} or an empty function instead. It will not work otherwise.
\item {\bfseries{When using {\ttfamily submit()}}}, make sure all the jobs will eventually complete by calling their callback, or set an \`{}expiration\`{}. Even if you submitted your job with a {\ttfamily null} callback , it still needs to call its callback. This is particularly important if you are using a {\ttfamily max\+Concurrent} value that isn\textquotesingle{}t {\ttfamily null} (unlimited), otherwise those not completed jobs will be clogging up the limiter and no new jobs will be allowed to run. It\textquotesingle{}s safe to call the callback more than once, subsequent calls are ignored.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md9449}{}\doxysubsection{\texorpdfstring{Docs}{Docs}}\label{README.md_autotoc_md9449}
\hypertarget{README.md_autotoc_md9450}{}\doxysubsubsection{\texorpdfstring{Constructor}{Constructor}}\label{README.md_autotoc_md9450}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{/*\ options\ */\});}

\end{DoxyCode}


Basic options\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily max\+Concurrent}   &{\ttfamily null} (unlimited)   &How many jobs can be executing at the same time. Consider setting a value instead of leaving it {\ttfamily null}, it can help your application\textquotesingle{}s performance, especially if you think the limiter\textquotesingle{}s queue might get very long.    \\\cline{1-3}
{\ttfamily min\+Time}   &{\ttfamily 0} ms   &How long to wait after launching a job before launching another one.    \\\cline{1-3}
{\ttfamily high\+Water}   &{\ttfamily null} (unlimited)   &How long can the queue be? When the queue length exceeds that value, the selected {\ttfamily strategy} is executed to shed the load.    \\\cline{1-3}
{\ttfamily strategy}   &{\ttfamily Bottleneck.\+strategy.\+LEAK}   &Which strategy to use when the queue gets longer than the high water mark. Read about strategies. Strategies are never executed if {\ttfamily high\+Water} is {\ttfamily null}.    \\\cline{1-3}
{\ttfamily penalty}   &{\ttfamily 15 \texorpdfstring{$\ast$}{*} min\+Time}, or {\ttfamily 5000} when {\ttfamily min\+Time} is {\ttfamily 0}   &The {\ttfamily penalty} value used by the {\ttfamily BLOCK} strategy.    \\\cline{1-3}
{\ttfamily reservoir}   &{\ttfamily null} (unlimited)   &How many jobs can be executed before the limiter stops executing jobs. If {\ttfamily reservoir} reaches {\ttfamily 0}, no jobs will be executed until it is no longer {\ttfamily 0}. New jobs will still be queued up.    \\\cline{1-3}
{\ttfamily reservoir\+Refresh\+Interval}   &{\ttfamily null} (disabled)   &Every {\ttfamily reservoir\+Refresh\+Interval} milliseconds, the {\ttfamily reservoir} value will be automatically updated to the value of {\ttfamily reservoir\+Refresh\+Amount}. The {\ttfamily reservoir\+Refresh\+Interval} value should be a \href{https://github.com/SGrondin/bottleneck/issues/88}{\texttt{ multiple of 250 (5000 for Clustering)}}.    \\\cline{1-3}
{\ttfamily reservoir\+Refresh\+Amount}   &{\ttfamily null} (disabled)   &The value to set {\ttfamily reservoir} to when {\ttfamily reservoir\+Refresh\+Interval} is in use.    \\\cline{1-3}
{\ttfamily reservoir\+Increase\+Interval}   &{\ttfamily null} (disabled)   &Every {\ttfamily reservoir\+Increase\+Interval} milliseconds, the {\ttfamily reservoir} value will be automatically incremented by {\ttfamily reservoir\+Increase\+Amount}. The {\ttfamily reservoir\+Increase\+Interval} value should be a \href{https://github.com/SGrondin/bottleneck/issues/88}{\texttt{ multiple of 250 (5000 for Clustering)}}.    \\\cline{1-3}
{\ttfamily reservoir\+Increase\+Amount}   &{\ttfamily null} (disabled)   &The increment applied to {\ttfamily reservoir} when {\ttfamily reservoir\+Increase\+Interval} is in use.    \\\cline{1-3}
{\ttfamily reservoir\+Increase\+Maximum}   &{\ttfamily null} (disabled)   &The maximum value that {\ttfamily reservoir} can reach when {\ttfamily reservoir\+Increase\+Interval} is in use.    \\\cline{1-3}
{\ttfamily Promise}   &{\ttfamily Promise} (built-\/in)   &This lets you override the Promise library used by Bottleneck.   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md9451}{}\doxysubsubsection{\texorpdfstring{Reservoir Intervals}{Reservoir Intervals}}\label{README.md_autotoc_md9451}
Reservoir Intervals let you execute requests in bursts, by automatically controlling the limiter\textquotesingle{}s {\ttfamily reservoir} value. The {\ttfamily reservoir} is simply the number of jobs the limiter is allowed to execute. Once the value reaches 0, it stops starting new jobs.

There are 2 types of Reservoir Intervals\+: Refresh Intervals and Increase Intervals.\hypertarget{README.md_autotoc_md9452}{}\doxysubsubsubsection{\texorpdfstring{Refresh Interval}{Refresh Interval}}\label{README.md_autotoc_md9452}
In this example, we throttle to 100 requests every 60 seconds\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ reservoir:\ 100,\ //\ initial\ value}
\DoxyCodeLine{\ \ reservoirRefreshAmount:\ 100,}
\DoxyCodeLine{\ \ reservoirRefreshInterval:\ 60\ *\ 1000,\ //\ must\ be\ divisible\ by\ 250}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ also\ use\ maxConcurrent\ and/or\ minTime\ for\ safety}
\DoxyCodeLine{\ \ maxConcurrent:\ 1,}
\DoxyCodeLine{\ \ minTime:\ 333\ //\ pick\ a\ value\ that\ makes\ sense\ for\ your\ use\ case}
\DoxyCodeLine{\});}

\end{DoxyCode}
 {\ttfamily reservoir} is a counter decremented every time a job is launched, we set its initial value to 100. Then, every {\ttfamily reservoir\+Refresh\+Interval} (60000 ms), {\ttfamily reservoir} is automatically updated to be equal to the {\ttfamily reservoir\+Refresh\+Amount} (100).\hypertarget{README.md_autotoc_md9453}{}\doxysubsubsubsection{\texorpdfstring{Increase Interval}{Increase Interval}}\label{README.md_autotoc_md9453}
In this example, we throttle jobs to meet the Shopify API Rate Limits. Users are allowed to send 40 requests initially, then every second grants 2 more requests up to a maximum of 40.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ reservoir:\ 40,\ //\ initial\ value}
\DoxyCodeLine{\ \ reservoirIncreaseAmount:\ 2,}
\DoxyCodeLine{\ \ reservoirIncreaseInterval:\ 1000,\ //\ must\ be\ divisible\ by\ 250}
\DoxyCodeLine{\ \ reservoirIncreaseMaximum:\ 40,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ also\ use\ maxConcurrent\ and/or\ minTime\ for\ safety}
\DoxyCodeLine{\ \ maxConcurrent:\ 5,}
\DoxyCodeLine{\ \ minTime:\ 250\ //\ pick\ a\ value\ that\ makes\ sense\ for\ your\ use\ case}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9454}{}\doxysubsubsubsection{\texorpdfstring{Warnings}{Warnings}}\label{README.md_autotoc_md9454}
Reservoir Intervals are an advanced feature, please take the time to read and understand the following warnings.


\begin{DoxyItemize}
\item {\bfseries{Reservoir Intervals are not a replacement for {\ttfamily min\+Time} and {\ttfamily max\+Concurrent}.}} It\textquotesingle{}s strongly recommended to also use {\ttfamily min\+Time} and/or {\ttfamily max\+Concurrent} to spread out the load. For example, suppose a lot of jobs are queued up because the {\ttfamily reservoir} is 0. Every time the Refresh Interval is triggered, a number of jobs equal to {\ttfamily reservoir\+Refresh\+Amount} will automatically be launched, all at the same time! To prevent this flooding effect and keep your application running smoothly, use {\ttfamily min\+Time} and {\ttfamily max\+Concurrent} to {\bfseries{stagger}} the jobs.
\item {\bfseries{The Reservoir Interval starts from the moment the limiter is created}}. Let\textquotesingle{}s suppose we\textquotesingle{}re using {\ttfamily reservoir\+Refresh\+Amount\+: 5}. If you happen to add 10 jobs just 1ms before the refresh is triggered, the first 5 will run immediately, then 1ms later it will refresh the reservoir value and that will make the last 5 also run right away. It will have run 10 jobs in just over 1ms no matter what your reservoir interval was!
\item {\bfseries{Reservoir Intervals prevent a limiter from being garbage collected.}} Call {\ttfamily limiter.\+disconnect()} to clear the interval and allow the memory to be freed. However, it\textquotesingle{}s not necessary to call {\ttfamily .disconnect()} to allow the Node.\+js process to exit.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md9455}{}\doxysubsubsection{\texorpdfstring{submit()}{submit()}}\label{README.md_autotoc_md9455}
Adds a job to the queue. This is the callback version of {\ttfamily schedule()}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.submit(someAsyncCall,\ arg1,\ arg2,\ callback);}

\end{DoxyCode}
 You can pass {\ttfamily null} instead of an empty function if there is no callback, but {\ttfamily some\+Async\+Call} still needs to call {\bfseries{its}} callback to let the limiter know it has completed its work.

{\ttfamily submit()} can also accept advanced options.\hypertarget{README.md_autotoc_md9456}{}\doxysubsubsection{\texorpdfstring{schedule()}{schedule()}}\label{README.md_autotoc_md9456}
Adds a job to the queue. This is the Promise and async/await version of {\ttfamily submit()}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ fn\ =\ function(arg1,\ arg2)\ \{}
\DoxyCodeLine{\ \ return\ httpGet(arg1,\ arg2);\ //\ Here\ httpGet()\ returns\ a\ promise}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.schedule(fn,\ arg1,\ arg2)}
\DoxyCodeLine{.then((result)\ =>\ \{}
\DoxyCodeLine{\ \ /*\ ...\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}
 In other words, {\ttfamily schedule()} takes a function {\bfseries{fn}} and a list of arguments. {\ttfamily schedule()} returns a promise that will be executed according to the rate limits.

{\ttfamily schedule()} can also accept advanced options.

Here\textquotesingle{}s another example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{//\ suppose\ that\ \`{}client.get(url)`\ returns\ a\ promise}
\DoxyCodeLine{}
\DoxyCodeLine{const\ url\ =\ "{}https://wikipedia.org"{};}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.schedule(()\ =>\ client.get(url))}
\DoxyCodeLine{.then(response\ =>\ console.log(response.body));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9457}{}\doxysubsubsection{\texorpdfstring{wrap()}{wrap()}}\label{README.md_autotoc_md9457}
Takes a function that returns a promise. Returns a function identical to the original, but rate limited. 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ wrapped\ =\ limiter.wrap(fn);}
\DoxyCodeLine{}
\DoxyCodeLine{wrapped()}
\DoxyCodeLine{.then(function\ (result)\ \{}
\DoxyCodeLine{\ \ /*\ ...\ */}
\DoxyCodeLine{\})}
\DoxyCodeLine{.catch(function\ (error)\ \{}
\DoxyCodeLine{\ \ //\ Bottleneck\ might\ need\ to\ fail\ the\ job\ even\ if\ the\ original\ function\ can\ never\ fail.}
\DoxyCodeLine{\ \ //\ For\ example,\ your\ job\ is\ taking\ longer\ than\ the\ \`{}expiration`\ time\ you've\ set.}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9458}{}\doxysubsubsection{\texorpdfstring{Job Options}{Job Options}}\label{README.md_autotoc_md9458}
{\ttfamily submit()}, {\ttfamily schedule()}, and {\ttfamily wrap()} all accept advanced options. 
\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Submit}
\DoxyCodeLine{limiter.submit(\{/*\ options\ */\},\ someAsyncCall,\ arg1,\ arg2,\ callback);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Schedule}
\DoxyCodeLine{limiter.schedule(\{/*\ options\ */\},\ fn,\ arg1,\ arg2);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Wrap}
\DoxyCodeLine{const\ wrapped\ =\ limiter.wrap(fn);}
\DoxyCodeLine{wrapped.withOptions(\{/*\ options\ */\},\ arg1,\ arg2);}

\end{DoxyCode}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily priority}   &{\ttfamily 5}   &A priority between {\ttfamily 0} and {\ttfamily 9}. A job with a priority of {\ttfamily 4} will be queued ahead of a job with a priority of {\ttfamily 5}. {\bfseries{Important\+:}} You must set a low {\ttfamily max\+Concurrent} value for priorities to work, otherwise there is nothing to queue because jobs will be be scheduled immediately!    \\\cline{1-3}
{\ttfamily weight}   &{\ttfamily 1}   &Must be an integer equal to or higher than {\ttfamily 0}. The {\ttfamily weight} is what increases the number of running jobs (up to {\ttfamily max\+Concurrent}) and decreases the {\ttfamily reservoir} value.    \\\cline{1-3}
{\ttfamily expiration}   &{\ttfamily null} (unlimited)   &The number of milliseconds a job is given to complete. Jobs that execute for longer than {\ttfamily expiration} ms will be failed with a {\ttfamily Bottleneck\+Error}.    \\\cline{1-3}
{\ttfamily id}   &{\ttfamily \texorpdfstring{$<$}{<}no-\/id\texorpdfstring{$>$}{>}}   &You should give an ID to your jobs, it helps with debugging.   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md9459}{}\doxysubsubsection{\texorpdfstring{Strategies}{Strategies}}\label{README.md_autotoc_md9459}
A strategy is a simple algorithm that is executed every time adding a job would cause the number of queued jobs to exceed {\ttfamily high\+Water}. Strategies are never executed if {\ttfamily high\+Water} is {\ttfamily null}.\hypertarget{README.md_autotoc_md9460}{}\doxysubsubsubsection{\texorpdfstring{Bottleneck.\+strategy.\+LEAK}{Bottleneck.\+strategy.\+LEAK}}\label{README.md_autotoc_md9460}
When adding a new job to a limiter, if the queue length reaches {\ttfamily high\+Water}, drop the oldest job with the lowest priority. This is useful when jobs that have been waiting for too long are not important anymore. If all the queued jobs are more important (based on their {\ttfamily priority} value) than the one being added, it will not be added.\hypertarget{README.md_autotoc_md9461}{}\doxysubsubsubsection{\texorpdfstring{Bottleneck.\+strategy.\+OVERFLOW\+\_\+\+PRIORITY}{Bottleneck.\+strategy.\+OVERFLOW\+\_\+\+PRIORITY}}\label{README.md_autotoc_md9461}
Same as {\ttfamily LEAK}, except it will only drop jobs that are {\itshape less important} than the one being added. If all the queued jobs are as or more important than the new one, it will not be added.\hypertarget{README.md_autotoc_md9462}{}\doxysubsubsubsection{\texorpdfstring{Bottleneck.\+strategy.\+OVERFLOW}{Bottleneck.\+strategy.\+OVERFLOW}}\label{README.md_autotoc_md9462}
When adding a new job to a limiter, if the queue length reaches {\ttfamily high\+Water}, do not add the new job. This strategy totally ignores priority levels.\hypertarget{README.md_autotoc_md9463}{}\doxysubsubsubsection{\texorpdfstring{Bottleneck.\+strategy.\+BLOCK}{Bottleneck.\+strategy.\+BLOCK}}\label{README.md_autotoc_md9463}
When adding a new job to a limiter, if the queue length reaches {\ttfamily high\+Water}, the limiter falls into "{}blocked mode"{}. All queued jobs are dropped and no new jobs will be accepted until the limiter unblocks. It will unblock after {\ttfamily penalty} milliseconds have passed without receiving a new job. {\ttfamily penalty} is equal to {\ttfamily 15 \texorpdfstring{$\ast$}{*} min\+Time} (or {\ttfamily 5000} if {\ttfamily min\+Time} is {\ttfamily 0}) by default. This strategy is ideal when bruteforce attacks are to be expected. This strategy totally ignores priority levels.\hypertarget{README.md_autotoc_md9464}{}\doxysubsubsection{\texorpdfstring{Jobs lifecycle}{Jobs lifecycle}}\label{README.md_autotoc_md9464}

\begin{DoxyEnumerate}
\item {\bfseries{Received}}. Your new job has been added to the limiter. Bottleneck needs to check whether it can be accepted into the queue.
\item {\bfseries{Queued}}. Bottleneck has accepted your job, but it can not tell at what exact timestamp it will run yet, because it is dependent on previous jobs.
\item {\bfseries{Running}}. Your job is not in the queue anymore, it will be executed after a delay that was computed according to your {\ttfamily min\+Time} setting.
\item {\bfseries{Executing}}. Your job is executing its code.
\item {\bfseries{Done}}. Your job has completed.
\end{DoxyEnumerate}

{\bfseries{Note\+:}} By default, Bottleneck does not keep track of DONE jobs, to save memory. You can enable this feature by passing {\ttfamily track\+Done\+Status\+: true} as an option when creating a limiter.\hypertarget{README.md_autotoc_md9465}{}\doxysubsubsubsection{\texorpdfstring{counts()}{counts()}}\label{README.md_autotoc_md9465}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ counts\ =\ limiter.counts();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(counts);}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ RECEIVED:\ 0,}
\DoxyCodeLine{\ \ QUEUED:\ 0,}
\DoxyCodeLine{\ \ RUNNING:\ 0,}
\DoxyCodeLine{\ \ EXECUTING:\ 0,}
\DoxyCodeLine{\ \ DONE:\ 0}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}


Returns an object with the current number of jobs per status in the limiter.\hypertarget{README.md_autotoc_md9466}{}\doxysubsubsubsection{\texorpdfstring{job\+Status()}{job\+Status()}}\label{README.md_autotoc_md9466}

\begin{DoxyCode}{0}
\DoxyCodeLine{console.log(limiter.jobStatus("{}some-\/job-\/id"{}));}
\DoxyCodeLine{//\ Example:\ QUEUED}

\end{DoxyCode}


Returns the status of the job with the provided job id {\bfseries{in the limiter}}. Returns {\ttfamily null} if no job with that id exist.\hypertarget{README.md_autotoc_md9467}{}\doxysubsubsubsection{\texorpdfstring{jobs()}{jobs()}}\label{README.md_autotoc_md9467}

\begin{DoxyCode}{0}
\DoxyCodeLine{console.log(limiter.jobs("{}RUNNING"{}));}
\DoxyCodeLine{//\ Example:\ ['id1',\ 'id2']}

\end{DoxyCode}


Returns an array of all the job ids with the specified status {\bfseries{in the limiter}}. Not passing a status string returns all the known ids.\hypertarget{README.md_autotoc_md9468}{}\doxysubsubsubsection{\texorpdfstring{queued()}{queued()}}\label{README.md_autotoc_md9468}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ count\ =\ limiter.queued(priority);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(count);}

\end{DoxyCode}


{\ttfamily priority} is optional. Returns the number of {\ttfamily QUEUED} jobs with the given {\ttfamily priority} level. Omitting the {\ttfamily priority} argument returns the total number of queued jobs {\bfseries{in the limiter}}.\hypertarget{README.md_autotoc_md9469}{}\doxysubsubsubsection{\texorpdfstring{cluster\+Queued()}{cluster\+Queued()}}\label{README.md_autotoc_md9469}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ count\ =\ await\ limiter.clusterQueued();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(count);}

\end{DoxyCode}


Returns the number of {\ttfamily QUEUED} jobs {\bfseries{in the Cluster}}.\hypertarget{README.md_autotoc_md9470}{}\doxysubsubsubsection{\texorpdfstring{empty()}{empty()}}\label{README.md_autotoc_md9470}

\begin{DoxyCode}{0}
\DoxyCodeLine{if\ (limiter.empty())\ \{}
\DoxyCodeLine{\ \ //\ do\ something...}
\DoxyCodeLine{\}}

\end{DoxyCode}


Returns a boolean which indicates whether there are any {\ttfamily RECEIVED} or {\ttfamily QUEUED} jobs {\bfseries{in the limiter}}.\hypertarget{README.md_autotoc_md9471}{}\doxysubsubsubsection{\texorpdfstring{running()}{running()}}\label{README.md_autotoc_md9471}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.running()}
\DoxyCodeLine{.then((count)\ =>\ console.log(count));}

\end{DoxyCode}


Returns a promise that returns the {\bfseries{total weight}} of the {\ttfamily RUNNING} and {\ttfamily EXECUTING} jobs {\bfseries{in the Cluster}}.\hypertarget{README.md_autotoc_md9472}{}\doxysubsubsubsection{\texorpdfstring{done()}{done()}}\label{README.md_autotoc_md9472}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.done()}
\DoxyCodeLine{.then((count)\ =>\ console.log(count));}

\end{DoxyCode}


Returns a promise that returns the {\bfseries{total weight}} of {\ttfamily DONE} jobs {\bfseries{in the Cluster}}. Does not require passing the {\ttfamily track\+Done\+Status\+: true} option.\hypertarget{README.md_autotoc_md9473}{}\doxysubsubsubsection{\texorpdfstring{check()}{check()}}\label{README.md_autotoc_md9473}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.check()}
\DoxyCodeLine{.then((wouldRunNow)\ =>\ console.log(wouldRunNow));}

\end{DoxyCode}
 Checks if a new job would be executed immediately if it was submitted now. Returns a promise that returns a boolean.\hypertarget{README.md_autotoc_md9474}{}\doxysubsubsection{\texorpdfstring{Events}{Events}}\label{README.md_autotoc_md9474}
{\bfseries{\textquotesingle{}error\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}error"{},\ function\ (error)\ \{}
\DoxyCodeLine{\ \ /*\ handle\ errors\ here\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}


The two main causes of error events are\+: uncaught exceptions in your event handlers, and network errors when Clustering is enabled.

{\bfseries{\textquotesingle{}failed\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}failed"{},\ function\ (error,\ jobInfo)\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ every\ time\ a\ job\ fails.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}retry\textquotesingle{}}}

See Retries to learn how to automatically retry jobs. 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}retry"{},\ function\ (message,\ jobInfo)\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ every\ time\ a\ job\ is\ retried.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}empty\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}empty"{},\ function\ ()\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ when\ \`{}limiter.empty()`\ becomes\ true.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}idle\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}idle"{},\ function\ ()\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ when\ \`{}limiter.empty()`\ is\ \`{}true`\ and\ \`{}limiter.running()`\ is\ \`{}0`.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}dropped\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}dropped"{},\ function\ (dropped)\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ when\ a\ strategy\ was\ triggered.}
\DoxyCodeLine{\ \ //\ The\ dropped\ request\ is\ passed\ to\ this\ event\ listener.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}depleted\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}depleted"{},\ function\ (empty)\ \{}
\DoxyCodeLine{\ \ //\ This\ will\ be\ called\ every\ time\ the\ reservoir\ drops\ to\ 0.}
\DoxyCodeLine{\ \ //\ The\ \`{}empty`\ (boolean)\ argument\ indicates\ whether\ \`{}limiter.empty()`\ is\ currently\ true.}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}debug\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}debug"{},\ function\ (message,\ data)\ \{}
\DoxyCodeLine{\ \ //\ Useful\ to\ figure\ out\ what\ the\ limiter\ is\ doing\ in\ real\ time}
\DoxyCodeLine{\ \ //\ and\ to\ help\ debug\ your\ application}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\bfseries{\textquotesingle{}received\textquotesingle{}}} {\bfseries{\textquotesingle{}queued\textquotesingle{}}} {\bfseries{\textquotesingle{}scheduled\textquotesingle{}}} {\bfseries{\textquotesingle{}executing\textquotesingle{}}} {\bfseries{\textquotesingle{}done\textquotesingle{}}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}queued"{},\ function\ (info)\ \{}
\DoxyCodeLine{\ \ //\ This\ event\ is\ triggered\ when\ a\ job\ transitions\ from\ one\ Lifecycle\ stage\ to\ another}
\DoxyCodeLine{\});}

\end{DoxyCode}


See Jobs Lifecycle for more information.

These Lifecycle events are not triggered for jobs located on another limiter in a Cluster, for performance reasons.\hypertarget{README.md_autotoc_md9475}{}\doxysubsubsubsection{\texorpdfstring{Other event methods}{Other event methods}}\label{README.md_autotoc_md9475}
Use {\ttfamily remove\+All\+Listeners()} with an optional event name as first argument to remove listeners.

Use {\ttfamily .once()} instead of {\ttfamily .on()} to only receive a single event.\hypertarget{README.md_autotoc_md9476}{}\doxysubsubsection{\texorpdfstring{Retries}{Retries}}\label{README.md_autotoc_md9476}
The following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Listen\ to\ the\ "{}failed"{}\ event}
\DoxyCodeLine{limiter.on("{}failed"{},\ async\ (error,\ jobInfo)\ =>\ \{}
\DoxyCodeLine{\ \ const\ id\ =\ jobInfo.options.id;}
\DoxyCodeLine{\ \ console.warn(`Job\ \$\{id\}\ failed:\ \$\{error\}`);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (jobInfo.retryCount\ ===\ 0)\ \{\ //\ Here\ we\ only\ retry\ once}
\DoxyCodeLine{\ \ \ \ console.log(`Retrying\ job\ \$\{id\}\ in\ 25ms!`);}
\DoxyCodeLine{\ \ \ \ return\ 25;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Listen\ to\ the\ "{}retry"{}\ event}
\DoxyCodeLine{limiter.on("{}retry"{},\ (error,\ jobInfo)\ =>\ console.log(`Now\ retrying\ \$\{jobInfo.options.id\}`));}
\DoxyCodeLine{}
\DoxyCodeLine{const\ main\ =\ async\ function\ ()\ \{}
\DoxyCodeLine{\ \ let\ executions\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Schedule\ one\ job}
\DoxyCodeLine{\ \ const\ result\ =\ await\ limiter.schedule(\{\ id:\ 'ABC123'\ \},\ async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ executions++;}
\DoxyCodeLine{\ \ \ \ if\ (executions\ ===\ 1)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ throw\ new\ Error("{}Boom!"{});}
\DoxyCodeLine{\ \ \ \ \}\ else\ \{}
\DoxyCodeLine{\ \ \ \ \ \ return\ "{}Success!"{};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ console.log(`Result:\ \$\{result\}`);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{main();}

\end{DoxyCode}
 will output 
\begin{DoxyCode}{0}
\DoxyCodeLine{Job\ ABC123\ failed:\ Error:\ Boom!}
\DoxyCodeLine{Retrying\ job\ ABC123\ in\ 25ms!}
\DoxyCodeLine{Now\ retrying\ ABC123}
\DoxyCodeLine{Result:\ Success!}

\end{DoxyCode}
 To re-\/run your job, simply return an integer from the `\textquotesingle{}failed'{\ttfamily event handler. The number returned is how many milliseconds to wait before retrying it. Return}0\`{} to retry it immediately.

{\bfseries{IMPORTANT\+:}} When you ask the limiter to retry a job it will not send it back into the queue. It will stay in the {\ttfamily EXECUTING} state until it succeeds or until you stop retrying it. {\bfseries{This means that it counts as a concurrent job for {\ttfamily max\+Concurrent} even while it\textquotesingle{}s just waiting to be retried.}} The number of milliseconds to wait ignores your {\ttfamily min\+Time} settings.\hypertarget{README.md_autotoc_md9477}{}\doxysubsubsection{\texorpdfstring{update\+Settings()}{update\+Settings()}}\label{README.md_autotoc_md9477}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.updateSettings(options);}

\end{DoxyCode}
 The options are the same as the limiter constructor.

{\bfseries{Note\+:}} Changes don\textquotesingle{}t affect {\ttfamily SCHEDULED} jobs.\hypertarget{README.md_autotoc_md9478}{}\doxysubsubsection{\texorpdfstring{increment\+Reservoir()}{increment\+Reservoir()}}\label{README.md_autotoc_md9478}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.incrementReservoir(incrementBy);}

\end{DoxyCode}
 Returns a promise that returns the new reservoir value.\hypertarget{README.md_autotoc_md9479}{}\doxysubsubsection{\texorpdfstring{current\+Reservoir()}{current\+Reservoir()}}\label{README.md_autotoc_md9479}

\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.currentReservoir()}
\DoxyCodeLine{.then((reservoir)\ =>\ console.log(reservoir));}

\end{DoxyCode}
 Returns a promise that returns the current reservoir value.\hypertarget{README.md_autotoc_md9480}{}\doxysubsubsection{\texorpdfstring{stop()}{stop()}}\label{README.md_autotoc_md9480}
The {\ttfamily stop()} method is used to safely shutdown a limiter. It prevents any new jobs from being added to the limiter and waits for all {\ttfamily EXECUTING} jobs to complete.


\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.stop(options)}
\DoxyCodeLine{.then(()\ =>\ \{}
\DoxyCodeLine{\ \ console.log("{}Shutdown\ completed!"{})}
\DoxyCodeLine{\});}

\end{DoxyCode}


{\ttfamily stop()} returns a promise that resolves once all the {\ttfamily EXECUTING} jobs have completed and, if desired, once all non-\/{\ttfamily EXECUTING} jobs have been dropped.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily drop\+Waiting\+Jobs}   &{\ttfamily true}   &When {\ttfamily true}, drop all the {\ttfamily RECEIVED}, {\ttfamily QUEUED} and {\ttfamily RUNNING} jobs. When {\ttfamily false}, allow those jobs to complete before resolving the Promise returned by this method.    \\\cline{1-3}
{\ttfamily drop\+Error\+Message}   &{\ttfamily This limiter has been stopped.}   &The error message used to drop jobs when {\ttfamily drop\+Waiting\+Jobs} is {\ttfamily true}.    \\\cline{1-3}
{\ttfamily enqueue\+Error\+Message}   &{\ttfamily This limiter has been stopped and cannot accept new jobs.}   &The error message used to reject a job added to the limiter after {\ttfamily stop()} has been called.   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md9481}{}\doxysubsubsection{\texorpdfstring{chain()}{chain()}}\label{README.md_autotoc_md9481}
Tasks that are ready to be executed will be added to that other limiter. Suppose you have 2 types of tasks, A and B. They both have their own limiter with their own settings, but both must also follow a global limiter G\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiterA\ =\ new\ Bottleneck(\ /*\ some\ settings\ */\ );}
\DoxyCodeLine{const\ limiterB\ =\ new\ Bottleneck(\ /*\ some\ different\ settings\ */\ );}
\DoxyCodeLine{const\ limiterG\ =\ new\ Bottleneck(\ /*\ some\ global\ settings\ */\ );}
\DoxyCodeLine{}
\DoxyCodeLine{limiterA.chain(limiterG);}
\DoxyCodeLine{limiterB.chain(limiterG);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Requests\ added\ to\ limiterA\ must\ follow\ the\ A\ and\ G\ rate\ limits.}
\DoxyCodeLine{//\ Requests\ added\ to\ limiterB\ must\ follow\ the\ B\ and\ G\ rate\ limits.}
\DoxyCodeLine{//\ Requests\ added\ to\ limiterG\ must\ follow\ the\ G\ rate\ limits.}

\end{DoxyCode}


To unchain, call {\ttfamily limiter.\+chain(null);}.\hypertarget{README.md_autotoc_md9482}{}\doxysubsection{\texorpdfstring{Group}{Group}}\label{README.md_autotoc_md9482}
The {\ttfamily Group} feature of Bottleneck manages many limiters automatically for you. It creates limiters dynamically and transparently.

Let\textquotesingle{}s take a DNS server as an example of how Bottleneck can be used. It\textquotesingle{}s a service that sees a lot of abuse and where incoming DNS requests need to be rate limited. Bottleneck is so tiny, it\textquotesingle{}s acceptable to create one limiter for each origin IP, even if it means creating thousands of limiters. The {\ttfamily Group} feature is perfect for this use case. Create one Group and use the origin IP to rate limit each IP independently. Each call with the same key (IP) will be routed to the same underlying limiter. A Group is created like a limiter\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ group\ =\ new\ Bottleneck.Group(options);}

\end{DoxyCode}


The {\ttfamily options} object will be used for every limiter created by the Group.

The Group is then used with the {\ttfamily .key(str)} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ In\ this\ example,\ the\ key\ is\ an\ IP}
\DoxyCodeLine{group.key("{}77.66.54.32"{}).schedule(()\ =>\ \{}
\DoxyCodeLine{\ \ /*\ process\ the\ request\ */}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9483}{}\doxysubsubsubsection{\texorpdfstring{key()}{key()}}\label{README.md_autotoc_md9483}

\begin{DoxyItemize}
\item {\ttfamily str} \+: The key to use. All jobs added with the same key will use the same underlying limiter. {\itshape Default\+: {\ttfamily "{}"{}}}
\end{DoxyItemize}

The return value of {\ttfamily .key(str)} is a limiter. If it doesn\textquotesingle{}t already exist, it is generated for you. Calling {\ttfamily key()} is how limiters are created inside a Group.

Limiters that have been idle for longer than 5 minutes are deleted to avoid memory leaks, this value can be changed by passing a different {\ttfamily timeout} option, in milliseconds.\hypertarget{README.md_autotoc_md9484}{}\doxysubsubsubsection{\texorpdfstring{on("{}created"{})}{on("{}created"{})}}\label{README.md_autotoc_md9484}

\begin{DoxyCode}{0}
\DoxyCodeLine{group.on("{}created"{},\ (limiter,\ key)\ =>\ \{}
\DoxyCodeLine{\ \ console.log("{}A\ new\ limiter\ was\ created\ for\ key:\ "{}\ +\ key)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Prepare\ the\ limiter,\ for\ example\ we'll\ want\ to\ listen\ to\ its\ "{}error"{}\ events!}
\DoxyCodeLine{\ \ limiter.on("{}error"{},\ (err)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ Handle\ errors\ here}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\});}

\end{DoxyCode}


Listening for the {\ttfamily "{}created"{}} event is the recommended way to set up a new limiter. Your event handler is executed before {\ttfamily key()} returns the newly created limiter.\hypertarget{README.md_autotoc_md9485}{}\doxysubsubsubsection{\texorpdfstring{update\+Settings()}{update\+Settings()}}\label{README.md_autotoc_md9485}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ group\ =\ new\ Bottleneck.Group(\{\ maxConcurrent:\ 2,\ minTime:\ 250\ \});}
\DoxyCodeLine{group.updateSettings(\{\ minTime:\ 500\ \});}

\end{DoxyCode}
 After executing the above commands, {\bfseries{new limiters}} will be created with {\ttfamily \{ max\+Concurrent\+: 2, min\+Time\+: 500 \}}.\hypertarget{README.md_autotoc_md9486}{}\doxysubsubsubsection{\texorpdfstring{delete\+Key()}{delete\+Key()}}\label{README.md_autotoc_md9486}

\begin{DoxyItemize}
\item {\ttfamily str}\+: The key for the limiter to delete.
\end{DoxyItemize}

Manually deletes the limiter at the specified key. When using Clustering, the Redis data is immediately deleted and the other Groups in the Cluster will eventually delete their local key automatically, unless it is still being used.\hypertarget{README.md_autotoc_md9487}{}\doxysubsubsubsection{\texorpdfstring{keys()}{keys()}}\label{README.md_autotoc_md9487}
Returns an array containing all the keys in the Group.\hypertarget{README.md_autotoc_md9488}{}\doxysubsubsubsection{\texorpdfstring{cluster\+Keys()}{cluster\+Keys()}}\label{README.md_autotoc_md9488}
Same as {\ttfamily group.\+keys()}, but returns all keys in this Group ID across the Cluster.\hypertarget{README.md_autotoc_md9489}{}\doxysubsubsubsection{\texorpdfstring{limiters()}{limiters()}}\label{README.md_autotoc_md9489}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiters\ =\ group.limiters();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(limiters);}
\DoxyCodeLine{//\ [\ \{\ key:\ "{}some\ key"{},\ limiter:\ <limiter>\ \},\ \{\ key:\ "{}some\ other\ key"{},\ limiter:\ <some\ other\ limiter>\ \}\ ]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9490}{}\doxysubsection{\texorpdfstring{Batching}{Batching}}\label{README.md_autotoc_md9490}
Some APIs can accept multiple operations in a single call. Bottleneck\textquotesingle{}s Batching feature helps you take advantage of those APIs\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ batcher\ =\ new\ Bottleneck.Batcher(\{}
\DoxyCodeLine{\ \ maxTime:\ 1000,}
\DoxyCodeLine{\ \ maxSize:\ 10}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{batcher.on("{}batch"{},\ (batch)\ =>\ \{}
\DoxyCodeLine{\ \ console.log(batch);\ //\ ["{}some-\/data"{},\ "{}some-\/other-\/data"{}]}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Handle\ batch\ here}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{batcher.add("{}some-\/data"{});}
\DoxyCodeLine{batcher.add("{}some-\/other-\/data"{});}

\end{DoxyCode}


{\ttfamily batcher.\+add()} returns a Promise that resolves once the request has been flushed to a {\ttfamily "{}batch"{}} event.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily max\+Time}   &{\ttfamily null} (unlimited)   &Maximum acceptable time (in milliseconds) a request can have to wait before being flushed to the {\ttfamily "{}batch"{}} event.    \\\cline{1-3}
{\ttfamily max\+Size}   &{\ttfamily null} (unlimited)   &Maximum number of requests in a batch.   \\\cline{1-3}
\end{longtabu}


Batching doesn\textquotesingle{}t throttle requests, it only groups them up optimally according to your {\ttfamily max\+Time} and {\ttfamily max\+Size} settings.\hypertarget{README.md_autotoc_md9491}{}\doxysubsection{\texorpdfstring{Clustering}{Clustering}}\label{README.md_autotoc_md9491}
Clustering lets many limiters access the same shared state, stored in Redis. Changes to the state are Atomic, Consistent and Isolated (and fully \href{https://en.wikipedia.org/wiki/ACID}{\texttt{ ACID}} with the right \href{https://redis.io/topics/persistence}{\texttt{ Durability}} configuration), to eliminate any chances of race conditions or state corruption. Your settings, such as {\ttfamily max\+Concurrent}, {\ttfamily min\+Time}, etc., are shared across the whole cluster, which means —for example— that {\ttfamily \{ max\+Concurrent\+: 5 \}} guarantees no more than 5 jobs can ever run at a time in the entire cluster of limiters. 100\% of Bottleneck\textquotesingle{}s features are supported in Clustering mode. Enabling Clustering is as simple as changing a few settings. It\textquotesingle{}s also a convenient way to store or export state for later use.

Bottleneck will attempt to spread load evenly across limiters.\hypertarget{README.md_autotoc_md9492}{}\doxysubsubsection{\texorpdfstring{Enabling Clustering}{Enabling Clustering}}\label{README.md_autotoc_md9492}
First, add {\ttfamily redis} or {\ttfamily ioredis} to your application\textquotesingle{}s dependencies\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ NodeRedis\ (https://github.com/NodeRedis/node\_redis)}
\DoxyCodeLine{npm\ install\ -\/-\/save\ redis}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ or\ ioredis\ (https://github.com/luin/ioredis)}
\DoxyCodeLine{npm\ install\ -\/-\/save\ ioredis}

\end{DoxyCode}
 Then create a limiter or a Group\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ /*\ Some\ basic\ options\ */}
\DoxyCodeLine{\ \ maxConcurrent:\ 5,}
\DoxyCodeLine{\ \ minTime:\ 500}
\DoxyCodeLine{\ \ id:\ "{}my-\/super-\/app"{}\ //\ All\ limiters\ with\ the\ same\ id\ will\ be\ clustered\ together}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /*\ Clustering\ options\ */}
\DoxyCodeLine{\ \ datastore:\ "{}redis"{},\ //\ or\ "{}ioredis"{}}
\DoxyCodeLine{\ \ clearDatastore:\ false,}
\DoxyCodeLine{\ \ clientOptions:\ \{}
\DoxyCodeLine{\ \ \ \ host:\ "{}127.0.0.1"{},}
\DoxyCodeLine{\ \ \ \ port:\ 6379}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Redis\ client\ options}
\DoxyCodeLine{\ \ \ \ //\ Using\ NodeRedis?\ See\ https://github.com/NodeRedis/node\_redis\#options-\/object-\/properties}
\DoxyCodeLine{\ \ \ \ //\ Using\ ioredis?\ See\ https://github.com/luin/ioredis/blob/master/API.md\#new-\/redisport-\/host-\/options}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily datastore}   &{\ttfamily "{}local"{}}   &Where the limiter stores its internal state. The default ({\ttfamily "{}local"{}}) keeps the state in the limiter itself. Set it to {\ttfamily "{}redis"{}} or {\ttfamily "{}ioredis"{}} to enable Clustering.    \\\cline{1-3}
{\ttfamily clear\+Datastore}   &{\ttfamily false}   &When set to {\ttfamily true}, on initial startup, the limiter will wipe any existing Bottleneck state data on the Redis db.    \\\cline{1-3}
{\ttfamily client\+Options}   &{\ttfamily \{\}}   &This object is passed directly to the redis client library you\textquotesingle{}ve selected.    \\\cline{1-3}
{\ttfamily cluster\+Nodes}   &{\ttfamily null}   &{\bfseries{ioredis only.}} When {\ttfamily cluster\+Nodes} is not null, the client will be instantiated by calling {\ttfamily new Redis.\+Cluster(cluster\+Nodes, client\+Options)} instead of {\ttfamily new Redis(client\+Options)}.    \\\cline{1-3}
{\ttfamily timeout}   &{\ttfamily null} (no TTL)   &The Redis TTL in milliseconds (\href{https://redis.io/commands/ttl}{\texttt{ TTL}}) for the keys created by the limiter. When {\ttfamily timeout} is set, the limiter\textquotesingle{}s state will be automatically removed from Redis after {\ttfamily timeout} milliseconds of inactivity.    \\\cline{1-3}
{\ttfamily Redis}   &{\ttfamily null}   &Overrides the import/require of the redis/ioredis library. You shouldn\textquotesingle{}t need to set this option unless your application is failing to start due to a failure to require/import the client library.   \\\cline{1-3}
\end{longtabu}


{\bfseries{Note\+: When using Groups}}, the {\ttfamily timeout} option has a default of {\ttfamily 300000} milliseconds and the generated limiters automatically receive an {\ttfamily id} with the pattern {\ttfamily \$\{group.\+id\}-\/\$\{KEY\}}.

{\bfseries{Note\+:}} If you are seeing a runtime error due to the {\ttfamily require()} function not being able to load {\ttfamily redis}/{\ttfamily ioredis}, then directly pass the module as the {\ttfamily Redis} option. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{import\ Redis\ from\ "{}ioredis"{}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{}
\DoxyCodeLine{\ \ id:\ "{}my-\/super-\/app"{},}
\DoxyCodeLine{\ \ datastore:\ "{}ioredis"{},}
\DoxyCodeLine{\ \ clientOptions:\ \{\ host:\ '12.34.56.78',\ port:\ 6379\ \},}
\DoxyCodeLine{\ \ Redis}
\DoxyCodeLine{\});}

\end{DoxyCode}
 Unfortunately, this is a side effect of having to disable inlining, which is necessary to make Bottleneck easy to use in the browser.\hypertarget{README.md_autotoc_md9493}{}\doxysubsubsection{\texorpdfstring{Important considerations when Clustering}{Important considerations when Clustering}}\label{README.md_autotoc_md9493}
The first limiter connecting to Redis will store its constructor options on Redis and all subsequent limiters will be using those settings. You can alter the constructor options used by all the connected limiters by calling {\ttfamily update\+Settings()}. The {\ttfamily clear\+Datastore} option instructs a new limiter to wipe any previous Bottleneck data (for that {\ttfamily id}), including previously stored settings.

Queued jobs are {\bfseries{NOT}} stored on Redis. They are local to each limiter. Exiting the Node.\+js process will lose those jobs. This is because Bottleneck has no way to propagate the JS code to run a job across a different Node.\+js process than the one it originated on. Bottleneck doesn\textquotesingle{}t keep track of the queue contents of the limiters on a cluster for performance and reliability reasons. You can use something like \href{https://github.com/bee-queue/bee-queue}{\texttt{ {\ttfamily Bee\+Queue}}} in addition to Bottleneck to get around this limitation.

Due to the above, functionality relying on the queue length happens purely locally\+:
\begin{DoxyItemize}
\item Priorities are local. A higher priority job will run before a lower priority job {\bfseries{on the same limiter}}. Another limiter on the cluster might run a lower priority job before our higher priority one.
\item Assuming constant priority levels, Bottleneck guarantees that jobs will be run in the order they were received {\bfseries{on the same limiter}}. Another limiter on the cluster might run a job received later before ours runs.
\item {\ttfamily high\+Water} and load shedding (strategies) are per limiter. However, one limiter entering Blocked mode will put the entire cluster in Blocked mode until {\ttfamily penalty} milliseconds have passed. See Strategies.
\item The {\ttfamily "{}empty"{}} event is triggered when the (local) queue is empty.
\item The {\ttfamily "{}idle"{}} event is triggered when the (local) queue is empty {\itshape and} no jobs are currently running anywhere in the cluster.
\end{DoxyItemize}

You must work around these limitations in your application code if they are an issue to you. The {\ttfamily publish()} method could be useful here.

The current design guarantees reliability, is highly performant and lets limiters come and go. Your application can scale up or down, and clients can be disconnected at any time without issues.

It is {\bfseries{strongly recommended}} that you give an {\ttfamily id} to every limiter and Group since it is used to build the name of your limiter\textquotesingle{}s Redis keys! Limiters with the same {\ttfamily id} inside the same Redis db will be sharing the same datastore.

It is {\bfseries{strongly recommended}} that you set an {\ttfamily expiration} (See Job Options) {\itshape on every job}, since that lets the cluster recover from crashed or disconnected clients. Otherwise, a client crashing while executing a job would not be able to tell the cluster to decrease its number of "{}running"{} jobs. By using expirations, those lost jobs are automatically cleared after the specified time has passed. Using expirations is essential to keeping a cluster reliable in the face of unpredictable application bugs, network hiccups, and so on.

Network latency between Node.\+js and Redis is not taken into account when calculating timings (such as {\ttfamily min\+Time}). To minimize the impact of latency, Bottleneck only performs a single Redis call per lifecycle transition. Keeping the Redis server close to your limiters will help you get a more consistent experience. Keeping the system time consistent across all clients will also help.

It is {\bfseries{strongly recommended}} to set up an \`{}"{}error"{}\`{} listener on all your limiters and on your Groups.\hypertarget{README.md_autotoc_md9494}{}\doxysubsubsection{\texorpdfstring{Clustering Methods}{Clustering Methods}}\label{README.md_autotoc_md9494}
The {\ttfamily ready()}, {\ttfamily publish()} and {\ttfamily clients()} methods also exist when using the {\ttfamily local} datastore, for code compatibility reasons\+: code written for {\ttfamily redis}/{\ttfamily ioredis} won\textquotesingle{}t break with {\ttfamily local}.\hypertarget{README.md_autotoc_md9495}{}\doxysubsubsubsection{\texorpdfstring{ready()}{ready()}}\label{README.md_autotoc_md9495}
This method returns a promise that resolves once the limiter is connected to Redis.

As of v2.\+9.\+0, it\textquotesingle{}s no longer necessary to wait for {\ttfamily .ready()} to resolve before issuing commands to a limiter. The commands will be queued until the limiter successfully connects. Make sure to listen to the {\ttfamily "{}error"{}} event to handle connection errors.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{/*\ options\ */\});}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.on("{}error"{},\ (err)\ =>\ \{}
\DoxyCodeLine{\ \ //\ handle\ network\ errors}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.ready()}
\DoxyCodeLine{.then(()\ =>\ \{}
\DoxyCodeLine{\ \ //\ The\ limiter\ is\ ready}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9496}{}\doxysubsubsubsection{\texorpdfstring{publish(message)}{publish(message)}}\label{README.md_autotoc_md9496}
This method broadcasts the {\ttfamily message} string to every limiter in the Cluster. It returns a promise. 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{/*\ options\ */\});}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.on("{}message"{},\ (msg)\ =>\ \{}
\DoxyCodeLine{\ \ console.log(msg);\ //\ prints\ "{}this\ is\ a\ string"{}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.publish("{}this\ is\ a\ string"{});}

\end{DoxyCode}


To send objects, stringify them first\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.on("{}message"{},\ (msg)\ =>\ \{}
\DoxyCodeLine{\ \ console.log(JSON.parse(msg).hello)\ //\ prints\ "{}world"{}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{limiter.publish(JSON.stringify(\{\ hello:\ "{}world"{}\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9497}{}\doxysubsubsubsection{\texorpdfstring{clients()}{clients()}}\label{README.md_autotoc_md9497}
If you need direct access to the redis clients, use {\ttfamily .clients()}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{console.log(limiter.clients());}
\DoxyCodeLine{//\ \{\ client:\ <Redis\ Client>,\ subscriber:\ <Redis\ Client>\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9498}{}\doxysubsubsection{\texorpdfstring{Additional Clustering information}{Additional Clustering information}}\label{README.md_autotoc_md9498}

\begin{DoxyItemize}
\item Bottleneck is compatible with \href{https://redis.io/topics/cluster-tutorial}{\texttt{ Redis Clusters}}, but you must use the {\ttfamily ioredis} datastore and the {\ttfamily cluster\+Nodes} option.
\item Bottleneck is compatible with Redis Sentinel, but you must use the {\ttfamily ioredis} datastore.
\item Bottleneck\textquotesingle{}s data is stored in Redis keys starting with {\ttfamily b\+\_\+}. It also uses pubsub channels starting with {\ttfamily b\+\_\+} It will not interfere with any other data stored on the server.
\item Bottleneck loads a few Lua scripts on the Redis server using the {\ttfamily SCRIPT LOAD} command. These scripts only take up a few Kb of memory. Running the {\ttfamily SCRIPT FLUSH} command will cause any connected limiters to experience critical errors until a new limiter connects to Redis and loads the scripts again.
\item The Lua scripts are highly optimized and designed to use as few resources as possible.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md9499}{}\doxysubsubsection{\texorpdfstring{Managing Redis Connections}{Managing Redis Connections}}\label{README.md_autotoc_md9499}
Bottleneck needs to create 2 Redis Clients to function, one for normal operations and one for pubsub subscriptions. These 2 clients are kept in a {\ttfamily Bottleneck.\+Redis\+Connection} (Node\+Redis) or a {\ttfamily Bottleneck.\+IORedis\+Connection} (ioredis) object, referred to as the Connection object.

By default, every Group and every standalone limiter (a limiter not created by a Group) will create their own Connection object, but it is possible to manually control this behavior. In this example, every Group and limiter is sharing the same Connection object and therefore the same 2 clients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ connection\ =\ new\ Bottleneck.RedisConnection(\{}
\DoxyCodeLine{\ \ clientOptions:\ \{/*\ NodeRedis/ioredis\ options\ */\}}
\DoxyCodeLine{\ \ //\ ioredis\ also\ accepts\ \`{}clusterNodes`\ here}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{\ connection:\ connection\ \});}
\DoxyCodeLine{const\ group\ =\ new\ Bottleneck.Group(\{\ connection:\ connection\ \});}

\end{DoxyCode}
 You can access and reuse the Connection object of any Group or limiter\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{const\ group\ =\ new\ Bottleneck.Group(\{\ connection:\ limiter.connection\ \});}

\end{DoxyCode}
 When a Connection object is created manually, the connectivity {\ttfamily "{}error"{}} events are emitted on the Connection itself. 
\begin{DoxyCode}{0}
\DoxyCodeLine{connection.on("{}error"{},\ (err)\ =>\ \{\ /*\ handle\ connectivity\ errors\ here\ */\ \});}

\end{DoxyCode}
 If you already have a Node\+Redis/ioredis client, you can ask Bottleneck to reuse it, although currently the Connection object will still create a second client for pubsub operations\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{import\ Redis\ from\ "{}redis"{};}
\DoxyCodeLine{const\ client\ =\ new\ Redis.createClient(\{/*\ options\ */\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ connection\ =\ new\ Bottleneck.RedisConnection(\{}
\DoxyCodeLine{\ \ //\ \`{}clientOptions`\ and\ \`{}clusterNodes`\ will\ be\ ignored\ since\ we're\ passing\ a\ raw\ client}
\DoxyCodeLine{\ \ client:\ client}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ limiter\ =\ new\ Bottleneck(\{\ connection:\ connection\ \});}
\DoxyCodeLine{const\ group\ =\ new\ Bottleneck.Group(\{\ connection:\ connection\ \});}

\end{DoxyCode}
 Depending on your application, using more clients can improve performance.

Use the {\ttfamily disconnect(flush)} method to close the Redis clients. 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.disconnect();}
\DoxyCodeLine{group.disconnect();}

\end{DoxyCode}
 If you created the Connection object manually, you need to call {\ttfamily connection.\+disconnect()} instead, for safety reasons.\hypertarget{README.md_autotoc_md9500}{}\doxysubsection{\texorpdfstring{Debugging your application}{Debugging your application}}\label{README.md_autotoc_md9500}
Debugging complex scheduling logic can be difficult, especially when priorities, weights, and network latency all interact with one another.

If your application is not behaving as expected, start by making sure you\textquotesingle{}re catching {\ttfamily "{}error"{}} events emitted by your limiters and your Groups. Those errors are most likely uncaught exceptions from your application code.

Make sure you\textquotesingle{}ve read the \textquotesingle{}Gotchas\textquotesingle{} section.

To see exactly what a limiter is doing in real time, listen to the {\ttfamily "{}debug"{}} event. It contains detailed information about how the limiter is executing your code. Adding job IDs to all your jobs makes the debug output more readable.

When Bottleneck has to fail one of your jobs, it does so by using {\ttfamily Bottleneck\+Error} objects. This lets you tell those errors apart from your own code\textquotesingle{}s errors\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{limiter.schedule(fn)}
\DoxyCodeLine{.then((result)\ =>\ \{\ /*\ ...\ */\ \}\ )}
\DoxyCodeLine{.catch((error)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (error\ instanceof\ Bottleneck.BottleneckError)\ \{}
\DoxyCodeLine{\ \ \ \ /*\ ...\ */}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md9501}{}\doxysubsection{\texorpdfstring{Upgrading to v2}{Upgrading to v2}}\label{README.md_autotoc_md9501}
The internal algorithms essentially haven\textquotesingle{}t changed from v1, but many small changes to the interface were made to introduce new features.

All the breaking changes\+:
\begin{DoxyItemize}
\item Bottleneck v2 requires Node 6+ or a modern browser. Use {\ttfamily require("{}bottleneck/es5"{})} if you need ES5 support in v2. Bottleneck v1 will continue to use ES5 only.
\item The Bottleneck constructor now takes an options object. See Constructor.
\item The {\ttfamily Cluster} feature is now called {\ttfamily Group}. This is to distinguish it from the new v2 Clustering feature.
\item The {\ttfamily Group} constructor takes an options object to match the limiter constructor.
\item Jobs take an optional options object. See Job options.
\item Removed {\ttfamily submit\+Priority()}, use {\ttfamily submit()} with an options object instead.
\item Removed {\ttfamily schedule\+Priority()}, use {\ttfamily schedule()} with an options object instead.
\item The {\ttfamily reject\+On\+Drop} option is now {\ttfamily true} by default. It can be set to {\ttfamily false} if you wish to retain v1 behavior. However this option is left undocumented as enabling it is considered to be a poor practice.
\item Use {\ttfamily null} instead of {\ttfamily 0} to indicate an unlimited {\ttfamily max\+Concurrent} value.
\item Use {\ttfamily null} instead of {\ttfamily -\/1} to indicate an unlimited {\ttfamily high\+Water} value.
\item Renamed {\ttfamily change\+Settings()} to {\ttfamily update\+Settings()}, it now returns a promise to indicate completion. It takes the same options object as the constructor.
\item Renamed {\ttfamily nb\+Queued()} to {\ttfamily queued()}.
\item Renamed {\ttfamily nb\+Running} to {\ttfamily running()}, it now returns its result using a promise.
\item Removed {\ttfamily is\+Blocked()}.
\item Changing the Promise library is now done through the options object like any other limiter setting.
\item Removed {\ttfamily change\+Penalty()}, it is now done through the options object like any other limiter setting.
\item Removed {\ttfamily change\+Reservoir()}, it is now done through the options object like any other limiter setting.
\item Removed {\ttfamily stop\+All()}. Use the new {\ttfamily stop()} method.
\item {\ttfamily check()} now accepts an optional {\ttfamily weight} argument, and returns its result using a promise.
\item Removed the {\ttfamily Group} {\ttfamily change\+Timeout()} method. Instead, pass a {\ttfamily timeout} option when creating a Group.
\end{DoxyItemize}

Version 2 is more user-\/friendly and powerful.

After upgrading your code, please take a minute to read the Debugging your application chapter.\hypertarget{README.md_autotoc_md9502}{}\doxysubsection{\texorpdfstring{Contributing}{Contributing}}\label{README.md_autotoc_md9502}
This README is always in need of improvements. If wording can be clearer and simpler, please consider forking this repo and submitting a Pull Request, or simply opening an issue.

Suggestions and bug reports are also welcome.

To work on the Bottleneck code, simply clone the repo, makes your changes to the files located in {\ttfamily src/} only, then run {\ttfamily ./scripts/build.sh \&\& npm test} to ensure that everything is set up correctly.

To speed up compilation time during development, run {\ttfamily ./scripts/build.sh dev} instead. Make sure to build and test without {\ttfamily dev} before submitting a PR.

The tests must also pass in Clustering mode and using the ES5 bundle. You\textquotesingle{}ll need a Redis server running locally (latency needs to be minimal to run the tests). If the server isn\textquotesingle{}t using the default hostname and port, you can set those in the {\ttfamily .env} file. Then run {\ttfamily ./scripts/build.sh \&\& npm run test-\/all}.

All contributions are appreciated and will be considered. 