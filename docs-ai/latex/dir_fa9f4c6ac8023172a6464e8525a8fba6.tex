\doxysection{node\+\_\+modules/@atproto/api Directory Reference}
\hypertarget{dir_fa9f4c6ac8023172a6464e8525a8fba6}{}\label{dir_fa9f4c6ac8023172a6464e8525a8fba6}\index{node\_modules/"@atproto/api Directory Reference@{node\_modules/"@atproto/api Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_0b6fb90de05aabdc116ecbc7dd55ac69}{docs}}
\item 
directory \mbox{\hyperlink{dir_6cff4e96a83c0bb89ba01a11248a1ded}{node\+\_\+modules}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This API is a client for ATProtocol servers. It communicates using HTTP. It includes\+:


\begin{DoxyItemize}
\item âœ”ï¸ APIs for ATProto and Bluesky.
\item âœ”ï¸ Validation and complete typescript types.
\item âœ”ï¸ Session management.
\item âœ”ï¸ A Rich\+Text library.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md1962}{}\doxysubsection{\texorpdfstring{Getting started}{Getting started}}\label{README.md_autotoc_md1962}
First install the package\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{yarn\ add\ @atproto/api}

\end{DoxyCode}


Then in your application\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ AtpAgent\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ agent\ =\ new\ AtpAgent(\{\ service:\ 'https://example.com'\ \})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1963}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md1963}
\hypertarget{README.md_autotoc_md1964}{}\doxysubsubsection{\texorpdfstring{Session management}{Session management}}\label{README.md_autotoc_md1964}
You\textquotesingle{}ll need an authenticated session for most API calls. There are two ways to manage sessions\+:


\begin{DoxyEnumerate}
\item App password based session management
\item OAuth based session management
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md1965}{}\doxysubsubsubsection{\texorpdfstring{App password based session management}{App password based session management}}\label{README.md_autotoc_md1965}
Username / password based authentication can be performed using the {\ttfamily Atp\+Agent} class.

\begin{DoxyAttention}{Attention}
~\newline
 This method is deprecated in favor of OAuth based session management. It is recommended to use OAuth based session management (through the {\ttfamily @atproto/oauth-\/client-\/\texorpdfstring{$\ast$}{*}} packages).
\end{DoxyAttention}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ AtpAgent,\ AtpSessionEvent,\ AtpSessionData\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ configure\ connection\ to\ the\ server,\ without\ account\ authentication}
\DoxyCodeLine{const\ agent\ =\ new\ AtpAgent(\{}
\DoxyCodeLine{\ \ service:\ 'https://example.com',}
\DoxyCodeLine{\ \ persistSession:\ (evt:\ AtpSessionEvent,\ sess?:\ AtpSessionData)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ store\ the\ session-\/data\ for\ reuse}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Change\ the\ agent\ state\ to\ an\ authenticated\ state\ either\ by:}
\DoxyCodeLine{}
\DoxyCodeLine{//\ 1)\ creating\ a\ new\ account\ on\ the\ server.}
\DoxyCodeLine{await\ agent.createAccount(\{}
\DoxyCodeLine{\ \ email:\ 'alice@mail.com',}
\DoxyCodeLine{\ \ password:\ 'hunter2',}
\DoxyCodeLine{\ \ handle:\ 'alice.example.com',}
\DoxyCodeLine{\ \ inviteCode:\ 'some-\/code-\/12345-\/abcde',}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ 2)\ if\ an\ existing\ session\ was\ securely\ stored\ previously,\ then\ reuse\ that\ to\ resume\ the\ session.}
\DoxyCodeLine{await\ agent.resumeSession(savedSessionData)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ 3)\ if\ no\ old\ session\ was\ available,\ create\ a\ new\ one\ by\ logging\ in\ with\ password\ (App\ Password)}
\DoxyCodeLine{await\ agent.login(\{}
\DoxyCodeLine{\ \ identifier:\ 'alice@mail.com',}
\DoxyCodeLine{\ \ password:\ 'hunter2',}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1966}{}\doxysubsubsubsection{\texorpdfstring{OAuth based session management}{OAuth based session management}}\label{README.md_autotoc_md1966}
Depending on the environment used by your application, different OAuth clients are available\+:


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/@atproto/oauth-client-browser}{\texttt{ @atproto/oauth-\/client-\/browser}}\+: for the browser.
\item \href{https://www.npmjs.com/package/@atproto/oauth-client-node}{\texttt{ @atproto/oauth-\/client-\/node}}\+: for Node.\+js.
\item \href{https://www.npmjs.com/package/@atproto/oauth-client}{\texttt{ @atproto/oauth-\/client}}\+: Lower level; compatible with most JS engines.
\end{DoxyItemize}

Every {\ttfamily @atproto/oauth-\/client-\/\texorpdfstring{$\ast$}{*}} implementation has a different way to obtain an {\ttfamily OAuth\+Session} instance that can be used to instantiate an {\ttfamily Agent} (from {\ttfamily @atproto/api}). Here is an example restoring a previously saved session\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ Agent\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{import\ \{\ OAuthClient\ \}\ from\ '@atproto/oauth-\/client'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ oauthClient\ =\ new\ OAuthClient(\{}
\DoxyCodeLine{\ \ //\ ...}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{const\ oauthSession\ =\ await\ oauthClient.restore('did:plc:123')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instantiate\ the\ api\ Agent\ using\ an\ OAuthSession}
\DoxyCodeLine{const\ agent\ =\ new\ Agent(oauthSession)}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1967}{}\doxysubsubsection{\texorpdfstring{API calls}{API calls}}\label{README.md_autotoc_md1967}
The agent includes methods for many common operations, including\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ The\ DID\ of\ the\ user\ currently\ authenticated\ (or\ undefined)}
\DoxyCodeLine{agent.did}
\DoxyCodeLine{agent.accountDid\ //\ Throws\ if\ the\ user\ is\ not\ authenticated}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Feeds\ and\ content}
\DoxyCodeLine{await\ agent.getTimeline(params,\ opts)}
\DoxyCodeLine{await\ agent.getAuthorFeed(params,\ opts)}
\DoxyCodeLine{await\ agent.getPostThread(params,\ opts)}
\DoxyCodeLine{await\ agent.getPost(params)}
\DoxyCodeLine{await\ agent.getPosts(params,\ opts)}
\DoxyCodeLine{await\ agent.getLikes(params,\ opts)}
\DoxyCodeLine{await\ agent.getRepostedBy(params,\ opts)}
\DoxyCodeLine{await\ agent.post(record)}
\DoxyCodeLine{await\ agent.deletePost(postUri)}
\DoxyCodeLine{await\ agent.like(uri,\ cid)}
\DoxyCodeLine{await\ agent.deleteLike(likeUri)}
\DoxyCodeLine{await\ agent.repost(uri,\ cid)}
\DoxyCodeLine{await\ agent.deleteRepost(repostUri)}
\DoxyCodeLine{await\ agent.uploadBlob(data,\ opts)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Social\ graph}
\DoxyCodeLine{await\ agent.getFollows(params,\ opts)}
\DoxyCodeLine{await\ agent.getFollowers(params,\ opts)}
\DoxyCodeLine{await\ agent.follow(did)}
\DoxyCodeLine{await\ agent.deleteFollow(followUri)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Actors}
\DoxyCodeLine{await\ agent.getProfile(params,\ opts)}
\DoxyCodeLine{await\ agent.upsertProfile(updateFn)}
\DoxyCodeLine{await\ agent.getProfiles(params,\ opts)}
\DoxyCodeLine{await\ agent.getSuggestions(params,\ opts)}
\DoxyCodeLine{await\ agent.searchActors(params,\ opts)}
\DoxyCodeLine{await\ agent.searchActorsTypeahead(params,\ opts)}
\DoxyCodeLine{await\ agent.mute(did)}
\DoxyCodeLine{await\ agent.unmute(did)}
\DoxyCodeLine{await\ agent.muteModList(listUri)}
\DoxyCodeLine{await\ agent.unmuteModList(listUri)}
\DoxyCodeLine{await\ agent.blockModList(listUri)}
\DoxyCodeLine{await\ agent.unblockModList(listUri)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Notifications}
\DoxyCodeLine{await\ agent.listNotifications(params,\ opts)}
\DoxyCodeLine{await\ agent.countUnreadNotifications(params,\ opts)}
\DoxyCodeLine{await\ agent.updateSeenNotifications()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Identity}
\DoxyCodeLine{await\ agent.resolveHandle(params,\ opts)}
\DoxyCodeLine{await\ agent.updateHandle(params,\ opts)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Legacy:\ Session\ management\ should\ be\ performed\ through\ the\ SessionManager}
\DoxyCodeLine{//\ rather\ than\ the\ Agent\ instance.}
\DoxyCodeLine{if\ (agent\ instanceof\ AtpAgent)\ \{}
\DoxyCodeLine{\ \ //\ AtpAgent\ instances\ support\ using\ different\ sessions\ during\ their\ lifetime}
\DoxyCodeLine{\ \ await\ agent.createAccount(\{\ ...\ \})\ //\ session\ a}
\DoxyCodeLine{\ \ await\ agent.login(\{\ ...\ \})\ //\ session\ b}
\DoxyCodeLine{\ \ await\ agent.resumeSession(savedSession)\ //\ session\ c}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1968}{}\doxysubsubsection{\texorpdfstring{Validation and types}{Validation and types}}\label{README.md_autotoc_md1968}
The package includes a complete types system which includes validation and type-\/guards. For example, to validate a post record\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ AppBskyFeedPost\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ post\ =\ \{...\}}
\DoxyCodeLine{if\ (AppBskyFeedPost.isRecord(post))\ \{}
\DoxyCodeLine{\ \ //\ typescript\ now\ recognizes\ \`{}post`\ as\ a\ AppBskyFeedPost.Record}
\DoxyCodeLine{\ \ //\ however\ -\/-\/\ we\ still\ need\ to\ validate\ it}
\DoxyCodeLine{\ \ const\ res\ =\ AppBskyFeedPost.validateRecord(post)}
\DoxyCodeLine{\ \ if\ (res.success)\ \{}
\DoxyCodeLine{\ \ \ \ //\ a\ valid\ record}
\DoxyCodeLine{\ \ \}\ else\ \{}
\DoxyCodeLine{\ \ \ \ //\ something\ is\ wrong}
\DoxyCodeLine{\ \ \ \ console.log(res.error)}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1969}{}\doxysubsubsection{\texorpdfstring{Rich text}{Rich text}}\label{README.md_autotoc_md1969}
Some records (ie posts) use the {\ttfamily app.\+bsky.\+richtext} lexicon. At the moment richtext is only used for links and mentions, but it will be extended over time to include bold, italic, and so on.

â„¹ï¸ It is {\bfseries{strongly}} recommended to use this package\textquotesingle{}s {\ttfamily Rich\+Text} library. Javascript encodes strings in utf16 while the protocol (and most other programming environments) use utf8. Converting between the two is challenging, but {\ttfamily Rich\+Text} handles that for you.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ RichText\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ creating\ richtext}
\DoxyCodeLine{const\ rt\ =\ new\ RichText(\{}
\DoxyCodeLine{\ \ text:\ 'Hello\ @alice.com,\ check\ out\ this\ link:\ https://example.com',}
\DoxyCodeLine{\})}
\DoxyCodeLine{await\ rt.detectFacets(agent)\ //\ automatically\ detects\ mentions\ and\ links}
\DoxyCodeLine{const\ postRecord\ =\ \{}
\DoxyCodeLine{\ \ \$type:\ 'app.bsky.feed.post',}
\DoxyCodeLine{\ \ text:\ rt.text,}
\DoxyCodeLine{\ \ facets:\ rt.facets,}
\DoxyCodeLine{\ \ createdAt:\ new\ Date().toISOString(),}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ rendering\ as\ markdown}
\DoxyCodeLine{let\ markdown\ =\ ''}
\DoxyCodeLine{for\ (const\ segment\ of\ rt.segments())\ \{}
\DoxyCodeLine{\ \ if\ (segment.isLink())\ \{}
\DoxyCodeLine{\ \ \ \ markdown\ +=\ \`{}[\$\{segment.text\}](\$\{segment.link?.uri\})`}
\DoxyCodeLine{\ \ \}\ else\ if\ (segment.isMention())\ \{}
\DoxyCodeLine{\ \ \ \ markdown\ +=\ \`{}[\$\{segment.text\}](https://my-\/bsky-\/app.com/user/\$\{segment.mention?.did\})`}
\DoxyCodeLine{\ \ \}\ else\ \{}
\DoxyCodeLine{\ \ \ \ markdown\ +=\ segment.text}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ calculating\ string\ lengths}
\DoxyCodeLine{const\ rt2\ =\ new\ RichText(\{\ text:\ 'Hello'\ \})}
\DoxyCodeLine{console.log(rt2.length)\ //\ =>\ 5}
\DoxyCodeLine{console.log(rt2.graphemeLength)\ //\ =>\ 5}
\DoxyCodeLine{const\ rt3\ =\ new\ RichText(\{\ text:\ 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘§'\ \})}
\DoxyCodeLine{console.log(rt3.length)\ //\ =>\ 25}
\DoxyCodeLine{console.log(rt3.graphemeLength)\ //\ =>\ 1}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1970}{}\doxysubsubsection{\texorpdfstring{Moderation}{Moderation}}\label{README.md_autotoc_md1970}
Applying the moderation system is a challenging task, but we\textquotesingle{}ve done our best to simplify it for you. The Moderation API helps handle a wide range of tasks, including\+:


\begin{DoxyItemize}
\item Moderator labeling
\item User muting (including mutelists)
\item User blocking
\item Mutewords
\item Hidden posts
\end{DoxyItemize}

For more information, see the \doxysectlink{md_node__modules_2_0datproto_2api_2docs_2moderation}{Moderation Documentation}{0}.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ moderatePost\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ First\ get\ the\ user's\ moderation\ prefs\ and\ their\ label\ definitions}
\DoxyCodeLine{//\ =}
\DoxyCodeLine{}
\DoxyCodeLine{const\ prefs\ =\ await\ agent.getPreferences()}
\DoxyCodeLine{const\ labelDefs\ =\ await\ agent.getLabelDefinitions(prefs)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ We\ call\ the\ appropriate\ moderation\ function\ for\ the\ content}
\DoxyCodeLine{//\ =}
\DoxyCodeLine{}
\DoxyCodeLine{const\ postMod\ =\ moderatePost(postView,\ \{}
\DoxyCodeLine{\ \ userDid:\ agent.session.did,}
\DoxyCodeLine{\ \ moderationPrefs:\ prefs.moderationPrefs,}
\DoxyCodeLine{\ \ labelDefs,}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ We\ then\ use\ the\ output\ to\ decide\ how\ to\ affect\ rendering}
\DoxyCodeLine{//\ =}
\DoxyCodeLine{}
\DoxyCodeLine{//\ in\ feeds}
\DoxyCodeLine{if\ (postMod.ui('contentList').filter)\ \{}
\DoxyCodeLine{\ \ //\ don't\ include\ in\ feeds}
\DoxyCodeLine{\}}
\DoxyCodeLine{if\ (postMod.ui('contentList').blur)\ \{}
\DoxyCodeLine{\ \ //\ render\ the\ whole\ object\ behind\ a\ cover\ (use\ postMod.ui('contentList').blurs\ to\ explain)}
\DoxyCodeLine{\ \ if\ (postMod.ui('contentList').noOverride)\ \{}
\DoxyCodeLine{\ \ \ \ //\ do\ not\ allow\ the\ cover\ the\ be\ removed}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{if\ (postMod.ui('contentList').alert\ ||\ postMod.ui('contentList').inform)\ \{}
\DoxyCodeLine{\ \ //\ render\ warnings\ on\ the\ post}
\DoxyCodeLine{\ \ //\ find\ the\ warnings\ in\ postMod.ui('contentList').alerts\ and\ postMod.ui('contentList').informs}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ viewed\ directly}
\DoxyCodeLine{if\ (postMod.ui('contentView').filter)\ \{}
\DoxyCodeLine{\ \ //\ don't\ include\ in\ feeds}
\DoxyCodeLine{\}}
\DoxyCodeLine{if\ (postMod.ui('contentView').blur)\ \{}
\DoxyCodeLine{\ \ //\ render\ the\ whole\ object\ behind\ a\ cover\ (use\ postMod.ui('contentView').blurs\ to\ explain)}
\DoxyCodeLine{\ \ if\ (postMod.ui('contentView').noOverride)\ \{}
\DoxyCodeLine{\ \ \ \ //\ do\ not\ allow\ the\ cover\ the\ be\ removed}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{if\ (postMod.ui('contentView').alert\ ||\ postMod.ui('contentView').inform)\ \{}
\DoxyCodeLine{\ \ //\ render\ warnings\ on\ the\ post}
\DoxyCodeLine{\ \ //\ find\ the\ warnings\ in\ postMod.ui('contentView').alerts\ and\ postMod.ui('contentView').informs}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ post\ embeds\ in\ all\ contexts}
\DoxyCodeLine{if\ (postMod.ui('contentMedia').blur)\ \{}
\DoxyCodeLine{\ \ //\ render\ the\ whole\ object\ behind\ a\ cover\ (use\ postMod.ui('contentMedia').blurs\ to\ explain)}
\DoxyCodeLine{\ \ if\ (postMod.ui('contentMedia').noOverride)\ \{}
\DoxyCodeLine{\ \ \ \ //\ do\ not\ allow\ the\ cover\ the\ be\ removed}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1971}{}\doxysubsection{\texorpdfstring{Advanced}{Advanced}}\label{README.md_autotoc_md1971}
\hypertarget{README.md_autotoc_md1972}{}\doxysubsubsection{\texorpdfstring{Advanced API calls}{Advanced API calls}}\label{README.md_autotoc_md1972}
The methods above are convenience wrappers. It covers most but not all available methods.

The AT Protocol identifies methods and records with reverse-\/\+DNS names. You can use them on the agent as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ res1\ =\ await\ agent.com.atproto.repo.createRecord(\{}
\DoxyCodeLine{\ \ did:\ alice.did,}
\DoxyCodeLine{\ \ collection:\ 'app.bsky.feed.post',}
\DoxyCodeLine{\ \ record:\ \{}
\DoxyCodeLine{\ \ \ \ \$type:\ 'app.bsky.feed.post',}
\DoxyCodeLine{\ \ \ \ text:\ 'Hello,\ world!',}
\DoxyCodeLine{\ \ \ \ createdAt:\ new\ Date().toISOString(),}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})}
\DoxyCodeLine{const\ res2\ =\ await\ agent.com.atproto.repo.listRecords(\{}
\DoxyCodeLine{\ \ repo:\ alice.did,}
\DoxyCodeLine{\ \ collection:\ 'app.bsky.feed.post',}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{const\ res3\ =\ await\ agent.app.bsky.feed.post.create(}
\DoxyCodeLine{\ \ \{\ repo:\ alice.did\ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ text:\ 'Hello,\ world!',}
\DoxyCodeLine{\ \ \ \ createdAt:\ new\ Date().toISOString(),}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{)}
\DoxyCodeLine{const\ res4\ =\ await\ agent.app.bsky.feed.post.list(\{\ repo:\ alice.did\ \})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1973}{}\doxysubsubsection{\texorpdfstring{Non-\/browser configuration}{Non-\/browser configuration}}\label{README.md_autotoc_md1973}
If your environment doesn\textquotesingle{}t have a built-\/in {\ttfamily fetch} implementation, you\textquotesingle{}ll need to provide one. This will typically be done through a polyfill.\hypertarget{README.md_autotoc_md1974}{}\doxysubsubsection{\texorpdfstring{Bring your own fetch}{Bring your own fetch}}\label{README.md_autotoc_md1974}
If you want to provide your own {\ttfamily fetch} implementation, you can do so by instantiating the session\+Manager with a custom fetch implementation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ AtpAgent\ \}\ from\ '@atproto/api'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ myFetch\ =\ (input:\ RequestInfo\ |\ URL,\ init?:\ RequestInit)\ =>\ \{}
\DoxyCodeLine{\ \ console.log('requesting',\ input)}
\DoxyCodeLine{\ \ const\ response\ =\ await\ globalThis.fetch(input,\ init)}
\DoxyCodeLine{\ \ console.log('got\ response',\ response)}
\DoxyCodeLine{\ \ return\ response}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ agent\ =\ new\ AtpAgent(\{}
\DoxyCodeLine{\ \ service:\ 'https://example.com',}
\DoxyCodeLine{\ \ fetch:\ myFetch,}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md1975}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md1975}
This project is dual-\/licensed under MIT and Apache 2.\+0 terms\+:


\begin{DoxyItemize}
\item MIT license (\href{https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt}{\texttt{ LICENSE-\/\+MIT.\+txt}} or \href{http://opensource.org/licenses/MIT}{\texttt{ http\+://opensource.\+org/licenses/\+MIT}})
\item Apache License, Version 2.\+0, (\href{https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt}{\texttt{ LICENSE-\/\+APACHE.\+txt}} or \href{http://www.apache.org/licenses/LICENSE-2.0}{\texttt{ http\+://www.\+apache.\+org/licenses/\+LICENSE-\/2.\+0}})
\end{DoxyItemize}

Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-\/licensing is the additional software patent assurance provided by Apache 2.\+0. 