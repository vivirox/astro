\doxysection{node\+\_\+modules/expect-\/type Directory Reference}
\hypertarget{dir_78b3bc975489ee3495c8355d7e4ffc91}{}\label{dir_78b3bc975489ee3495c8355d7e4ffc91}\index{node\_modules/expect-\/type Directory Reference@{node\_modules/expect-\/type Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://github.com/mmkal/expect-type/actions/workflows/ci.yml}{\texttt{ }}  \href{https://x.com/mmkalmmkal}{\texttt{ }}

Compile-\/time tests for types. Useful to make sure types don\textquotesingle{}t regress into being overly permissive as changes go in over time.

Similar to {\ttfamily expect}, but with type-\/awareness. Gives you access to several type-\/matchers that let you make assertions about the form of a reference or generic type parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{expectTypeOf\}\ from\ 'expect-\/type'}
\DoxyCodeLine{import\ \{foo,\ bar\}\ from\ '../foo'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ sure\ \`{}foo`\ has\ type\ \{a:\ number\}}
\DoxyCodeLine{expectTypeOf(foo).toMatchTypeOf<\{a:\ number\}>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ make\ sure\ \`{}bar`\ is\ a\ function\ taking\ a\ string:}
\DoxyCodeLine{expectTypeOf(bar).parameter(0).toBeString()}
\DoxyCodeLine{expectTypeOf(bar).returns.not.toBeAny()}

\end{DoxyCode}


It can be used in your existing test files (and is actually \href{https://vitest.dev/guide/testing-types}{\texttt{ built in to vitest}}). Or it can be used in any other type-\/checked file you\textquotesingle{}d like -\/ it\textquotesingle{}s built into existing tooling with no dependencies. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time -\/ they\textquotesingle{}ll appear in your IDE and when you run {\ttfamily tsc}.

See below for lots more examples.\hypertarget{README.md_autotoc_md14862}{}\doxysubsection{\texorpdfstring{Contents}{Contents}}\label{README.md_autotoc_md14862}

\begin{DoxyItemize}
\item Contents
\item Installation and usage
\item \doxylink{README.md_documentation}{Documentation}
\begin{DoxyItemize}
\item \doxylink{md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g_features}{Features}
\item Why is my assertion failing?
\item Where is \`{}.to\+Match\+Type\+Of\`{}?
\item Internal type helpers
\item Error messages
\begin{DoxyItemize}
\item Concrete "{}expected"{} objects vs type arguments
\end{DoxyItemize}
\item Overloaded functions
\item Within test frameworks
\item Vitest
\begin{DoxyItemize}
\item Jest \& \`{}eslint-\/plugin-\/jest\`{}
\end{DoxyItemize}
\item Limitations
\end{DoxyItemize}
\item Similar projects
\begin{DoxyItemize}
\item Comparison
\end{DoxyItemize}
\item Type\+Script backwards-\/compatibility
\item \doxylink{md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g_contributing}{Contributing}
\begin{DoxyItemize}
\item Documentation of limitations through tests
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md14863}{}\doxysubsection{\texorpdfstring{Installation and usage}{Installation and usage}}\label{README.md_autotoc_md14863}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ expect-\/type\ -\/-\/save-\/dev}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{expectTypeOf\}\ from\ 'expect-\/type'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md14864}{}\doxysubsection{\texorpdfstring{Documentation}{Documentation}}\label{README.md_autotoc_md14864}
The {\ttfamily expect\+Type\+Of} method takes a single argument or a generic type parameter. Neither it nor the functions chained off its return value have any meaningful runtime behaviour. The assertions you write will be {\itshape compile-\/time} errors if they don\textquotesingle{}t hold true.\hypertarget{README.md_autotoc_md14865}{}\doxysubsubsection{\texorpdfstring{Features}{Features}}\label{README.md_autotoc_md14865}
Check an object\textquotesingle{}s type with {\ttfamily .to\+Equal\+Type\+Of}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf<\{a:\ number\}>()}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of} can check that two concrete objects have equivalent types (note\+: when these assertions {\itshape fail}, the error messages can be less informative vs the generic type argument syntax above -\/ see error messages docs)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf(\{a:\ 1\})}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of} succeeds for objects with different values, but the same type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf(\{a:\ 2\})}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of} fails on excess properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(\{a:\ 1,\ b:\ 1\}).toEqualTypeOf<\{a:\ number\}>()}

\end{DoxyCode}


To allow for extra properties on an object type, use {\ttfamily .to\+Match\+Object\+Type}. This is a strict check, but only on the subset of keys that are in the expected type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1,\ b:\ 1\}).toMatchObjectType<\{a:\ number\}>()}

\end{DoxyCode}


{\ttfamily .to\+Match\+Object\+Type} can check partial matches on deeply nested objects\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ \{}
\DoxyCodeLine{\ \ email:\ 'a@b.com',}
\DoxyCodeLine{\ \ name:\ 'John\ Doe',}
\DoxyCodeLine{\ \ address:\ \{street:\ '123\ 2nd\ St',\ city:\ 'New\ York',\ zip:\ '10001',\ state:\ 'NY',\ country:\ 'USA'\},}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(user).toMatchObjectType<\{name:\ string;\ address:\ \{city:\ string\}\}>()}

\end{DoxyCode}


To check that a type extends another type, use {\ttfamily .to\+Extend}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf('some\ string').toExtend<string\ |\ boolean>()}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toExtend<\{b:\ number\}>()}

\end{DoxyCode}


{\ttfamily .to\+Extend} can be used with object types, but {\ttfamily .to\+Match\+Object\+Type} is usually a better choice when dealing with objects, since it\textquotesingle{}s stricter\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1,\ b:\ 2\}).toExtend<\{a:\ number\}>()\ //\ avoid\ this}
\DoxyCodeLine{expectTypeOf(\{a:\ 1,\ b:\ 2\}).toMatchObjectType<\{a:\ number\}>()\ //\ prefer\ this}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of}, {\ttfamily .to\+Match\+Object\+Type}, and {\ttfamily .to\+Extend} all fail on missing properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf<\{a:\ number;\ b:\ number\}>()}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toMatchObjectType<\{a:\ number;\ b:\ number\}>()}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toExtend<\{a:\ number;\ b:\ number\}>()}

\end{DoxyCode}


Another example of the difference between {\ttfamily .to\+Extend}, {\ttfamily .to\+Match\+Object\+Type}, and {\ttfamily .to\+Equal\+Type\+Of}. {\ttfamily .to\+Extend} can be used for "{}is-\/a"{} relationships\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Fruit\ =\ \{type:\ 'Fruit';\ edible:\ boolean\}}
\DoxyCodeLine{type\ Apple\ =\ \{type:\ 'Fruit';\ name:\ 'Apple';\ edible:\ true\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Apple>().toExtend<Fruit>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ -\/\ the\ \`{}editable`\ property\ isn't\ an\ exact\ match.\ In\ \`{}Apple`,\ it's\ \`{}true`,\ which\ extends\ \`{}boolean`,\ but\ they're\ not\ identical.}
\DoxyCodeLine{expectTypeOf<Apple>().toMatchObjectType<Fruit>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ -\/\ Apple\ is\ not\ an\ identical\ type\ to\ Fruit,\ it's\ a\ subtype}
\DoxyCodeLine{expectTypeOf<Apple>().toEqualTypeOf<Fruit>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ -\/\ Apple\ is\ a\ Fruit,\ but\ not\ vice\ versa}
\DoxyCodeLine{expectTypeOf<Fruit>().toExtend<Apple>()}

\end{DoxyCode}


Assertions can be inverted with {\ttfamily .not}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).not.toExtend<\{b:\ 1\}>()}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).not.toMatchObjectType<\{b:\ 1\}>()}

\end{DoxyCode}


{\ttfamily .not} can be easier than relying on {\ttfamily // @ts-\/expect-\/error}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Fruit\ =\ \{type:\ 'Fruit';\ edible:\ boolean\}}
\DoxyCodeLine{type\ Apple\ =\ \{type:\ 'Fruit';\ name:\ 'Apple';\ edible:\ true\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Apple>().toExtend<Fruit>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Fruit>().not.toExtend<Apple>()}
\DoxyCodeLine{expectTypeOf<Apple>().not.toEqualTypeOf<Fruit>()}

\end{DoxyCode}


Catch any/unknown/never types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<unknown>().toBeUnknown()}
\DoxyCodeLine{expectTypeOf<any>().toBeAny()}
\DoxyCodeLine{expectTypeOf<never>().toBeNever()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf<never>().toBeNumber()}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of} distinguishes between deeply-\/nested {\ttfamily any} and {\ttfamily unknown} properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<\{deeply:\ \{nested:\ any\}\}>().not.toEqualTypeOf<\{deeply:\ \{nested:\ unknown\}\}>()}

\end{DoxyCode}


You can test for basic Java\+Script types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(()\ =>\ 1).toBeFunction()}
\DoxyCodeLine{expectTypeOf(\{\}).toBeObject()}
\DoxyCodeLine{expectTypeOf([]).toBeArray()}
\DoxyCodeLine{expectTypeOf('').toBeString()}
\DoxyCodeLine{expectTypeOf(1).toBeNumber()}
\DoxyCodeLine{expectTypeOf(true).toBeBoolean()}
\DoxyCodeLine{expectTypeOf(()\ =>\ \{\}).returns.toBeVoid()}
\DoxyCodeLine{expectTypeOf(Promise.resolve(123)).resolves.toBeNumber()}
\DoxyCodeLine{expectTypeOf(Symbol(1)).toBeSymbol()}
\DoxyCodeLine{expectTypeOf(1n).toBeBigInt()}

\end{DoxyCode}


{\ttfamily .to\+Be...} methods allow for types that extend the expected type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<number>().toBeNumber()}
\DoxyCodeLine{expectTypeOf<1>().toBeNumber()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<any[]>().toBeArray()}
\DoxyCodeLine{expectTypeOf<number[]>().toBeArray()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<string>().toBeString()}
\DoxyCodeLine{expectTypeOf<'foo'>().toBeString()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<boolean>().toBeBoolean()}
\DoxyCodeLine{expectTypeOf<true>().toBeBoolean()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<bigint>().toBeBigInt()}
\DoxyCodeLine{expectTypeOf<0n>().toBeBigInt()}

\end{DoxyCode}


{\ttfamily .to\+Be...} methods protect against {\ttfamily any}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ goodIntParser\ =\ (s:\ string)\ =>\ Number.parseInt(s,\ 10)}
\DoxyCodeLine{const\ badIntParser\ =\ (s:\ string)\ =>\ JSON.parse(s)\ //\ uh-\/oh\ -\/\ works\ at\ runtime\ if\ the\ input\ is\ a\ number,\ but\ return\ 'any'}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(goodIntParser).returns.toBeNumber()}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ -\/\ if\ you\ write\ a\ test\ like\ this,\ \`{}.toBeNumber()`\ will\ let\ you\ know\ your\ implementation\ returns\ \`{}any`.}
\DoxyCodeLine{expectTypeOf(badIntParser).returns.toBeNumber()}

\end{DoxyCode}


Nullable types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(undefined).toBeUndefined()}
\DoxyCodeLine{expectTypeOf(undefined).toBeNullable()}
\DoxyCodeLine{expectTypeOf(undefined).not.toBeNull()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(null).toBeNull()}
\DoxyCodeLine{expectTypeOf(null).toBeNullable()}
\DoxyCodeLine{expectTypeOf(null).not.toBeUndefined()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<1\ |\ undefined>().toBeNullable()}
\DoxyCodeLine{expectTypeOf<1\ |\ null>().toBeNullable()}
\DoxyCodeLine{expectTypeOf<1\ |\ undefined\ |\ null>().toBeNullable()}

\end{DoxyCode}


More {\ttfamily .not} examples\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(1).not.toBeUnknown()}
\DoxyCodeLine{expectTypeOf(1).not.toBeAny()}
\DoxyCodeLine{expectTypeOf(1).not.toBeNever()}
\DoxyCodeLine{expectTypeOf(1).not.toBeNull()}
\DoxyCodeLine{expectTypeOf(1).not.toBeUndefined()}
\DoxyCodeLine{expectTypeOf(1).not.toBeNullable()}
\DoxyCodeLine{expectTypeOf(1).not.toBeBigInt()}

\end{DoxyCode}


Detect assignability of unioned types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<number>().toExtend<string\ |\ number>()}
\DoxyCodeLine{expectTypeOf<string\ |\ number>().not.toExtend<number>()}

\end{DoxyCode}


Use {\ttfamily .extract} and {\ttfamily .exclude} to narrow down complex union types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ ResponsiveProp<T>\ =\ T\ |\ T[]\ |\ \{xs?:\ T;\ sm?:\ T;\ md?:\ T\}}
\DoxyCodeLine{const\ getResponsiveProp\ =\ <T>(\_props:\ T):\ ResponsiveProp<T>\ =>\ (\{\})}
\DoxyCodeLine{type\ CSSProperties\ =\ \{margin?:\ string;\ padding?:\ string\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ cssProperties:\ CSSProperties\ =\ \{margin:\ '1px',\ padding:\ '2px'\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(getResponsiveProp(cssProperties))}
\DoxyCodeLine{\ \ .exclude<unknown[]>()}
\DoxyCodeLine{\ \ .exclude<\{xs?:\ unknown\}>()}
\DoxyCodeLine{\ \ .toEqualTypeOf<CSSProperties>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(getResponsiveProp(cssProperties))}
\DoxyCodeLine{\ \ .extract<unknown[]>()}
\DoxyCodeLine{\ \ .toEqualTypeOf<CSSProperties[]>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(getResponsiveProp(cssProperties))}
\DoxyCodeLine{\ \ .extract<\{xs?:\ any\}>()}
\DoxyCodeLine{\ \ .toEqualTypeOf<\{xs?:\ CSSProperties;\ sm?:\ CSSProperties;\ md?:\ CSSProperties\}>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<ResponsiveProp<number>>().exclude<number\ |\ number[]>().toHaveProperty('sm')}
\DoxyCodeLine{expectTypeOf<ResponsiveProp<number>>().exclude<number\ |\ number[]>().not.toHaveProperty('xxl')}

\end{DoxyCode}


{\ttfamily .extract} and {\ttfamily .exclude} return never if no types remain after exclusion\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Person\ =\ \{name:\ string;\ age:\ number\}}
\DoxyCodeLine{type\ Customer\ =\ Person\ \&\ \{customerId:\ string\}}
\DoxyCodeLine{type\ Employee\ =\ Person\ \&\ \{employeeId:\ string\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Customer\ |\ Employee>().extract<\{foo:\ string\}>().toBeNever()}
\DoxyCodeLine{expectTypeOf<Customer\ |\ Employee>().exclude<\{name:\ string\}>().toBeNever()}

\end{DoxyCode}


Use {\ttfamily .pick} to pick a set of properties from an object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Person\ =\ \{name:\ string;\ age:\ number\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Person>().pick<'name'>().toEqualTypeOf<\{name:\ string\}>()}

\end{DoxyCode}


Use {\ttfamily .omit} to remove a set of properties from an object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Person\ =\ \{name:\ string;\ age:\ number\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Person>().omit<'name'>().toEqualTypeOf<\{age:\ number\}>()}

\end{DoxyCode}


Make assertions about object properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ obj\ =\ \{a:\ 1,\ b:\ ''\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ check\ that\ properties\ exist\ (or\ don't)\ with\ \`{}.toHaveProperty`}
\DoxyCodeLine{expectTypeOf(obj).toHaveProperty('a')}
\DoxyCodeLine{expectTypeOf(obj).not.toHaveProperty('c')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ check\ types\ of\ properties}
\DoxyCodeLine{expectTypeOf(obj).toHaveProperty('a').toBeNumber()}
\DoxyCodeLine{expectTypeOf(obj).toHaveProperty('b').toBeString()}
\DoxyCodeLine{expectTypeOf(obj).toHaveProperty('a').not.toBeString()}

\end{DoxyCode}


{\ttfamily .to\+Equal\+Type\+Of} can be used to distinguish between functions\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ NoParam\ =\ ()\ =>\ void}
\DoxyCodeLine{type\ HasParam\ =\ (s:\ string)\ =>\ void}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<NoParam>().not.toEqualTypeOf<HasParam>()}

\end{DoxyCode}


But often it\textquotesingle{}s preferable to use {\ttfamily .parameters} or {\ttfamily .returns} for more specific function assertions\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ NoParam\ =\ ()\ =>\ void}
\DoxyCodeLine{type\ HasParam\ =\ (s:\ string)\ =>\ void}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()}
\DoxyCodeLine{expectTypeOf<NoParam>().returns.toBeVoid()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()}
\DoxyCodeLine{expectTypeOf<HasParam>().returns.toBeVoid()}

\end{DoxyCode}


Up to ten overloads will produce union types for {\ttfamily .parameters} and {\ttfamily .returns}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Factorize\ =\ \{}
\DoxyCodeLine{\ \ (input:\ number):\ number[]}
\DoxyCodeLine{\ \ (input:\ bigint):\ bigint[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Factorize>().parameters.not.toEqualTypeOf<[number]>()}
\DoxyCodeLine{expectTypeOf<Factorize>().parameters.toEqualTypeOf<[number]\ |\ [bigint]>()}
\DoxyCodeLine{expectTypeOf<Factorize>().returns.toEqualTypeOf<number[]\ |\ bigint[]>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Factorize>().parameter(0).toEqualTypeOf<number\ |\ bigint>()}

\end{DoxyCode}


Note that these aren\textquotesingle{}t exactly like Type\+Script\textquotesingle{}s built-\/in Parameters$<$...$>$ and Return\+Type$<$...$>$\+:

The Type\+Script builtins simply choose a single overload (see the Overloaded functions section for more information)


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Factorize\ =\ \{}
\DoxyCodeLine{\ \ (input:\ number):\ number[]}
\DoxyCodeLine{\ \ (input:\ bigint):\ bigint[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ overload\ using\ \`{}number`\ is\ ignored!}
\DoxyCodeLine{expectTypeOf<Parameters<Factorize>>().toEqualTypeOf<[bigint]>()}
\DoxyCodeLine{expectTypeOf<ReturnType<Factorize>>().toEqualTypeOf<bigint[]>()}

\end{DoxyCode}


More examples of ways to work with functions -\/ parameters using {\ttfamily .parameter(n)} or {\ttfamily .parameters}, and return values using {\ttfamily .returns}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ f\ =\ (a:\ number)\ =>\ [a,\ a]}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(f).toBeFunction()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(f).toBeCallableWith(1)}
\DoxyCodeLine{expectTypeOf(f).not.toBeAny()}
\DoxyCodeLine{expectTypeOf(f).returns.not.toBeAny()}
\DoxyCodeLine{expectTypeOf(f).returns.toEqualTypeOf([1,\ 2])}
\DoxyCodeLine{expectTypeOf(f).returns.toEqualTypeOf([1,\ 2,\ 3])}
\DoxyCodeLine{expectTypeOf(f).parameter(0).not.toEqualTypeOf('1')}
\DoxyCodeLine{expectTypeOf(f).parameter(0).toEqualTypeOf(1)}
\DoxyCodeLine{expectTypeOf(1).parameter(0).toBeNever()}
\DoxyCodeLine{}
\DoxyCodeLine{const\ twoArgFunc\ =\ (a:\ number,\ b:\ string)\ =>\ (\{a,\ b\})}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(twoArgFunc).parameters.toEqualTypeOf<[number,\ string]>()}

\end{DoxyCode}


{\ttfamily .to\+Be\+Callable\+With} allows for overloads. You can also use it to narrow down the return type for given input parameters.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Factorize\ =\ \{}
\DoxyCodeLine{\ \ (input:\ number):\ number[]}
\DoxyCodeLine{\ \ (input:\ bigint):\ bigint[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Factorize>().toBeCallableWith(6)}
\DoxyCodeLine{expectTypeOf<Factorize>().toBeCallableWith(6n)}

\end{DoxyCode}


{\ttfamily .to\+Be\+Callable\+With} returns a type that can be used to narrow down the return type for given input parameters.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Factorize\ =\ \{}
\DoxyCodeLine{\ \ (input:\ number):\ number[]}
\DoxyCodeLine{\ \ (input:\ bigint):\ bigint[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{expectTypeOf<Factorize>().toBeCallableWith(6).returns.toEqualTypeOf<number[]>()}
\DoxyCodeLine{expectTypeOf<Factorize>().toBeCallableWith(6n).returns.toEqualTypeOf<bigint[]>()}

\end{DoxyCode}


{\ttfamily .to\+Be\+Callable\+With} can be used to narrow down the parameters of a function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Delete\ =\ \{}
\DoxyCodeLine{\ \ (path:\ string):\ void}
\DoxyCodeLine{\ \ (paths:\ string[],\ options?:\ \{force:\ boolean\}):\ void}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Delete>().toBeCallableWith('abc').parameters.toEqualTypeOf<[string]>()}
\DoxyCodeLine{expectTypeOf<Delete>()}
\DoxyCodeLine{\ \ .toBeCallableWith(['abc',\ 'def'],\ \{force:\ true\})}
\DoxyCodeLine{\ \ .parameters.toEqualTypeOf<[string[],\ \{force:\ boolean\}?]>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Delete>().toBeCallableWith('abc').parameter(0).toBeString()}
\DoxyCodeLine{expectTypeOf<Delete>().toBeCallableWith('abc').parameter(1).toBeUndefined()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Delete>()}
\DoxyCodeLine{\ \ .toBeCallableWith(['abc',\ 'def',\ 'ghi'])}
\DoxyCodeLine{\ \ .parameter(0)}
\DoxyCodeLine{\ \ .toEqualTypeOf<string[]>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Delete>()}
\DoxyCodeLine{\ \ .toBeCallableWith(['abc',\ 'def',\ 'ghi'])}
\DoxyCodeLine{\ \ .parameter(1)}
\DoxyCodeLine{\ \ .toEqualTypeOf<\{force:\ boolean\}\ |\ undefined>()}

\end{DoxyCode}


You can\textquotesingle{}t use {\ttfamily .to\+Be\+Callable\+With} with {\ttfamily .not} -\/ you need to use ts-\/expect-\/error\+::


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ f\ =\ (a:\ number)\ =>\ [a,\ a]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf(f).toBeCallableWith('foo')}

\end{DoxyCode}


Use {\ttfamily .map} to transform types\+:

This can be useful for generic functions or complex types which you can\textquotesingle{}t access via {\ttfamily .to\+Be\+Callable\+With}, {\ttfamily .to\+Have\+Property} etc. The callback function isn\textquotesingle{}t called at runtime, which can make this a useful way to get complex inferred types without worrying about running code.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ capitalize\ =\ <S\ extends\ string>(input:\ S)\ =>}
\DoxyCodeLine{\ \ (input.slice(0,\ 1).toUpperCase()\ +\ input.slice(1))\ as\ Capitalize<S>}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(capitalize)}
\DoxyCodeLine{\ \ .map(fn\ =>\ fn('hello\ world'))}
\DoxyCodeLine{\ \ .toEqualTypeOf<'Hello\ world'>()}

\end{DoxyCode}


You can also check type guards \& type assertions\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ assertNumber\ =\ (v:\ any):\ asserts\ v\ is\ number\ =>\ \{}
\DoxyCodeLine{\ \ if\ (typeof\ v\ !==\ 'number')\ \{}
\DoxyCodeLine{\ \ \ \ throw\ new\ TypeError('Nope\ !')}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(assertNumber).asserts.toBeNumber()}
\DoxyCodeLine{}
\DoxyCodeLine{const\ isString\ =\ (v:\ any):\ v\ is\ string\ =>\ typeof\ v\ ===\ 'string'}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(isString).guards.toBeString()}
\DoxyCodeLine{}
\DoxyCodeLine{const\ isBigInt\ =\ (value:\ any):\ value\ is\ bigint\ =>\ typeof\ value\ ===\ 'bigint'}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(isBigInt).guards.toBeBigInt()}

\end{DoxyCode}


Assert on constructor parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(Date).toBeConstructibleWith('1970')}
\DoxyCodeLine{expectTypeOf(Date).toBeConstructibleWith(0)}
\DoxyCodeLine{expectTypeOf(Date).toBeConstructibleWith(new\ Date())}
\DoxyCodeLine{expectTypeOf(Date).toBeConstructibleWith()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(Date).constructorParameters.toEqualTypeOf<}
\DoxyCodeLine{\ \ |\ []}
\DoxyCodeLine{\ \ |\ [value:\ string\ |\ number]}
\DoxyCodeLine{\ \ |\ [value:\ string\ |\ number\ |\ Date]}
\DoxyCodeLine{\ \ |\ [}
\DoxyCodeLine{\ \ \ \ \ \ year:\ number,}
\DoxyCodeLine{\ \ \ \ \ \ monthIndex:\ number,}
\DoxyCodeLine{\ \ \ \ \ \ date?:\ number\ |\ undefined,}
\DoxyCodeLine{\ \ \ \ \ \ hours?:\ number\ |\ undefined,}
\DoxyCodeLine{\ \ \ \ \ \ minutes?:\ number\ |\ undefined,}
\DoxyCodeLine{\ \ \ \ \ \ seconds?:\ number\ |\ undefined,}
\DoxyCodeLine{\ \ \ \ \ \ ms?:\ number\ |\ undefined,}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{>()}

\end{DoxyCode}


Constructor overloads\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ DBConnection\ \{}
\DoxyCodeLine{\ \ constructor()}
\DoxyCodeLine{\ \ constructor(connectionString:\ string)}
\DoxyCodeLine{\ \ constructor(options:\ \{host:\ string;\ port:\ number\})}
\DoxyCodeLine{\ \ constructor(...\_:\ unknown[])\ \{\}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(DBConnection).toBeConstructibleWith()}
\DoxyCodeLine{expectTypeOf(DBConnection).toBeConstructibleWith('localhost')}
\DoxyCodeLine{expectTypeOf(DBConnection).toBeConstructibleWith(\{host:\ 'localhost',\ port:\ 1234\})}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ -\/\ as\ when\ calling\ \`{}new\ DBConnection(...)`\ you\ can't\ actually\ use\ the\ \`{}(...args:\ unknown[])`\ overlaod,\ it's\ purely\ for\ the\ implementation.}
\DoxyCodeLine{expectTypeOf(DBConnection).toBeConstructibleWith(1,\ 2)}

\end{DoxyCode}


Check function {\ttfamily this} parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ greet(this:\ \{name:\ string\},\ message:\ string)\ \{}
\DoxyCodeLine{\ \ return\ \`{}Hello\ \$\{this.name\},\ here's\ your\ message:\ \$\{message\}`}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(greet).thisParameter.toEqualTypeOf<\{name:\ string\}>()}

\end{DoxyCode}


Distinguish between functions with different {\ttfamily this} parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ greetFormal(this:\ \{title:\ string;\ name:\ string\},\ message:\ string)\ \{}
\DoxyCodeLine{\ \ return\ \`{}Dear\ \$\{this.title\}\ \$\{this.name\},\ here's\ your\ message:\ \$\{message\}`}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{function\ greetCasual(this:\ \{name:\ string\},\ message:\ string)\ \{}
\DoxyCodeLine{\ \ return\ \`{}Hi\ \$\{this.name\},\ here's\ your\ message:\ \$\{message\}`}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(greetFormal).not.toEqualTypeOf(greetCasual)}

\end{DoxyCode}


Class instance types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(Date).instance.toHaveProperty('toISOString')}

\end{DoxyCode}


Promise resolution types can be checked with {\ttfamily .resolves}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ asyncFunc\ =\ async\ ()\ =>\ 123}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(asyncFunc).returns.resolves.toBeNumber()}

\end{DoxyCode}


Array items can be checked with {\ttfamily .items}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf([1,\ 2,\ 3]).items.toBeNumber()}
\DoxyCodeLine{expectTypeOf([1,\ 2,\ 3]).items.not.toBeString()}

\end{DoxyCode}


You can also compare arrays directly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<any[]>().not.toEqualTypeOf<number[]>()}

\end{DoxyCode}


Check that functions never return\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ thrower\ =\ ()\ =>\ \{}
\DoxyCodeLine{\ \ throw\ new\ Error('oh\ no')}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(thrower).returns.toBeNever()}

\end{DoxyCode}


Generics can be used rather than references\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<\{a:\ string\}>().not.toEqualTypeOf<\{a:\ number\}>()}

\end{DoxyCode}


Distinguish between missing/null/optional properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf<\{a?:\ number\}>().not.toEqualTypeOf<\{\}>()}
\DoxyCodeLine{expectTypeOf<\{a?:\ number\}>().not.toEqualTypeOf<\{a:\ number\}>()}
\DoxyCodeLine{expectTypeOf<\{a?:\ number\}>().not.toEqualTypeOf<\{a:\ number\ |\ undefined\}>()}
\DoxyCodeLine{expectTypeOf<\{a?:\ number\ |\ null\}>().not.toEqualTypeOf<\{a:\ number\ |\ null\}>()}
\DoxyCodeLine{expectTypeOf<\{a:\ \{b?:\ number\}\}>().not.toEqualTypeOf<\{a:\ \{\}\}>()}

\end{DoxyCode}


Detect the difference between regular and {\ttfamily readonly} properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ A1\ =\ \{readonly\ a:\ string;\ b:\ string\}}
\DoxyCodeLine{type\ E1\ =\ \{a:\ string;\ b:\ string\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<A1>().toExtend<E1>()}
\DoxyCodeLine{expectTypeOf<A1>().not.toEqualTypeOf<E1>()}
\DoxyCodeLine{}
\DoxyCodeLine{type\ A2\ =\ \{a:\ string;\ b:\ \{readonly\ c:\ string\}\}}
\DoxyCodeLine{type\ E2\ =\ \{a:\ string;\ b:\ \{c:\ string\}\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<A2>().toExtend<E2>()}
\DoxyCodeLine{expectTypeOf<A2>().not.toEqualTypeOf<E2>()}

\end{DoxyCode}


Distinguish between classes with different constructors\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ A\ \{}
\DoxyCodeLine{\ \ value:\ number}
\DoxyCodeLine{\ \ constructor(a:\ 1)\ \{}
\DoxyCodeLine{\ \ \ \ this.value\ =\ a}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{class\ B\ \{}
\DoxyCodeLine{\ \ value:\ number}
\DoxyCodeLine{\ \ constructor(b:\ 2)\ \{}
\DoxyCodeLine{\ \ \ \ this.value\ =\ b}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<typeof\ A>().not.toEqualTypeOf<typeof\ B>()}
\DoxyCodeLine{}
\DoxyCodeLine{class\ C\ \{}
\DoxyCodeLine{\ \ value:\ number}
\DoxyCodeLine{\ \ constructor(c:\ 1)\ \{}
\DoxyCodeLine{\ \ \ \ this.value\ =\ c}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<typeof\ A>().toEqualTypeOf<typeof\ C>()}

\end{DoxyCode}


Known limitation\+: Intersection types can cause issues with {\ttfamily to\+Equal\+Type\+Of}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ the\ following\ line\ doesn't\ compile,\ even\ though\ the\ types\ are\ arguably\ the\ same.}
\DoxyCodeLine{//\ See\ https://github.com/mmkal/expect-\/type/pull/21}
\DoxyCodeLine{expectTypeOf<\{a:\ 1\}\ \&\ \{b:\ 2\}>().toEqualTypeOf<\{a:\ 1;\ b:\ 2\}>()}

\end{DoxyCode}


To workaround for simple cases, you can use a mapped type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Simplify<T>\ =\ \{[K\ in\ keyof\ T]:\ T[K]\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Simplify<\{a:\ 1\}\ \&\ \{b:\ 2\}>>().toEqualTypeOf<\{a:\ 1;\ b:\ 2\}>()}

\end{DoxyCode}


But this won\textquotesingle{}t work if the nesting is deeper in the type. For these situations, you can use the {\ttfamily .branded} helper. Note that this comes at a performance cost, and can cause the compiler to \textquotesingle{}give up\textquotesingle{} if used with excessively deep types, so use sparingly. This helper is under {\ttfamily .branded} because it deeply transforms the Actual and Expected types into a pseudo-\/\+AST\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error}
\DoxyCodeLine{expectTypeOf<\{a:\ \{b:\ 1\}\ \&\ \{c:\ 1\}\}>().toEqualTypeOf<\{a:\ \{b:\ 1;\ c:\ 1\}\}>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<\{a:\ \{b:\ 1\}\ \&\ \{c:\ 1\}\}>().branded.toEqualTypeOf<\{a:\ \{b:\ 1;\ c:\ 1\}\}>()}

\end{DoxyCode}


Be careful with {\ttfamily .branded} for very deep or complex types, though. If possible you should find a way to simplify your test to avoid needing to use it\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ This\ *should*\ result\ in\ an\ error,\ but\ the\ "{}branding"{}\ mechanism\ produces\ too\ large\ a\ type\ and\ TypeScript\ just\ gives\ up!\ https://github.com/microsoft/TypeScript/issues/50670}
\DoxyCodeLine{expectTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ 1>().branded.toEqualTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ 2>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ the\ non-\/branded\ implementation\ catches\ the\ error\ as\ expected.}
\DoxyCodeLine{expectTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ 1>().toEqualTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ 2>()}

\end{DoxyCode}


So, if you have an extremely deep type that ALSO has an intersection in it, you\textquotesingle{}re out of luck and this library won\textquotesingle{}t be able to test your type properly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ this\ fails,\ but\ it\ should\ succeed.}
\DoxyCodeLine{expectTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ \{a:\ 1\}\ \&\ \{b:\ 2\}>().toEqualTypeOf<}
\DoxyCodeLine{\ \ ()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ \{a:\ 1;\ b:\ 2\}}
\DoxyCodeLine{>()}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ succeeds,\ but\ it\ should\ fail.}
\DoxyCodeLine{expectTypeOf<()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ \{a:\ 1\}\ \&\ \{b:\ 2\}>().branded.toEqualTypeOf<}
\DoxyCodeLine{\ \ ()\ =>\ ()\ =>\ ()\ =>\ ()\ =>\ \{a:\ 1;\ c:\ 2\}}
\DoxyCodeLine{>()}

\end{DoxyCode}


Another limitation\+: passing {\ttfamily this} references to {\ttfamily expect\+Type\+Of} results in errors.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ B\ \{}
\DoxyCodeLine{\ \ b\ =\ 'b'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ foo()\ \{}
\DoxyCodeLine{\ \ \ \ //\ @ts-\/expect-\/error}
\DoxyCodeLine{\ \ \ \ expectTypeOf(this).toEqualTypeOf(this)}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instead\ of\ the\ above,\ try\ something\ like\ this:}
\DoxyCodeLine{expectTypeOf(B).instance.toEqualTypeOf<\{b:\ string;\ foo:\ ()\ =>\ void\}>()}

\end{DoxyCode}


Overloads limitation for Type\+Script \texorpdfstring{$<$}{<}5.\+3\+: Due to a \href{https://github.com/microsoft/TypeScript/issues/28867}{\texttt{ Type\+Script bug fixed in 5.\+3}}, overloaded functions which include an overload resembling {\ttfamily (...args\+: unknown\mbox{[}\mbox{]}) =\texorpdfstring{$>$}{>} unknown} will exclude {\ttfamily unknown\mbox{[}\mbox{]}} from {\ttfamily .parameters} and exclude {\ttfamily unknown} from {\ttfamily .returns}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Factorize\ =\ \{}
\DoxyCodeLine{\ \ (...args:\ unknown[]):\ unknown}
\DoxyCodeLine{\ \ (input:\ number):\ number[]}
\DoxyCodeLine{\ \ (input:\ bigint):\ bigint[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<Factorize>().parameters.toEqualTypeOf<[number]\ |\ [bigint]>()}
\DoxyCodeLine{expectTypeOf<Factorize>().returns.toEqualTypeOf<number[]\ |\ bigint[]>()}

\end{DoxyCode}


This overload, however, allows any input and returns an unknown output anyway, so it\textquotesingle{}s not very useful. If you are worried about this for some reason, you\textquotesingle{}ll have to update Type\+Script to 5.\+3+.\hypertarget{README.md_autotoc_md14866}{}\doxysubsubsection{\texorpdfstring{Why is my assertion failing?}{Why is my assertion failing?}}\label{README.md_autotoc_md14866}
For complex types, an assertion might fail when it should if the {\ttfamily Actual} type contains a deeply-\/nested intersection type but the {\ttfamily Expected} doesn\textquotesingle{}t. In these cases you can use {\ttfamily .branded} as described above\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ @ts-\/expect-\/error\ this\ unfortunately\ fails\ -\/\ a\ TypeScript\ limitation\ prevents\ making\ this\ pass\ without\ a\ big\ perf\ hit}
\DoxyCodeLine{expectTypeOf<\{a:\ \{b:\ 1\}\ \&\ \{c:\ 1\}\}>().toEqualTypeOf<\{a:\ \{b:\ 1;\ c:\ 1\}\}>()}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf<\{a:\ \{b:\ 1\}\ \&\ \{c:\ 1\}\}>().branded.toEqualTypeOf<\{a:\ \{b:\ 1;\ c:\ 1\}\}>()}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md14867}{}\doxysubsubsection{\texorpdfstring{Where is {\ttfamily .to\+Match\+Type\+Of}?}{Where is {\ttfamily .to\+Match\+Type\+Of}?}}\label{README.md_autotoc_md14867}
The {\ttfamily .to\+Match\+Type\+Of} method is deprecated, in favour of {\ttfamily .to\+Match\+Object\+Type} (when strictly checking against an object type with a subset of keys), or {\ttfamily .to\+Extend} (when checking for "{}is-\/a"{} relationships). There are no foreseeable plans to remove {\ttfamily .to\+Match\+Type\+Of}, but there\textquotesingle{}s no reason to continue using it -\/ {\ttfamily .to\+Match\+Object\+Type} is stricter, and {\ttfamily .to\+Extend} is identical.\hypertarget{README.md_autotoc_md14868}{}\doxysubsubsection{\texorpdfstring{Internal type helpers}{Internal type helpers}}\label{README.md_autotoc_md14868}
ðŸš§ This library also exports some helper types for performing boolean operations on types, checking extension/equality in various ways, branding types, and checking for various special types like {\ttfamily never}, {\ttfamily any}, {\ttfamily unknown}. Use at your own risk! Nothing is stopping you from using these beyond this warning\+:

\texorpdfstring{$>$}{>}All internal types that are not documented here are {\itshape not} part of the supported API surface, and may be renamed, modified, or removed, without warning or documentation in release notes.

For a dedicated internal type library, feel free to look at the \href{./src/index.ts}{\texttt{ source code}} for inspiration -\/ or better, use a library like \href{https://npmjs.com/package/type-fest}{\texttt{ type-\/fest}}.\hypertarget{README.md_autotoc_md14869}{}\doxysubsubsection{\texorpdfstring{Error messages}{Error messages}}\label{README.md_autotoc_md14869}
When types don\textquotesingle{}t match, {\ttfamily .to\+Equal\+Type\+Of} and {\ttfamily .to\+Match\+Type\+Of} use a special helper type to produce error messages that are as actionable as possible. But there\textquotesingle{}s a bit of a nuance to understanding them. Since the assertions are written "{}fluently"{}, the failure should be on the "{}expected"{} type, not the "{}actual"{} type ({\ttfamily expect\texorpdfstring{$<$}{<}Actual\texorpdfstring{$>$}{>}().to\+Equal\+Type\+Of\texorpdfstring{$<$}{<}Expected\texorpdfstring{$>$}{>}()}). This means that type errors can be a little confusing -\/ so this library produces a {\ttfamily Mismatch\+Info} type to try to make explicit what the expectation is. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf<\{a:\ string\}>()}

\end{DoxyCode}


Is an assertion that will fail, since {\ttfamily \{a\+: 1\}} has type {\ttfamily \{a\+: number\}} and not {\ttfamily \{a\+: string\}}. The error message in this case will read something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{test/test.ts:999:999\ -\/\ error\ TS2344:\ Type\ '\{\ a:\ string;\ \}'\ does\ not\ satisfy\ the\ constraint\ '\{\ a:\ \(\backslash\)\(\backslash\)"{}Expected:\ string,\ Actual:\ number\(\backslash\)\(\backslash\)"{};\ \}'.}
\DoxyCodeLine{\ \ Types\ of\ property\ 'a'\ are\ incompatible.}
\DoxyCodeLine{\ \ \ \ Type\ 'string'\ is\ not\ assignable\ to\ type\ '\(\backslash\)\(\backslash\)"{}Expected:\ string,\ Actual:\ number\(\backslash\)\(\backslash\)"{}'.}
\DoxyCodeLine{}
\DoxyCodeLine{999\ expectTypeOf(\{a:\ 1\}).toEqualTypeOf<\{a:\ string\}>()}

\end{DoxyCode}


Note that the type constraint reported is a human-\/readable messaging specifying both the "{}expected"{} and "{}actual"{} types. Rather than taking the sentence `Types of property \textquotesingle{}a' are incompatible // Type \textquotesingle{}string\textquotesingle{} is not assignable to type "{}\+Expected\+: string, Actual\+: number"{}{\ttfamily literally -\/ just look at the property name (}\textquotesingle{}a\textquotesingle{}{\ttfamily ) and the message\+:}Expected\+: string, Actual\+: number\`{}. This will tell you what\textquotesingle{}s wrong, in most cases. Extremely complex types will, of course, be more effort to debug, and may require some experimentation. Please \href{https://github.com/mmkal/expect-type}{\texttt{ raise an issue}} if the error messages are misleading.

The {\ttfamily to\+Be...} methods (like {\ttfamily to\+Be\+String}, {\ttfamily to\+Be\+Number}, {\ttfamily to\+Be\+Void}, etc.) fail by resolving to a non-\/callable type when the {\ttfamily Actual} type under test doesn\textquotesingle{}t match up. For example, the failure for an assertion like {\ttfamily expect\+Type\+Of(1).to\+Be\+String()} will look something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{test/test.ts:999:999\ -\/\ error\ TS2349:\ This\ expression\ is\ not\ callable.}
\DoxyCodeLine{\ \ Type\ 'ExpectString<number>'\ has\ no\ call\ signatures.}
\DoxyCodeLine{}
\DoxyCodeLine{999\ expectTypeOf(1).toBeString()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \string~\string~\string~\string~\string~\string~\string~\string~\string~\string~}

\end{DoxyCode}


The {\ttfamily This expression is not callable} part isn\textquotesingle{}t all that helpful -\/ the meaningful error is the next line, {\ttfamily Type \textquotesingle{}Expect\+String\texorpdfstring{$<$}{<}number\texorpdfstring{$>$}{>} has no call signatures}. This essentially means you passed a number but asserted it should be a string.

If Type\+Script added support for \href{https://github.com/microsoft/TypeScript/pull/40468}{\texttt{ "{}throw"{} types}} these error messages could be improved. Until then they will take a certain amount of squinting.\hypertarget{README.md_autotoc_md14870}{}\doxysubsubsubsection{\texorpdfstring{Concrete "{}expected"{} objects vs type arguments}{Concrete "{}expected"{} objects vs type arguments}}\label{README.md_autotoc_md14870}
Error messages for an assertion like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf(\{a:\ ''\})}

\end{DoxyCode}


Will be less helpful than for an assertion like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{expectTypeOf(\{a:\ 1\}).toEqualTypeOf<\{a:\ string\}>()}

\end{DoxyCode}


This is because the Type\+Script compiler needs to infer the type argument for the `.to\+Equal\+Type\+Of(\{a\+: '\textquotesingle{}\}){\ttfamily style and this library can only mark it as a failure by comparing it against a generic}Mismatch{\ttfamily type. So, where possible, use a type argument rather than a concrete type for}.to\+Equal\+Type\+Of{\ttfamily and}to\+Match\+Type\+Of{\ttfamily . If it\textquotesingle{}s much more convenient to compare two concrete types, you can use}typeof\`{}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ one\ =\ valueFromFunctionOne(\{some:\ \{complex:\ inputs\}\})}
\DoxyCodeLine{const\ two\ =\ valueFromFunctionTwo(\{some:\ \{other:\ inputs\}\})}
\DoxyCodeLine{}
\DoxyCodeLine{expectTypeOf(one).toEqualTypeof<typeof\ two>()}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md14871}{}\doxysubsubsection{\texorpdfstring{Overloaded functions}{Overloaded functions}}\label{README.md_autotoc_md14871}
Due to a Type\+Script \href{https://github.com/microsoft/TypeScript/issues/32164\#issuecomment-506810756}{\texttt{ design limitation}}, the native Type\+Script {\ttfamily Parameters\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} and {\ttfamily Return\+Type\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} helpers only return types from one variant of an overloaded function. This limitation doesn\textquotesingle{}t apply to expect-\/type, since it is not used to author Type\+Script code, only to assert on existing types. So, we use a workaround for this Type\+Script behaviour to assert on {\itshape all} overloads as a union (actually, not necessarily {\itshape all} -\/ we cap out at 10 overloads).\hypertarget{README.md_autotoc_md14872}{}\doxysubsubsection{\texorpdfstring{Within test frameworks}{Within test frameworks}}\label{README.md_autotoc_md14872}
\hypertarget{README.md_autotoc_md14873}{}\doxysubsubsection{\texorpdfstring{Vitest}{Vitest}}\label{README.md_autotoc_md14873}
{\ttfamily expect\+Type\+Of} is built in to \href{https://vitest.dev/guide/testing-types}{\texttt{ vitest}}, so you can import {\ttfamily expect\+Type\+Of} from the vitest library directly if you prefer. Note that there is no set release cadence, at time of writing, so vitest may not always be using the very latest version.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{expectTypeOf\}\ from\ 'vitest'}
\DoxyCodeLine{import\ \{mount\}\ from\ './mount.js'}
\DoxyCodeLine{}
\DoxyCodeLine{test('my\ types\ work\ properly',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ expectTypeOf(mount).toBeFunction()}
\DoxyCodeLine{\ \ expectTypeOf(mount).parameter(0).toMatchTypeOf<\{name:\ string\}>()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ expectTypeOf(mount(\{name:\ 42\})).toBeString()}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md14874}{}\doxysubsubsubsection{\texorpdfstring{Jest \& {\ttfamily eslint-\/plugin-\/jest}}{Jest \& {\ttfamily eslint-\/plugin-\/jest}}}\label{README.md_autotoc_md14874}
If you\textquotesingle{}re using Jest along with {\ttfamily eslint-\/plugin-\/jest}, and you put assertions inside {\ttfamily test(...)} definitions, you may get warnings from the \href{https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/expect-expect.md}{\texttt{ {\ttfamily jest/expect-\/expect}}} rule, complaining that "{}\+Test has no assertions"{} for tests that only use {\ttfamily expect\+Type\+Of()}.

To remove this warning, configure the ESLint rule to consider {\ttfamily expect\+Type\+Of} as an assertion\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}rules"{}:\ \{}
\DoxyCodeLine{\ \ //\ ...}
\DoxyCodeLine{\ \ "{}jest/expect-\/expect"{}:\ [}
\DoxyCodeLine{\ \ \ \ "{}warn"{},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}assertFunctionNames"{}:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}expect"{},\ "{}expectTypeOf"{}}
\DoxyCodeLine{\ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ],}
\DoxyCodeLine{\ \ //\ ...}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md14875}{}\doxysubsubsection{\texorpdfstring{Limitations}{Limitations}}\label{README.md_autotoc_md14875}
A summary of some of the limitations of this library. Some of these are documented more fully elsewhere.


\begin{DoxyEnumerate}
\item Intersection types can result in failures when the expected and actual types are not identically defined, even when they are effectively identical. See Why is my assertion failing for details. TL;DR\+: use {\ttfamily .brand} in these cases -\/ and accept the performance hit that it comes with.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\ttfamily to\+Be\+Callable\+With} will likely fail if you try to use it with a generic function or an overload. See \href{https://github.com/mmkal/expect-type/issues/50}{\texttt{ this issue}} for an example and how to work around it.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item (For now) overloaded functions might trip up the {\ttfamily .parameter} and {\ttfamily .parameters} helpers. This matches how the built-\/in Type\+Script helper {\ttfamily Parameters\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} works. This may be improved in the future though (\href{https://github.com/mmkal/expect-type/issues/30}{\texttt{ see related issue}}).
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item {\ttfamily expect\+Type\+Of(this).to\+Equal\+Type\+Of(this)} inside class methods does not work.
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md14876}{}\doxysubsection{\texorpdfstring{Similar projects}{Similar projects}}\label{README.md_autotoc_md14876}
Other projects with similar goals\+:


\begin{DoxyItemize}
\item \href{https://github.com/SamVerschueren/tsd}{\texttt{ {\ttfamily tsd}}} is a CLI that runs the Type\+Script type checker over assertions
\item \href{https://github.com/TypeStrong/ts-expect}{\texttt{ {\ttfamily ts-\/expect}}} exports several generic helper types to perform type assertions
\item \href{https://github.com/Microsoft/dtslint}{\texttt{ {\ttfamily dtslint}}} does type checks via comment directives and tslint
\item \href{https://github.com/unional/type-plus}{\texttt{ {\ttfamily type-\/plus}}} comes with various type and runtime Type\+Script assertions
\item \href{https://github.com/ksxnodemodules/static-type-assert}{\texttt{ {\ttfamily static-\/type-\/assert}}} type assertion functions
\end{DoxyItemize}\hypertarget{README.md_autotoc_md14877}{}\doxysubsubsection{\texorpdfstring{Comparison}{Comparison}}\label{README.md_autotoc_md14877}
The key differences in this project are\+:


\begin{DoxyItemize}
\item a fluent, jest-\/inspired API, making the difference between {\ttfamily actual} and {\ttfamily expected} clear. This is helpful with complex types and assertions.
\item inverting assertions intuitively and easily via {\ttfamily expect\+Type\+Of(...).not}
\item checks generics properly and strictly (\href{https://github.com/SamVerschueren/tsd/issues/142}{\texttt{ tsd doesn\textquotesingle{}t}})
\item first-\/class support for\+:
\begin{DoxyItemize}
\item {\ttfamily any} (as well as {\ttfamily unknown} and {\ttfamily never}) (see issues outstanding at time of writing in tsd for \href{https://github.com/SamVerschueren/tsd/issues/78}{\texttt{ never}} and \href{https://github.com/SamVerschueren/tsd/issues/82}{\texttt{ any}}).
\begin{DoxyItemize}
\item This can be especially useful in combination with {\ttfamily not}, to protect against functions returning too-\/permissive types. For example, {\ttfamily const parse\+File = (filename\+: string) =\texorpdfstring{$>$}{>} JSON.\+parse(read\+File\+Sync(filename).to\+String())} returns {\ttfamily any}, which could lead to errors. After giving it a proper return-\/type, you can add a test for this with {\ttfamily expect(parse\+File).returns.\+not.\+to\+Be\+Any()}
\end{DoxyItemize}
\item object properties
\item function parameters
\item function return values
\item constructor parameters
\item class instances
\item array item values
\item nullable types
\end{DoxyItemize}
\item assertions on types "{}matching"{} rather than exact type equality, for "{}is-\/a"{} relationships e.\+g. {\ttfamily expect\+Type\+Of(square).to\+Match\+Type\+Of\texorpdfstring{$<$}{<}Shape\texorpdfstring{$>$}{>}()}
\item built into existing tooling. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time -\/ they\textquotesingle{}ll appear in your IDE and when you run {\ttfamily tsc}.
\item small implementation with no dependencies. \href{./src/index.ts}{\texttt{ Take a look!}} (tsd, for comparison, is \href{https://bundlephobia.com/result?p=tsd@0.13.1}{\texttt{ 2.\+6\+MB}} because it ships a patched version of Type\+Script).
\end{DoxyItemize}\hypertarget{README.md_autotoc_md14878}{}\doxysubsection{\texorpdfstring{Type\+Script backwards-\/compatibility}{Type\+Script backwards-\/compatibility}}\label{README.md_autotoc_md14878}
There is a CI job called {\ttfamily test-\/types} that checks whether the tests still pass with certain older Type\+Script versions. To check the supported Type\+Script versions, \href{./.github/workflows/ci.yml}{\texttt{ refer to the job definition}}.\hypertarget{README.md_autotoc_md14879}{}\doxysubsection{\texorpdfstring{Contributing}{Contributing}}\label{README.md_autotoc_md14879}
In most cases, it\textquotesingle{}s worth checking existing issues or creating one to discuss a new feature or a bug fix before opening a pull request.

Once you\textquotesingle{}re ready to make a pull request\+: clone the repo, and install pnpm if you don\textquotesingle{}t have it already with {\ttfamily npm install -\/-\/global pnpm}. Lockfiles for {\ttfamily npm} and {\ttfamily yarn} are gitignored.

If you\textquotesingle{}re adding a feature, you should write a self-\/contained usage example in the form of a test, in \href{./test/usage.test.ts}{\texttt{ test/usage.\+test.\+ts}}. This file is used to populate the bulk of this readme using \href{https://npmjs.com/package/eslint-plugin-codegen}{\texttt{ eslint-\/plugin-\/codegen}}, and to generate an \href{./test/errors.test.ts}{\texttt{ "{}errors"{} test file}}, which captures the error messages that are emitted for failing assertions by the Type\+Script compiler. So, the test name should be written as a human-\/readable sentence explaining the usage example. Have a look at the existing tests for an idea of the style.

After adding the tests, run {\ttfamily npm run lint -\/-\/ -\/-\/fix} to update the readme, and {\ttfamily npm test -\/-\/ -\/-\/update\+Snapshot} to update the errors test. The generated documentation and tests should be pushed to the same branch as the source code, and submitted as a pull request. CI will test that the docs and tests are up to date if you forget to run these commands.\hypertarget{README.md_autotoc_md14880}{}\doxysubsubsection{\texorpdfstring{Documentation of limitations through tests}{Documentation of limitations through tests}}\label{README.md_autotoc_md14880}
Limitations of the library are documented through tests in {\ttfamily usage.\+test.\+ts}. This means that if a future Type\+Script version (or library version) fixes the limitation, the test will start failing, and it will be automatically removed from the documentation once it no longer applies. 