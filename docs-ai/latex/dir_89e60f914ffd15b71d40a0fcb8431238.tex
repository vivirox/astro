\doxysection{node\+\_\+modules/oniguruma-\/to-\/es/node\+\_\+modules/regex Directory Reference}
\hypertarget{dir_89e60f914ffd15b71d40a0fcb8431238}{}\label{dir_89e60f914ffd15b71d40a0fcb8431238}\index{node\_modules/oniguruma-\/to-\/es/node\_modules/regex Directory Reference@{node\_modules/oniguruma-\/to-\/es/node\_modules/regex Directory Reference}}


\doxysubsection{Detailed Description}
 \href{https://github.com/slevithan/regex\#readme}{\texttt{   }} ~\newline
~\newline


 \href{https://npmjs.com/package/regex}{\texttt{ }} \href{https://npmjs.com/package/regex}{\texttt{ }} \href{https://bundlejs.com/?q=regex&treeshake=[*]}{\texttt{ }} 

Regex+ (aka {\ttfamily regex}, based on its package and tag name) is a template tag that extends Java\+Script regular expressions with key features that make regexes more powerful and dramatically more readable. It returns native {\ttfamily Reg\+Exp} instances that run with native performance, and can exceed the performance of regex literals you\textquotesingle{}d write yourself. It\textquotesingle{}s also lightweight, supports all ES2025 regex features, has built-\/in types, and can be used as a \href{https://github.com/slevithan/babel-plugin-transform-regex}{\texttt{ Babel plugin}} to avoid any runtime dependencies or user runtime cost.

Highlights include support for insignificant whitespace and comments, atomic groups and possessive quantifiers (that can help you avoid \href{https://en.wikipedia.org/wiki/ReDoS}{\texttt{ Re\+DoS}}), subroutines and subroutine definition groups (that enable powerful subpattern composition), and context-\/aware interpolation of regexes, escaped strings, and partial patterns.

With the Regex+ library, Java\+Script steps up as one of the best regex flavors alongside PCRE and Perl, possibly surpassing C++, Java, .NET, Python, and Ruby.



{\bfseries{{\bfseries{Table of contents}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item Features
\item Install and use
\item Examples
\item Context
\item Extended regex syntax
\begin{DoxyItemize}
\item Atomic groups
\item Possessive quantifiers
\item Subroutines
\item Subroutine definition groups
\item Recursion
\end{DoxyItemize}
\item Flags
\begin{DoxyItemize}
\item Implicit flags
\item Flag {\ttfamily v}
\item Flag {\ttfamily x}
\item Flag {\ttfamily n}
\end{DoxyItemize}
\item Interpolation
\begin{DoxyItemize}
\item \`{}\+Reg\+Exp\`{} instances
\item Escaped strings
\item Partial patterns
\item Interpolation principles
\item Interpolation contexts
\end{DoxyItemize}
\item Options
\begin{DoxyItemize}
\item Returning a string
\end{DoxyItemize}
\item Performance
\item Compatibility
\item FAQ 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25141}{}\doxysubsubsection{\texorpdfstring{üíé Features}{üíé Features}}\label{README.md_autotoc_md25141}
{\bfseries{A modern regex baseline}} so you don\textquotesingle{}t need to continually opt-\/in to best practices.


\begin{DoxyItemize}
\item Always-\/on flag {\ttfamily v} gives you the best level of Unicode support and strict errors.
\item New flags\+:
\begin{DoxyItemize}
\item Always-\/on flag {\ttfamily x} allows you to freely add whitespace and comments to your regexes.
\item Always-\/on flag {\ttfamily n} ({\itshape named capture only} mode) improves regex readability and efficiency.
\end{DoxyItemize}
\item No unreadable escaped backslashes {\ttfamily \textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}} since it\textquotesingle{}s a raw string template tag.
\end{DoxyItemize}

{\bfseries{Extended regex syntax}}.


\begin{DoxyItemize}
\item Atomic groups and possessive quantifiers can dramatically improve performance and prevent Re\+DoS.
\item Subroutines and definition groups enable powerful composition, improving readability and maintainability.
\item Recursive matching via an official plugin.
\item Custom syntax plugins supported.
\end{DoxyItemize}

{\bfseries{Context-\/aware and safe interpolation}} of regexes, strings, and partial patterns.


\begin{DoxyItemize}
\item Interpolated strings have their special characters escaped.
\item Interpolated regexes locally preserve the meaning of their own flags (or their absense), and their numbered backreferences are adjusted to work within the overall pattern.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md25142}{}\doxysubsubsection{\texorpdfstring{üïπÔ∏è Install and use}{üïπÔ∏è Install and use}}\label{README.md_autotoc_md25142}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ regex}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{regex\}\ from\ 'regex';}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Works\ with\ all\ string/regexp\ methods\ since\ it\ returns\ a\ native\ regexp}
\DoxyCodeLine{const\ str\ =\ 'abc';}
\DoxyCodeLine{regex`\(\backslash\)w`.test(str);\ //\ ‚Üí\ true}
\DoxyCodeLine{str.match(regex('g')`\(\backslash\)w`);\ //\ ‚Üí\ ['a',\ 'b',\ 'c']}

\end{DoxyCode}




{\bfseries{In browsers}}\begin{adjustwidth}{1em}{0em}


ESM\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ type="{}module"{}>}
\DoxyCodeLine{\ \ import\ \{regex\}\ from\ 'https://esm.run/regex';}
\DoxyCodeLine{\ \ //\ ‚Ä¶}
\DoxyCodeLine{</script>}

\end{DoxyCode}


Using a global name\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}https://cdn.jsdelivr.net/npm/regex/dist/regex.min.js"{}></script>}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ const\ \{regex\}\ =\ Regex;}
\DoxyCodeLine{\ \ //\ ‚Ä¶}
\DoxyCodeLine{</script>}

\end{DoxyCode}
 \end{adjustwidth}
\hypertarget{README.md_autotoc_md25143}{}\doxysubsubsection{\texorpdfstring{ü™ß Examples}{ü™ß Examples}}\label{README.md_autotoc_md25143}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{regex,\ pattern\}\ from\ 'regex';}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Subroutines\ and\ subroutine\ definition\ group}
\DoxyCodeLine{const\ record\ =\ regex`}
\DoxyCodeLine{\ \ \string^\ Admitted:\ \(\backslash\)g<date>\ \(\backslash\)n}
\DoxyCodeLine{\ \ \ \ Released:\ \(\backslash\)g<date>\ \$}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?(DEFINE)}
\DoxyCodeLine{\ \ \ \ (?<date>\ \ \(\backslash\)g<year>-\/\(\backslash\)g<month>-\/\(\backslash\)g<day>)}
\DoxyCodeLine{\ \ \ \ (?<year>\ \ \(\backslash\)d\{4\})}
\DoxyCodeLine{\ \ \ \ (?<month>\ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ \ \ (?<day>\ \ \ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ )}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Atomic\ group:\ Avoids\ ReDoS\ from\ the\ nested,\ overlapping\ quantifier}
\DoxyCodeLine{const\ words\ =\ regex`\string^(?>\(\backslash\)w+\(\backslash\)s?)+\$`;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Context-\/aware\ interpolation}
\DoxyCodeLine{const\ re\ =\ regex('m')`}
\DoxyCodeLine{\ \ \#\ Only\ the\ inner\ regex\ is\ case\ insensitive\ (flag\ i)}
\DoxyCodeLine{\ \ \#\ Also,\ the\ outer\ regex's\ flag\ m\ is\ not\ applied\ to\ it}
\DoxyCodeLine{\ \ \$\{/\string^a.b\$/i\}}
\DoxyCodeLine{\ \ |}
\DoxyCodeLine{\ \ \#\ Strings\ are\ escaped\ and\ repeated\ as\ complete\ units}
\DoxyCodeLine{\ \ \string^\ \$\{'a.b'\}+\ \$}
\DoxyCodeLine{\ \ |}
\DoxyCodeLine{\ \ \#\ This\ string\ is\ contextually\ sandboxed\ but\ not\ escaped}
\DoxyCodeLine{\ \ \$\{pattern('\string^\ a.b\ \$')\}}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Numbered\ backreferences\ in\ interpolated\ regexes\ are\ adjusted}
\DoxyCodeLine{const\ double\ =\ /(.)\(\backslash\)1/;}
\DoxyCodeLine{regex`\string^\ (?<first>.)\ \$\{double\}\ \$\{double\}\ \$`;}
\DoxyCodeLine{//\ ‚Üí\ /\string^(?<first>.)(.)\(\backslash\)2(.)\(\backslash\)3\$/v}

\end{DoxyCode}


See also the following examples of using subroutine definition groups to refactor regexes for readability and maintainability\+:


\begin{DoxyItemize}
\item \href{https://x.com/slevithan/status/1828112006353953055}{\texttt{ IP address regex}}.
\item \href{https://bsky.app/profile/slev.life/post/3lgc6ullyvk2x}{\texttt{ Date time regex}}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md25144}{}\doxysubsubsection{\texorpdfstring{‚ùì Context}{‚ùì Context}}\label{README.md_autotoc_md25144}
Due to years of legacy and backward compatibility, regular expression syntax in Java\+Script is a bit of a mess. There are four different sets of incompatible syntax and behavior rules that might apply to your regexes depending on the flags and features you use. The differences are just plain hard to fully grok and can easily create subtle bugs.



{\bfseries{See the four parsing modes}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyEnumerate}
\item Unicode-\/unaware (legacy) mode is the default and can easily and silently create Unicode-\/related bugs.
\item Named capture mode changes the meaning of {\ttfamily \textbackslash{}k} when a named capture appears anywhere in a regex.
\item Unicode mode with flag {\ttfamily u} adds strict errors (for unreserved escapes, octal escapes, quantified lookahead, etc.), switches to code point matching (changing the potential handling of the dot, negated sets like {\ttfamily \textbackslash{}W}, character class ranges, and quantifiers), changes flag {\ttfamily i} to apply Unicode case-\/folding, and adds support for new syntax.
\item Unicode\+Sets mode with flag {\ttfamily v} (an upgrade to {\ttfamily u}) incompatibly changes escaping rules within character classes, fixes case-\/insensitive matching for {\ttfamily \textbackslash{}p} and {\ttfamily \textbackslash{}P} within negated {\ttfamily \mbox{[}\texorpdfstring{$^\wedge$}{\string^}‚Ä¶\mbox{]}}, and adds support for new features/syntax. 
\end{DoxyEnumerate}\end{adjustwidth}


Additionally, Java\+Script regex syntax is hard to write and even harder to read and refactor. But it doesn\textquotesingle{}t have to be that way! With a few key features ‚Äî raw multiline strings, insignificant whitespace, comments, subroutines, subroutine definition groups, interpolation, and {\itshape named capture only} mode ‚Äî even long and complex regexes can be beautiful, grammatical, and intuitive.

Regex+ adds all of these features and returns native {\ttfamily Reg\+Exp} instances. It always uses flag {\ttfamily v} (already a best practice for new regexes) so you never forget to turn it on and don\textquotesingle{}t have to worry about the differences in other parsing modes (in environments without native {\ttfamily v}, flag {\ttfamily u} is automatically used instead while applying {\ttfamily v}\textquotesingle{}s escaping rules so your regexes are forward and backward compatible). It also supports atomic groups and possessive quantifiers to help you avoid catastrophic backtracking, and it gives you best-\/in-\/class, context-\/aware interpolation of {\ttfamily Reg\+Exp} instances, escaped strings, and partial patterns.\hypertarget{README.md_autotoc_md25145}{}\doxysubsubsection{\texorpdfstring{ü¶æ Extended regex syntax}{ü¶æ Extended regex syntax}}\label{README.md_autotoc_md25145}
Historically, Java\+Script regexes were not as powerful or readable as other major regex flavors like Java, .NET, PCRE, Perl, Python, and Ruby. With recent advancements and the Regex+ library, those days are over. Modern Java\+Script regexes have \href{https://github.com/slevithan/awesome-regex\#javascript-regex-evolution}{\texttt{ significantly improved}}, adding lookbehind, named capture, Unicode properties, set subtraction and intersection, etc. The extended syntax and implicit flags provided by Regex+ add the key remaining pieces needed to stand alongside or surpass other major flavors.\hypertarget{README.md_autotoc_md25146}{}\doxysubsubsubsection{\texorpdfstring{Atomic groups}{Atomic groups}}\label{README.md_autotoc_md25146}
Atomic groups are noncapturing groups with special behavior, and are written as {\ttfamily (?\texorpdfstring{$>$}{>}‚Ä¶)}. After matching the contents of an atomic group, the regex engine automatically throws away all backtracking positions remembered by any tokens within the group. Atomic groups are most commonly used to improve performance, and are a much needed feature that Regex+ brings to native Java\+Script regular expressions.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`\string^(?>\(\backslash\)w+\(\backslash\)s?)+\$`}

\end{DoxyCode}


This matches strings that contain word characters separated by spaces, with the final space being optional. Thanks to the atomic group, it instantly fails to find a match if given a long list of words that end with something not allowed, like `\textquotesingle{}A target string that takes a long time or can even hang your browser!'\`{}.

Try running this without the atomic group (as {\ttfamily /\texorpdfstring{$^\wedge$}{\string^}(?\+:\textbackslash{}w+\textbackslash{}s?)+\$/}) and, due to the exponential backtracking triggered by the many ways to divide the work of the inner and outer {\ttfamily +} quantifiers, it will either take a {\itshape very} long time, hang your browser/server, or throw an internal error after a delay. This is called {\itshape \href{https://www.regular-expressions.info/catastrophic.html}{\texttt{ catastrophic backtracking}}} or {\itshape \href{https://en.wikipedia.org/wiki/ReDoS}{\texttt{ Re\+DoS}}}, and it has taken down major services like \href{https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019}{\texttt{ Cloudflare}} and \href{https://stackstatus.tumblr.com/post/147710624694/outage-postmortem-july-20-2016}{\texttt{ Stack Overflow}}. Regex+ and atomic groups to the rescue!



{\bfseries{üëâ {\bfseries{Learn more with examples}}}}\begin{adjustwidth}{1em}{0em}


Consider {\ttfamily regex\`{}(?\texorpdfstring{$>$}{>}a+)ab\`{}} vs {\ttfamily regex\`{}(?\+:a+)ab\`{}}. The former (with an atomic group) doesn\textquotesingle{}t match `\textquotesingle{}aaaab'\`{}, but the latter does. The former doesn\textquotesingle{}t match because\+:


\begin{DoxyItemize}
\item The regex engine starts by using the greedy {\ttfamily a+} within the atomic group to match all the {\ttfamily a}s in the target string.
\item Then, when it tries to match the additional {\ttfamily a} outside the group, it fails (the next character in the target string is a {\ttfamily b}), so the regex engine backtracks.
\item But because it can\textquotesingle{}t backtrack into the atomic group to make the {\ttfamily +} give up its last matched {\ttfamily a}, there are no additional options to try and the overall match attempt fails.
\end{DoxyItemize}

For a more useful example, consider how this can affect lazy (non-\/greedy) quantifiers. Let\textquotesingle{}s say you want to match {\ttfamily \texorpdfstring{$<$}{<}b\texorpdfstring{$>$}{>}‚Ä¶\texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}} tags that are followed by {\ttfamily !}. You might try this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex('gis')`<b>.*?</b>!`;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ This\ is\ OK}
\DoxyCodeLine{'<b>Hi</b>!\ <b>Bye</b>.'.match(re);}
\DoxyCodeLine{//\ ‚Üí\ ['<b>Hi</b>!']}
\DoxyCodeLine{}
\DoxyCodeLine{//\ But\ not\ this}
\DoxyCodeLine{'<b>Hi</b>.\ <b>Bye</b>!'.match(re);}
\DoxyCodeLine{//\ ‚Üí\ ['<b>Hi</b>.\ <b>Bye</b>!']\ üëé}

\end{DoxyCode}


What happened with the second string was that, when an {\ttfamily !} wasn\textquotesingle{}t found immediately following the first {\ttfamily \texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}}, the regex engine backtracked and expanded the lazy {\ttfamily .\texorpdfstring{$\ast$}{*}?} to match an additional character (in this case, the {\ttfamily \texorpdfstring{$<$}{<}} of the {\ttfamily \texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}} tag) and then continued onward, all the way to just before the {\ttfamily \texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}!} at the end.

You can prevent this by wrapping the lazily quantified token and its following delimiter in an atomic group, as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex('gis')`<b>(?>.*?</b>)!`;}
\DoxyCodeLine{}
\DoxyCodeLine{'<b>Hi</b>.\ <b>Bye</b>!'.match(re);}
\DoxyCodeLine{//\ ‚Üí\ ['<b>Bye</b>!']\ üëç}

\end{DoxyCode}


Now, after the regex engine finds the first {\ttfamily \texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}} and exits the atomic group, it can no longer backtrack into the group and change what the {\ttfamily .\texorpdfstring{$\ast$}{*}?} already matched. As a result, the match attempt fails at the beginning of this example string. The regex engine then moves on and starts over at subsequent positions in the string, eventually finding {\ttfamily \texorpdfstring{$<$}{<}b\texorpdfstring{$>$}{>}Bye\texorpdfstring{$<$}{<}/b\texorpdfstring{$>$}{>}!}. Success. \end{adjustwidth}


\begin{DoxyNote}{Note}
Atomic groups are supported in many other regex flavors. There\textquotesingle{}s a \href{https://github.com/tc39/proposal-regexp-atomic-operators}{\texttt{ proposal}} to add them to Java\+Script.
\end{DoxyNote}
\hypertarget{README.md_autotoc_md25147}{}\doxysubsubsubsection{\texorpdfstring{Possessive quantifiers}{Possessive quantifiers}}\label{README.md_autotoc_md25147}
Possessive quantifiers are created by adding {\ttfamily +} to a quantifier, and they\textquotesingle{}re similar to greedy quantifiers except they don\textquotesingle{}t allow backtracking. Although greedy quantifiers start out by matching as much as possible, if the remainder of the regex doesn\textquotesingle{}t find a match, the regex engine will backtrack and try all permutations of how many times the quantifier should repeat. Possessive quantifiers prevent the regex engine from doing this.

\begin{quote}
Possessive quantifiers are syntactic sugar for atomic groups when their contents are a single repeated item (which could be a token, character class, or group). \end{quote}


Like atomic groups, possessive quantifiers are mostly useful for performance and preventing Re\+DoS, but they can also be used to eliminate certain matches. For example, {\ttfamily regex\`{}a++.\`{}} matches one or more {\ttfamily a} followed by a character other than {\ttfamily a}. Unlike {\ttfamily /a+./}, it won\textquotesingle{}t match a sequence of only {\ttfamily a} characters like `\textquotesingle{}aaa'{\ttfamily . The possessive}++{\ttfamily doesn\textquotesingle{}t give back any of the}a{\ttfamily s it matched, so in this case there\textquotesingle{}s nothing left for the following}.\`{} to match.

Here\textquotesingle{}s how possessive quantifier syntax compares to the greedy and lazy quantifiers that Java\+Script supports natively\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Greedy   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Lazy   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Possessive    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Greedy   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Lazy   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Possessive    }\\\cline{1-4}
\endhead
{\bfseries{Repeat}}   &\PBS\centering As many times as possible,~\newline
giving back as needed   &\PBS\centering As few times as possible,~\newline
expanding as needed   &\PBS\centering As many times as possible,~\newline
without giving back    \\\cline{1-4}
Zero or one   &\PBS\centering {\ttfamily ?}   &\PBS\centering {\ttfamily ??}   &\PBS\centering {\ttfamily ?+}    \\\cline{1-4}
Zero or more   &\PBS\centering {\ttfamily \texorpdfstring{$\ast$}{*}}   &\PBS\centering {\ttfamily \texorpdfstring{$\ast$}{*}?}   &\PBS\centering {\ttfamily \texorpdfstring{$\ast$}{*}+}    \\\cline{1-4}
One or more   &\PBS\centering {\ttfamily +}   &\PBS\centering {\ttfamily +?}   &\PBS\centering {\ttfamily ++}    \\\cline{1-4}
{\itshape N} or more   &\PBS\centering {\ttfamily \{2,\}}   &\PBS\centering {\ttfamily \{2,\}?}   &\PBS\centering {\ttfamily \{2,\}+}    \\\cline{1-4}
Between {\itshape N} and {\itshape M}   &\PBS\centering {\ttfamily \{0,5\}}   &\PBS\centering {\ttfamily \{0,5\}?}   &\PBS\centering {\ttfamily \{0,5\}+}   \\\cline{1-4}
\end{longtabu}


\begin{quote}
Fixed repetition quantifiers behave the same whether they\textquotesingle{}re greedy {\ttfamily \{2\}}, lazy {\ttfamily \{2\}?}, or possessive {\ttfamily \{2\}+}. \end{quote}


\begin{DoxyNote}{Note}
Possessive quantifiers are supported in many other regex flavors. There\textquotesingle{}s a \href{https://github.com/tc39/proposal-regexp-atomic-operators}{\texttt{ proposal}} to add them to Java\+Script.
\end{DoxyNote}
\hypertarget{README.md_autotoc_md25148}{}\doxysubsubsubsection{\texorpdfstring{Subroutines}{Subroutines}}\label{README.md_autotoc_md25148}
Subroutines are written as {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}} (where {\itshape name} refers to a named group), and they treat the referenced group as an independent subpattern that they try to match at the current position. This enables subpattern composition and reuse, which improves readability and maintainability.

The following example illustrates how subroutines and backreferences differ\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ A\ backreference\ with\ \(\backslash\)k<name>}
\DoxyCodeLine{regex`(?<prefix>sens|respons)e\(\backslash\)\ and\(\backslash\)\ \(\backslash\)k<prefix>ibility`}
\DoxyCodeLine{/*\ Matches:}
\DoxyCodeLine{-\/\ 'sense\ and\ sensibility'}
\DoxyCodeLine{-\/\ 'response\ and\ responsibility'\ */}
\DoxyCodeLine{}
\DoxyCodeLine{//\ A\ subroutine\ with\ \(\backslash\)g<name>}
\DoxyCodeLine{regex`(?<prefix>sens|respons)e\(\backslash\)\ and\(\backslash\)\ \(\backslash\)g<prefix>ibility`}
\DoxyCodeLine{/*\ Matches:}
\DoxyCodeLine{-\/\ 'sense\ and\ sensibility'}
\DoxyCodeLine{-\/\ 'sense\ and\ responsibility'}
\DoxyCodeLine{-\/\ 'response\ and\ sensibility'}
\DoxyCodeLine{-\/\ 'response\ and\ responsibility'\ */}

\end{DoxyCode}


Subroutines go beyond the composition benefits of interpolation. Apart from the obvious difference that they don\textquotesingle{}t require variables to be defined outside of the regex, they also don\textquotesingle{}t simply insert the referenced subpattern.


\begin{DoxyEnumerate}
\item They can reference groups that themselves contain subroutines, chained to any depth.
\item Any capturing groups that are set during the subroutine call revert to their previous values afterwards.
\item They don\textquotesingle{}t create named captures that are visible outside of the subroutine, so using subroutines doesn\textquotesingle{}t lead to "{}duplicate capture group name"{} errors.
\end{DoxyEnumerate}

To illustrate points 2 and 3, consider\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`}
\DoxyCodeLine{\ \ (?<double>\ (?<char>.)\(\backslash\)k<char>)}
\DoxyCodeLine{\ \ \(\backslash\)g<double>}
\DoxyCodeLine{\ \ \(\backslash\)k<double>}
\DoxyCodeLine{\`{}}

\end{DoxyCode}


The backreference {\ttfamily \textbackslash{}k\texorpdfstring{$<$}{<}double\texorpdfstring{$>$}{>}} matches whatever was matched by capturing group {\ttfamily (?\texorpdfstring{$<$}{<}double\texorpdfstring{$>$}{>}‚Ä¶)}, regardless of what was matched in between by the subroutine {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}double\texorpdfstring{$>$}{>}}. For example, this regex matches `\textquotesingle{}xx!!xx'{\ttfamily , but not}\textquotesingle{}xx!!!!\textquotesingle{}\`{}.



{\bfseries{üëâ {\bfseries{Show more details}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item Subroutines can appear before the groups they reference.
\item If there are \href{https://github.com/tc39/proposal-duplicate-named-capturing-groups}{\texttt{ duplicate capture names}}, subroutines refer to the first instance of the given group (matching the behavior of PCRE and Perl).
\item Although subroutines can be chained to any depth, a descriptive error is thrown if they\textquotesingle{}re used recursively. Support for recursion can be added via a plugin (see \texorpdfstring{$\ast$}{*}\+Recursion\texorpdfstring{$\ast$}{*}).
\item Like backreferences, subroutines can\textquotesingle{}t be used {\itshape within} character classes.
\item As with all extended syntax in {\ttfamily regex}, subroutines are applied after interpolation, giving them maximal flexibility. 
\end{DoxyItemize}\end{adjustwidth}




{\bfseries{üëâ {\bfseries{Show how to define subpatterns for use by reference only}}}}\begin{adjustwidth}{1em}{0em}


The following regex matches an IPv4 address such as "{}192.\+168.\+12.\+123"{}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ipv4\ =\ regex`}
\DoxyCodeLine{\ \ \(\backslash\)b\ \(\backslash\)g<byte>\ (\(\backslash\).\ \(\backslash\)g<byte>)\{3\}\ \(\backslash\)b}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Define\ the\ 'byte'\ subpattern}
\DoxyCodeLine{\ \ (?<byte>\ 25[0-\/5]\ |\ 2[0-\/4]\(\backslash\)d\ |\ 1\(\backslash\)d\(\backslash\)d\ |\ [1-\/9]?\(\backslash\)d)\{0\}}
\DoxyCodeLine{\`{};}

\end{DoxyCode}


Above, the {\ttfamily \{0\}} quantifier at the end of the {\ttfamily (?\texorpdfstring{$<$}{<}byte\texorpdfstring{$>$}{>}‚Ä¶)} group allows {\itshape defining} the group without {\itshape matching} it at that position. The subpattern within it can then be used by reference elsewhere within the pattern.

This next regex matches a record with multiple date fields, and captures each value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex`}
\DoxyCodeLine{\ \ \string^\ Admitted:\(\backslash\)\ (?<admitted>\ \(\backslash\)g<date>)\ \(\backslash\)n}
\DoxyCodeLine{\ \ \ \ Released:\(\backslash\)\ (?<released>\ \(\backslash\)g<date>)\ \$}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Define\ subpatterns}
\DoxyCodeLine{\ \ (\ (?<date>\ \ \(\backslash\)g<year>-\/\(\backslash\)g<month>-\/\(\backslash\)g<day>)}
\DoxyCodeLine{\ \ \ \ (?<year>\ \ \(\backslash\)d\{4\})}
\DoxyCodeLine{\ \ \ \ (?<month>\ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ \ \ (?<day>\ \ \ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ )\{0\}}
\DoxyCodeLine{\`{};}

\end{DoxyCode}


Here, the {\ttfamily \{0\}} quantifier at the end once again prevents matching its group at that position, while enabling all of the named groups within it to be used by reference.

When using a regex to find matches (e.\+g. via the string {\ttfamily match\+All} method), named groups defined this way appear on each match\textquotesingle{}s {\ttfamily groups} object with the value {\ttfamily undefined} (which is the value for any capturing group that didn\textquotesingle{}t participate in a match). See the next section \texorpdfstring{$\ast$}{*}\+Subroutine definition groups\texorpdfstring{$\ast$}{*} for a way to prevent such groups from appearing on the {\ttfamily groups} object. \end{adjustwidth}


\begin{DoxyNote}{Note}
Subroutines are based on the feature in PCRE and Perl. PCRE allows several syntax options including the {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}} used by Regex+, whereas Perl uses {\ttfamily (?\&name)}. Ruby also supports subroutines (and uses the {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}} syntax), but it has behavior differences related to capturing and backreferences that arguably make its subroutines less useful.
\end{DoxyNote}
\hypertarget{README.md_autotoc_md25149}{}\doxysubsubsubsection{\texorpdfstring{Subroutine definition groups}{Subroutine definition groups}}\label{README.md_autotoc_md25149}
The syntax {\ttfamily (?(DEFINE)‚Ä¶)} can be used at the end of a regex to define subpatterns for use by reference only. When combined with subroutines, this enables writing regexes in a grammatical way that can significantly improve readability and maintainability.

\begin{quote}
Named groups defined within subroutine definition groups don\textquotesingle{}t appear on the {\ttfamily groups} object of matches. \end{quote}


Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex`}
\DoxyCodeLine{\ \ \string^\ Admitted:\(\backslash\)\ (?<admitted>\ \(\backslash\)g<date>)\ \(\backslash\)n}
\DoxyCodeLine{\ \ \ \ Released:\(\backslash\)\ (?<released>\ \(\backslash\)g<date>)\ \$}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?(DEFINE)}
\DoxyCodeLine{\ \ \ \ (?<date>\ \ \(\backslash\)g<year>-\/\(\backslash\)g<month>-\/\(\backslash\)g<day>)}
\DoxyCodeLine{\ \ \ \ (?<year>\ \ \(\backslash\)d\{4\})}
\DoxyCodeLine{\ \ \ \ (?<month>\ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ \ \ (?<day>\ \ \ \(\backslash\)d\{2\})}
\DoxyCodeLine{\ \ )}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{const\ record\ =\ 'Admitted:\ 2024-\/01-\/01\(\backslash\)nReleased:\ 2024-\/01-\/03';}
\DoxyCodeLine{const\ match\ =\ re.exec(record);}
\DoxyCodeLine{console.log(match.groups);}
\DoxyCodeLine{/*\ ‚Üí\ \{}
\DoxyCodeLine{\ \ admitted:\ '2024-\/01-\/01',}
\DoxyCodeLine{\ \ released:\ '2024-\/01-\/03'}
\DoxyCodeLine{\}\ */}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Subroutine definition groups are based on the feature in PCRE and Perl. However, Regex+ supports a stricter version since it limits their placement, quantity, and the top-\/level syntax that can be used within them.
\end{DoxyNote}


{\bfseries{üëâ {\bfseries{Show more details}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item {\bfseries{Quantity\+:}} Only one definition group is allowed per regex, but it can contain any number of named groups and those groups can appear in any order.
\item {\bfseries{Placement\+:}} Apart from trailing whitespace and comments (allowed by implicit flag {\ttfamily x}), definition groups must appear at the end of their pattern.
\item {\bfseries{Contents\+:}} At the top level of definition groups, only named groups, whitespace, and comments are allowed.
\item {\bfseries{Duplicate names\+:}} All named groups within definition groups must use unique names.
\item {\bfseries{Casing\+:}} The word {\ttfamily DEFINE} must appear in uppercase. 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25150}{}\doxysubsubsubsection{\texorpdfstring{Recursion}{Recursion}}\label{README.md_autotoc_md25150}
The official Regex+ plugin \href{https://github.com/slevithan/regex-recursion}{\texttt{ regex-\/recursion}} enables the syntax {\ttfamily (?R)} and {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}} to match recursive/balanced patterns up to a specified max depth (2‚Äì100).\hypertarget{README.md_autotoc_md25151}{}\doxysubsubsection{\texorpdfstring{üö© Flags}{üö© Flags}}\label{README.md_autotoc_md25151}
Flags are added like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex('gm')`\string^.+`}

\end{DoxyCode}


{\ttfamily Reg\+Exp} instances interpolated into the pattern preserve their own flags locally (see \texorpdfstring{$\ast$}{*}\+Interpolating regexes\texorpdfstring{$\ast$}{*}).\hypertarget{README.md_autotoc_md25152}{}\doxysubsubsubsection{\texorpdfstring{Implicit flags}{Implicit flags}}\label{README.md_autotoc_md25152}
Flag {\ttfamily v} and emulated flags {\ttfamily x} and {\ttfamily n} are always on when using {\ttfamily regex}, giving your regexes a modern baseline syntax and avoiding the need to continually opt-\/in to their superior modes.

\begin{quote}
For special situations such as when using Regex+ within other tools, implicit flags can be disabled. See\+: \texorpdfstring{$\ast$}{*}\+Options\texorpdfstring{$\ast$}{*}. \end{quote}
\hypertarget{README.md_autotoc_md25153}{}\doxysubsubsubsection{\texorpdfstring{Flag {\ttfamily v}}{Flag {\ttfamily v}}}\label{README.md_autotoc_md25153}
Java\+Script\textquotesingle{}s native flag {\ttfamily v} gives you the best level of Unicode support, strict errors, and all the latest regex features like character class set operations and properties of strings (see \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicodeSets}{\texttt{ MDN}}). It\textquotesingle{}s always on when using {\ttfamily regex}, which helps avoid numerous Unicode-\/related bugs, and means there\textquotesingle{}s only one way to parse a regex instead of four (so you only need to remember one set of regex syntax and behavior).

Flag {\ttfamily v} is applied to the full pattern after interpolation happens.

\begin{quote}
In environments without native support for flag {\ttfamily v}, flag {\ttfamily u} is automatically used instead while applying {\ttfamily v}\textquotesingle{}s escaping rules so your regexes are forward and backward compatible. \end{quote}
\hypertarget{README.md_autotoc_md25154}{}\doxysubsubsubsection{\texorpdfstring{Flag {\ttfamily x}}{Flag {\ttfamily x}}}\label{README.md_autotoc_md25154}
Emulated flag {\ttfamily x} makes whitespace insignificant and adds support for line comments (starting with {\ttfamily \#}), allowing you to freely format your regexes for readability. It\textquotesingle{}s always implicitly on, though it doesn\textquotesingle{}t extend into interpolated {\ttfamily Reg\+Exp} instances (to avoid changing their meaning).

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex`}
\DoxyCodeLine{\ \ \#\ Match\ a\ date\ in\ YYYY-\/MM-\/DD\ format}
\DoxyCodeLine{\ \ (?<year>\ \ \(\backslash\)d\{4\})\ -\/\ \#\ Year\ part}
\DoxyCodeLine{\ \ (?<month>\ \(\backslash\)d\{2\})\ -\/\ \#\ Month\ part}
\DoxyCodeLine{\ \ (?<day>\ \ \ \(\backslash\)d\{2\})\ \ \ \#\ Day\ part}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Escape\ whitespace\ and\ hashes\ to\ match\ them\ literally}
\DoxyCodeLine{\ \ \(\backslash\)\ \ \ \ \#\ space\ char}
\DoxyCodeLine{\ \ \(\backslash\)x20\ \#\ space\ char}
\DoxyCodeLine{\ \ \(\backslash\)\#\ \ \ \#\ hash\ char}
\DoxyCodeLine{\ \ \(\backslash\)s\ \ \ \#\ any\ whitespace\ char}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Since\ embedded\ strings\ are\ always\ matched\ literally,\ you\ can\ also\ match}
\DoxyCodeLine{\ \ \#\ whitespace\ by\ embedding\ it\ as\ a\ string}
\DoxyCodeLine{\ \ \$\{'\ '\}+}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Patterns\ are\ directly\ embedded,\ so\ they\ use\ free\ spacing}
\DoxyCodeLine{\ \ \$\{pattern`\(\backslash\)d\ +\ |\ [a\ -\/\ z]`\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ Interpolated\ regexes\ use\ their\ own\ flags,\ so\ they\ preserve\ their\ whitespace}
\DoxyCodeLine{\ \ \$\{/\string^Fat\ cat\$/m\}}
\DoxyCodeLine{\`{};}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Flag {\ttfamily x} is based on the Java\+Script \href{https://github.com/tc39/proposal-regexp-x-mode}{\texttt{ proposal}} for it as well as support in many other regex flavors. Note that the rules for whitespace {\itshape within character classes} are inconsistent across regex flavors, so Regex+ follows the Java\+Script proposal and the flag {\ttfamily xx} option from Perl and PCRE.
\end{DoxyNote}


{\bfseries{üëâ {\bfseries{Show more details}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item Within a character class, {\ttfamily \#} is not a special character. It matches a literal {\ttfamily \#} and doesn\textquotesingle{}t start a comment. Additionally, the only insignificant whitespace characters within character classes are {\ttfamily space} and {\ttfamily tab}.
\item Outside of character classes, insignificant whitespace includes all Unicode characters matched natively by {\ttfamily \textbackslash{}s}.
\item Whitespace and comments still separate tokens, so they aren\textquotesingle{}t {\itshape ignored}. This is important with e.\+g. {\ttfamily \textbackslash{}0 1}, which matches a null character followed by a literal {\ttfamily 1}, rather than throwing as the invalid token {\ttfamily \textbackslash{}01} would. Conversely, things like {\ttfamily \textbackslash{}x 0A} and {\ttfamily (? \+:} are errors because the whitespace splits a valid node into incomplete parts.
\item Quantifiers that follow whitespace or comments apply to the preceeding token, so {\ttfamily x +} is equivalent to {\ttfamily x+}.
\item Whitespace is not insignificant within most enclosed tokens like {\ttfamily \textbackslash{}p\{‚Ä¶\}} and {\ttfamily \textbackslash{}u\{‚Ä¶\}}. The exception is {\ttfamily \mbox{[}\textbackslash{}q\{‚Ä¶\}\mbox{]}}.
\item Line comments with {\ttfamily \#} do not extend into or beyond interpolation, so interpolation effectively acts as a terminating newline for the comment. 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25155}{}\doxysubsubsubsection{\texorpdfstring{Flag {\ttfamily n}}{Flag {\ttfamily n}}}\label{README.md_autotoc_md25155}
Emulated flag {\ttfamily n} gives you {\itshape named capture only} mode, which turns unnamed groups {\ttfamily (‚Ä¶)} into noncapturing groups. It\textquotesingle{}s always implicitly on, though it doesn\textquotesingle{}t extend into interpolated {\ttfamily Reg\+Exp} instances (to avoid changing their meaning).

Requiring the syntactically clumsy {\ttfamily (?\+:‚Ä¶)} where you could just use {\ttfamily (‚Ä¶)} hurts readability and encourages adding unneeded captures (which hurt efficiency and refactoring). Flag {\ttfamily n} fixes this, making your regexes more readable.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Doesn't\ capture}
\DoxyCodeLine{regex`\(\backslash\)b(ab|cd)\(\backslash\)b`}
\DoxyCodeLine{//\ Use\ standard\ (?<name>‚Ä¶)\ to\ capture\ as\ \`{}name`}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Flag {\ttfamily n} is based on .NET, C++, Oniguruma, PCRE, Perl, and XReg\+Exp. Most of these share the flag letter {\ttfamily n}, but the option is variously called {\itshape explicit capture}, {\itshape no auto capture}, {\itshape don\textquotesingle{}t capture group}, or {\itshape nosubs}. In Regex+, flag {\ttfamily n} also prevents using numbered backreferences to named groups, which follows the behavior of C++ and the default handling of Oniguruma and Ruby. Referring to named groups by number is a footgun, and the way that named groups are numbered is inconsistent across regex flavors.
\end{DoxyNote}
\hypertarget{README.md_autotoc_md25156}{}\doxysubsubsection{\texorpdfstring{üß© Interpolation}{üß© Interpolation}}\label{README.md_autotoc_md25156}
\hypertarget{README.md_autotoc_md25157}{}\doxysubsubsubsection{\texorpdfstring{Interpolating regexes}{Interpolating regexes}}\label{README.md_autotoc_md25157}
The meaning of flags (or their absense) on interpolated regexes is preserved. For example, with flag {\ttfamily i} ({\ttfamily ignore\+Case})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`hello-\/\$\{/world/i\}`}
\DoxyCodeLine{//\ Matches\ 'hello-\/WORLD'\ but\ not\ 'HELLO-\/WORLD'}
\DoxyCodeLine{}
\DoxyCodeLine{regex('i')`hello-\/\$\{/world/\}`}
\DoxyCodeLine{//\ Matches\ 'HELLO-\/world'\ but\ not\ 'HELLO-\/WORLD'}

\end{DoxyCode}


This is also true for other flags that can change how an inner regex is matched\+: {\ttfamily m} ({\ttfamily multiline}) and {\ttfamily s} ({\ttfamily dot\+All}).

\begin{quote}
As with all interpolation in {\ttfamily regex}, embedded regexes are sandboxed and treated as complete units. For example, a following quantifier repeats the entire embedded regex rather than just its last token, and top-\/level alternation in the embedded regex will not break out to affect the meaning of the outer regex. Numbered backreferences within embedded regexes are adjusted to work within the overall pattern. \end{quote}




{\bfseries{üëâ {\bfseries{Show more details}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item Regexes can\textquotesingle{}t be interpolated inside character classes (so {\ttfamily regex\`{}\mbox{[}\$\{/./\}\mbox{]}\`{}} is an error) because the syntax context doesn\textquotesingle{}t match. See \texorpdfstring{$\ast$}{*}\+Interpolating partial patterns\texorpdfstring{$\ast$}{*} for a way to safely embed regex syntax (rather than {\ttfamily Reg\+Exp} instances) in character classes and other edge-\/case locations with different context.
\item To change the flags used by an interpolated regex, use the built-\/in capability of {\ttfamily Reg\+Exp} to copy a regex while providing new flags. E.\+g. `new Reg\+Exp(/./, \textquotesingle{}s')\`{}. 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25158}{}\doxysubsubsubsection{\texorpdfstring{Interpolating escaped strings}{Interpolating escaped strings}}\label{README.md_autotoc_md25158}
The {\ttfamily regex} tag escapes special characters in interpolated strings (and values coerced to strings). This escaping is done in a context-\/aware and safe way that prevents changing the meaning or error status of characters outside the interpolated string.

\begin{quote}
As with all interpolation in {\ttfamily regex}, escaped strings are sandboxed and treated as complete units. For example, a following quantifier repeats the entire escaped string rather than just its last character. And if interpolating into a character class, the escaped string is treated as a flag-\/{\ttfamily v}-\/mode nested union if it contains more than one character node. \end{quote}


As a result, {\ttfamily regex} is a safe and context-\/aware alternative to Java\+Script proposal \href{https://github.com/tc39/proposal-regex-escaping}{\texttt{ {\ttfamily Reg\+Exp.\+escape}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Instead\ of}
\DoxyCodeLine{RegExp.escape(str)}
\DoxyCodeLine{//\ You\ can\ say}
\DoxyCodeLine{regex`\$\{str\}`.source}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instead\ of}
\DoxyCodeLine{new\ RegExp(`\string^(?:\$\{RegExp.escape(str)\})+\$`)}
\DoxyCodeLine{//\ You\ can\ say}
\DoxyCodeLine{regex`\string^\$\{str\}+\$`}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instead\ of}
\DoxyCodeLine{new\ RegExp(`[a-\/\$\{RegExp.escape(str)\}]`,\ 'u')\ //\ Flag\ u/v\ required\ to\ avoid\ bugs}
\DoxyCodeLine{//\ You\ can\ say}
\DoxyCodeLine{regex`[a-\/\$\{str\}]`}
\DoxyCodeLine{//\ Given\ the\ context\ at\ the\ end\ of\ a\ range,\ throws\ if\ more\ than\ one\ char\ in\ str}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instead\ of}
\DoxyCodeLine{new\ RegExp(`[\(\backslash\)\(\backslash\)w-\/-\/[\$\{RegExp.escape(str)\}]]`,\ 'v')\ //\ Set\ subtraction}
\DoxyCodeLine{//\ You\ can\ say}
\DoxyCodeLine{regex`[\(\backslash\)w-\/-\/\$\{str\}]`}

\end{DoxyCode}


Some examples of where context awareness comes into play\+:


\begin{DoxyItemize}
\item A {\ttfamily \texorpdfstring{$\sim$}{\string~}} is not escaped at the top level, but it must be escaped within character classes if it\textquotesingle{}s immediately preceded or followed by another {\ttfamily \texorpdfstring{$\sim$}{\string~}} (in or outside of the interpolation) which would turn it into a reserved Unicode\+Sets double punctuator.
\item Leading digits must be escaped if they\textquotesingle{}re preceded by a numbered backreference or {\ttfamily \textbackslash{}0}, else {\ttfamily Reg\+Exp} throws (or in Unicode-\/unaware mode they might turn into octal escapes).
\item Letters {\ttfamily A}-\/{\ttfamily Z} and {\ttfamily a}-\/{\ttfamily z} must be escaped if preceded by uncompleted token {\ttfamily \textbackslash{}c}, else they\textquotesingle{}ll convert what should be an error into a valid token that probably doesn\textquotesingle{}t match what you expect.
\item You can\textquotesingle{}t escape your way out of protecting against a preceding unescaped {\ttfamily \textbackslash{}}. Doing nothing could turn e.\+g. {\ttfamily w} into {\ttfamily \textbackslash{}w} and introduce a bug, but then escaping the first character wouldn\textquotesingle{}t prevent the {\ttfamily \textbackslash{}} from mangling it, and if you escaped the preceding {\ttfamily \textbackslash{}} elsewhere in your code you\textquotesingle{}d change its meaning.
\end{DoxyItemize}

These and other issues (including the effects of current and potential future flags like {\ttfamily x}) make escaping without context unsafe to use at arbitrary positions in a regex, or at least complicated to get right. The existing popular regex escaping libraries don\textquotesingle{}t even attempt to handle these kinds of issues.

{\ttfamily regex} solves all of this via context awareness. So instead of remembering anything above, you should just switch to always safely escaping regex syntax via {\ttfamily regex}.\hypertarget{README.md_autotoc_md25159}{}\doxysubsubsubsection{\texorpdfstring{Interpolating partial patterns}{Interpolating partial patterns}}\label{README.md_autotoc_md25159}
As an alternative to interpolating {\ttfamily Reg\+Exp} instances, you might sometimes want to interpolate partial regex patterns as strings. Some example use cases\+:


\begin{DoxyItemize}
\item Adding a pattern inside a character class (not allowed for {\ttfamily Reg\+Exp} instances since their top-\/level syntax context doesn\textquotesingle{}t match).
\item When you don\textquotesingle{}t want the pattern to specify its own, local flags.
\item Composing a dynamic number of strings escaped via {\ttfamily regex} interpolation.
\item Dynamically adding backreferences without their corresponding captures (which wouldn\textquotesingle{}t be valid as a standalone {\ttfamily Reg\+Exp}).
\end{DoxyItemize}

For all of these cases, you can `import \{pattern\} from \textquotesingle{}regex'{\ttfamily and then interpolate}pattern(str){\ttfamily to avoid escaping special characters in the string or creating an intermediary}Reg\+Exp{\ttfamily instance. You can also use}{\ttfamily pattern}‚Ä¶{\ttfamily as a tag, as shorthand for}{\ttfamily pattern(String.\+raw}‚Ä¶{\ttfamily )}\`{}.

Apart from edge cases, {\ttfamily pattern} just embeds the provided string or other value directly. But because it handles the edge cases, patterns can safely be interpolated anywhere in a regex without worrying about their meaning being changed by (or making unintended changes in meaning to) the surrounding expression.

\begin{quote}
As with all interpolation in {\ttfamily regex}, patterns are sandboxed and treated as complete units. This is relevant e.\+g. if a pattern is followed by a quantifier, if it contains top-\/level alternation, or if it\textquotesingle{}s bordered by a character class range, subtraction, or intersection operator. \end{quote}


If you want to understand the handling of interpolated patterns more deeply, let\textquotesingle{}s look at some edge cases‚Ä¶



{\bfseries{üëâ {\bfseries{Show some edge cases}}}}\begin{adjustwidth}{1em}{0em}


First, let\textquotesingle{}s consider\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`[\$\{pattern`\string^\`{}\}a]`}
\DoxyCodeLine{regex`[a\$\{pattern`\string^\`{}\}]`}

\end{DoxyCode}


Although {\ttfamily \mbox{[}\texorpdfstring{$^\wedge$}{\string^}‚Ä¶\mbox{]}} is a negated character class, {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} {\itshape within} a class doesn\textquotesingle{}t need to be escaped, even with the strict escaping rules of flags {\ttfamily u} and {\ttfamily v}.

Both of these examples therefore match a literal {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} or {\ttfamily a}. The interpolated patterns don\textquotesingle{}t change the meaning of the surrounding character class. However, note that the {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} is not simply escaped, as it would be with {\ttfamily regex\`{}\mbox{[}\$\{\textquotesingle{}\texorpdfstring{$^\wedge$}{\string^}\textquotesingle{}\}a\mbox{]}\`{}}. You can see this by the fact that embedding {\ttfamily pattern\`{}\texorpdfstring{$^\wedge$}{\string^}\texorpdfstring{$^\wedge$}{\string^}\`{}} in a character class correctly leads to an "{}invalid set operation"{} error due to the use of a reserved double-\/punctuator.

\begin{quote}
If you wanted to dynamically choose whether to negate a character class, you could put the whole character class inside the pattern. \end{quote}


Moving on, the following lines all throw because otherwise the embedded patterns would break out of their interpolation sandboxes and change the meaning of surrounding syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`(\$\{pattern(')')\})`}
\DoxyCodeLine{regex`[\$\{pattern(']')\}]`}
\DoxyCodeLine{regex`[\$\{pattern('a\(\backslash\)\(\backslash\)')\}]]`}

\end{DoxyCode}


But these are fine since they don\textquotesingle{}t break out\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`(\$\{pattern('()')\})`}
\DoxyCodeLine{regex`[\(\backslash\)w-\/-\/\$\{pattern('[\_]')\}]`}
\DoxyCodeLine{regex`[\$\{pattern('\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)')\}]`}

\end{DoxyCode}


Patterns can be embedded within any token scope\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Not\ using\ \`{}pattern`\ for\ values\ that\ are\ not\ escaped\ anyway,\ but\ the\ behavior}
\DoxyCodeLine{//\ would\ be\ the\ same\ if\ you\ did}
\DoxyCodeLine{regex`.\{1,\$\{6\}\}`}
\DoxyCodeLine{regex`\(\backslash\)p\{\$\{'Letter'\}\}`}
\DoxyCodeLine{regex`\(\backslash\)u\{\$\{'000A'\}\}`}
\DoxyCodeLine{regex`(?<\$\{'name'\}>‚Ä¶)\(\backslash\)k<\$\{'name'\}>`}
\DoxyCodeLine{regex`[a-\/\$\{'z'\}]`}
\DoxyCodeLine{regex`[\(\backslash\)w-\/-\/\$\{'\_'\}]`}

\end{DoxyCode}


But again, changing the meaning or error status of characters outside the interpolation is an error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Not\ using\ \`{}pattern`\ for\ values\ that\ are\ not\ escaped\ anyway}
\DoxyCodeLine{/*\ 1.*/\ regex`\(\backslash\)u\$\{'000A'\}`}
\DoxyCodeLine{/*\ 2.*/\ regex`\(\backslash\)u\{\$\{pattern`A\}`\}`}
\DoxyCodeLine{/*\ 3.*/\ regex`(\$\{pattern`?:`\}‚Ä¶)`}

\end{DoxyCode}


These last examples are all errors due to the corresponding reasons below\+:


\begin{DoxyEnumerate}
\item This is an uncompleted {\ttfamily \textbackslash{}u} token (which is an error) followed by the tokens {\ttfamily 0}, {\ttfamily 0}, {\ttfamily 0}, {\ttfamily A}. That\textquotesingle{}s because the interpolation doesn\textquotesingle{}t happen within an enclosed {\ttfamily \textbackslash{}u\{‚Ä¶\}} context.
\item The unescaped {\ttfamily \}} within the interpolated pattern is not allowed to break out of its sandbox.
\item The group opening {\ttfamily (} can\textquotesingle{}t be quantified with {\ttfamily ?}.
\end{DoxyEnumerate}

\begin{quote}
Characters outside the interpolation such as a preceding, unescaped {\ttfamily \textbackslash{}} or an escaped number also can\textquotesingle{}t change the meaning of tokens inside the embedded pattern. \end{quote}


And since interpolated values are handled as complete units, consider the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ This\ works\ fine}
\DoxyCodeLine{regex`[\(\backslash\)0-\/\$\{pattern`\(\backslash\)cZ`\}]`}
\DoxyCodeLine{}
\DoxyCodeLine{//\ But\ this\ is\ an\ error\ since\ you\ can't\ create\ a\ range\ from\ 'a'\ to\ the\ set\ 'de'}
\DoxyCodeLine{regex`[a-\/\$\{'de'\}]`}
\DoxyCodeLine{//\ It's\ the\ same\ as\ if\ you\ tried\ to\ use\ /[a-\/[de]]/v}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Instead,\ use\ either\ of}
\DoxyCodeLine{regex`[a-\/\$\{'d'\}\$\{'e'\}]`}
\DoxyCodeLine{regex`[a-\/\$\{'d'\}e]`}
\DoxyCodeLine{//\ These\ are\ equivalent\ to\ /[a-\/de]/\ or\ /[[a-\/d][e]]/v}

\end{DoxyCode}
 \end{adjustwidth}


\begin{quote}
Implementation note\+: {\ttfamily pattern} returns an object with a custom {\ttfamily to\+String} that simply returns {\ttfamily String(value)}. \end{quote}


\begin{quote}
Patterns are not intended as an intermediate regex type. You can think of {\ttfamily pattern} as a directive to the {\ttfamily regex} tag\+: treat this string as a partial pattern rather than a string to be matched literally. \end{quote}
\hypertarget{README.md_autotoc_md25160}{}\doxysubsubsubsection{\texorpdfstring{Interpolation principles}{Interpolation principles}}\label{README.md_autotoc_md25160}
The above descriptions of interpolation might feel complex. But there are three simple rules that guide the behavior in all cases\+:


\begin{DoxyEnumerate}
\item Interpolation never changes the meaning or error status of characters outside of the interpolation, and vice versa.
\item Interpolated values are always aware of the context of where they\textquotesingle{}re embedded.
\item When relevant, interpolated values are always treated as complete units.
\end{DoxyEnumerate}

\begin{quote}
Examples where rule \#3 is relevant\+: With following quantifiers, if they contain top-\/level alternation or numbered backreferences, or if they\textquotesingle{}re placed in a character class range or set operation. \end{quote}
\hypertarget{README.md_autotoc_md25161}{}\doxysubsubsubsection{\texorpdfstring{Interpolation contexts}{Interpolation contexts}}\label{README.md_autotoc_md25161}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Context }&\cellcolor{\tableheadbgcolor}\textbf{ Example }&\cellcolor{\tableheadbgcolor}\textbf{ String / coerced }&\cellcolor{\tableheadbgcolor}\textbf{ Pattern }&\cellcolor{\tableheadbgcolor}\textbf{ Reg\+Exp  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Context }&\cellcolor{\tableheadbgcolor}\textbf{ Example }&\cellcolor{\tableheadbgcolor}\textbf{ String / coerced }&\cellcolor{\tableheadbgcolor}\textbf{ Pattern }&\cellcolor{\tableheadbgcolor}\textbf{ Reg\+Exp  }\\\cline{1-5}
\endhead
Default &{\ttfamily regex`\$\{'\texorpdfstring{$^\wedge$}{\string^}.+\textquotesingle{}\}{\ttfamily \texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Atomized \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Escaped\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Atomized\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Atomized \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Backrefs adjusted \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Flags localized\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr valign="{}top"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}Character class\+: \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\mbox{[}‚Ä¶\mbox{]}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\mbox{[}\texorpdfstring{$^\wedge$}{\string^}‚Ä¶\mbox{]}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\mbox{[}\mbox{[}‚Ä¶\mbox{]}\mbox{]}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, etc.\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}regex}\mbox{[}\$\{\textquotesingle{}a-\/z\textquotesingle{}\}\mbox{]}{\ttfamily \texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Atomized \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Escaped\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Atomized\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}i\texorpdfstring{$>$}{>}Error\texorpdfstring{$<$}{<}/i\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr valign="{}top"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}Interval quantifier\+: \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\{‚Ä¶\}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}regex}.\{1,\$\{5\}\}{\ttfamily \texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td rowspan="{}3"{}\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed \texorpdfstring{$<$}{<}br\texorpdfstring{$>$}{>} ‚Ä¢\&nbsp;Escaped\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td rowspan="{}3"{}\texorpdfstring{$>$}{>}‚Ä¢\&nbsp;Sandboxed\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td rowspan="{}3"{}\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}i\texorpdfstring{$>$}{>}Error\texorpdfstring{$<$}{<}/i\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr valign="{}top"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}Enclosed token\+: \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\textbackslash{}p\{‚Ä¶\}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\textbackslash{}P\{‚Ä¶\}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\textbackslash{}u\{‚Ä¶\}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\mbox{[}\textbackslash{}q\{‚Ä¶\}\mbox{]}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}regex}\textbackslash{}u\{\$\{\textquotesingle{}A0\textquotesingle{}\}\}{\ttfamily \texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}/tr\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}tr valign="{}top"{}\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}Group name\+: \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}(?\texorpdfstring{$<$}{<}‚Ä¶\texorpdfstring{$>$}{>})\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\textbackslash{}k\texorpdfstring{$<$}{<}‚Ä¶\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}, \texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}\textbackslash{}g\texorpdfstring{$<$}{<}‚Ä¶\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/code\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/td\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}td\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}code\texorpdfstring{$>$}{>}regex}‚Ä¶\textbackslash{}k\texorpdfstring{$<$}{<}\$\{\textquotesingle{}a\textquotesingle{}\}\texorpdfstring{$>$}{>}\`{}}  \\\cline{1-5}
\end{longtabu}




{\bfseries{üëâ {\bfseries{Show more details}}}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item {\itshape Atomized} means that the value is treated as a complete unit; it isn\textquotesingle{}t related to the {\itshape atomic groups} feature. For example, in default context, {\ttfamily \$\{foo\}\texorpdfstring{$\ast$}{*}} matches any number of {\ttfamily foo}; not just its last token. In character class context, subtraction and intersection operators apply to the entire atom.
\item {\itshape Sandboxed} means that the value can\textquotesingle{}t change the meaning or error status of characters outside of the interpolation, and vice versa.
\item Character classes have a sub-\/context on the borders of ranges. Only one character node (e.\+g. {\ttfamily a} or {\ttfamily \textbackslash{}u0061}) can be interpolated at these positions.
\item Numbers interpolated into an enclosed {\ttfamily \textbackslash{}u\{‚Ä¶\}} context are converted to hexadecimal.
\item The implementation details vary for how {\ttfamily regex} accomplishes sandboxing and atomization, based on the details of the specific pattern. But the concepts should always hold up. 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25162}{}\doxysubsubsection{\texorpdfstring{üî© Options}{üî© Options}}\label{README.md_autotoc_md25162}
Typically, {\ttfamily regex} is used as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex`‚Ä¶`\ //\ Without\ flags}
\DoxyCodeLine{regex('gi')`‚Ä¶`\ //\ With\ flags}

\end{DoxyCode}


However, several options are available that can be provided via an options object in place of the flags argument. These options aren\textquotesingle{}t usually needed, and are primarily intended for use within other tools.

Following are the available options and their default values\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regex(\{}
\DoxyCodeLine{\ \ flags:\ '',}
\DoxyCodeLine{\ \ subclass:\ false,}
\DoxyCodeLine{\ \ plugins:\ [],}
\DoxyCodeLine{\ \ unicodeSetsPlugin:\ <function>,}
\DoxyCodeLine{\ \ disable:\ \{}
\DoxyCodeLine{\ \ \ \ x:\ false,}
\DoxyCodeLine{\ \ \ \ n:\ false,}
\DoxyCodeLine{\ \ \ \ v:\ false,}
\DoxyCodeLine{\ \ \ \ atomic:\ false,}
\DoxyCodeLine{\ \ \ \ subroutines:\ false,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ force:\ \{}
\DoxyCodeLine{\ \ \ \ v:\ false,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})`‚Ä¶`;}

\end{DoxyCode}




{\bfseries{üëâ {\bfseries{Show details for each option}}}}\begin{adjustwidth}{1em}{0em}


{\bfseries{{\ttfamily flags}}} ‚Äî For providing flags when using an options object.

{\bfseries{{\ttfamily subclass}}} ‚Äî When {\ttfamily true}, the resulting regex is constructed using a {\ttfamily Reg\+Exp} subclass that avoids edge case issues with numbered backreferences. Without subclassing, submatches referenced {\itshape by number} from outside of the regex (e.\+g. in replacement strings) might reference the wrong values, because {\ttfamily regex}\textquotesingle{}s emulation of extended syntax might add unnamed captures to generated regex source that can affect group numbering.

Context\+: {\ttfamily regex}\textquotesingle{}s implicit flag {\ttfamily n} ({\itshape named capture only} mode) means that all captures have names, so normally there\textquotesingle{}s no need to reference submatches by number. In fact, flag {\ttfamily n} {\itshape prevents} you from doing so within the regex. And even in edge cases (such as when interpolating {\ttfamily Reg\+Exp} instances with numbered backreferences, or when flag {\ttfamily n} is explicitly disabled), any numbered backreferences within the regex are automatically adjusted to work correctly. However, issues can arise if you reference submatches by number (instead of their group names) from outside of the regex. Setting {\ttfamily subclass\+: true} resolves this, since the subclass knows about captures that are added only to emulate extended syntax, and automatically adjusts match results in all contexts.

\begin{quote}
This option isn\textquotesingle{}t enabled by default because it would prevent Regex+\textquotesingle{}s Babel plugin from emitting regex literals. It also has a tiny performance cost, and is rarely needed. The primary use case is tools that use {\ttfamily regex} internally with flag {\ttfamily n} disabled. \end{quote}


{\bfseries{{\ttfamily plugins}}} ‚Äî An array of functions. Plugins are called in order, after applying emulated flags and interpolation, but before the built-\/in plugins for extended syntax. This means that plugins can output extended syntax like atomic groups and subroutines. Plugins are expected to return an object with a string property {\ttfamily pattern}, and are called with two arguments\+:


\begin{DoxyEnumerate}
\item The pattern, as processed so far by preceding plugins, etc.
\item An object with a {\ttfamily flags} property that includes the native (non-\/emulated) flags that will be used by the regex.
\end{DoxyEnumerate}

The final result after running all plugins is provided to the {\ttfamily Reg\+Exp} constructor.

\begin{quote}
The tiny \href{https://github.com/slevithan/regex-utilities}{\texttt{ regex-\/utilities}} library is intended for use in plugins, and can make it easier to work with regex syntax. \end{quote}


{\bfseries{{\ttfamily unicode\+Sets\+Plugin}}} ‚Äî A plugin function that\textquotesingle{}s used when flag {\ttfamily v} isn\textquotesingle{}t supported natively, or when implicit flag {\ttfamily v} is disabled. The default value is a built-\/in function that provides basic backward compatibility by applying flag {\ttfamily v}\textquotesingle{}s escaping rules and throwing on use of {\ttfamily v}-\/only syntax (nested character classes, set subtraction/intersection, etc.).


\begin{DoxyItemize}
\item Setting {\ttfamily unicode\+Sets\+Plugin} to {\ttfamily null} prevents {\ttfamily regex} from applying flag {\ttfamily v}\textquotesingle{}s escaping rules. This can be useful in combination with option {\ttfamily disable\+: \{v\+: true\}} for tools that want to use {\ttfamily regex}\textquotesingle{}s extended syntax and/or flags but need to accept input with flag {\ttfamily u}\textquotesingle{}s escaping rules.
\item Regex+ is not primarily a backward compatibility library, so in order to remain lightweight, it doesn\textquotesingle{}t transpile flag {\ttfamily v}\textquotesingle{}s new features out of the box. By replacing the default function, you can add backward compatible support for these features. See also\+: \texorpdfstring{$\ast$}{*}\+Compatibility\texorpdfstring{$\ast$}{*}.
\item This plugin runs last, which means it\textquotesingle{}s possible to wrap an existing library (e.\+g. \href{https://github.com/mathiasbynens/regexpu-core}{\texttt{ regexpu-\/core}}, used by Babel to \href{https://babel.dev/docs/babel-plugin-transform-unicode-sets-regex}{\texttt{ transpile {\ttfamily v}}}), without the library needing to understand {\ttfamily regex}\textquotesingle{}s extended syntax.
\end{DoxyItemize}

{\bfseries{{\ttfamily disable}}} ‚Äî A set of options that can be individually disabled by setting their values to {\ttfamily true}.


\begin{DoxyItemize}
\item {\bfseries{{\ttfamily x}}} ‚Äî Disables implicit, emulated flag {\ttfamily x}.
\item {\bfseries{{\ttfamily n}}} ‚Äî Disables implicit, emulated flag {\ttfamily n}. Note that, although it\textquotesingle{}s safe to use unnamed captures and numbered backreferences within a regex when flag {\ttfamily n} is disabled, referencing submatches by number from {\itshape outside} a regex (e.\+g. in replacement strings) can result in incorrect values because extended syntax might add additional unnamed captures to generated regex source. It\textquotesingle{}s therefore recommended to enable the {\ttfamily subclass} option when disabling {\ttfamily n}.
\item {\bfseries{{\ttfamily v}}} ‚Äî Disables implicit flag {\ttfamily v} even when it\textquotesingle{}s supported natively, resulting in flag {\ttfamily u} being added instead (in combination with the {\ttfamily unicode\+Sets\+Plugin}).
\item {\bfseries{{\ttfamily atomic}}} ‚Äî Disables atomic groups and possessive quantifiers, resulting in a syntax error if they\textquotesingle{}re used.
\item {\bfseries{{\ttfamily subroutines}}} ‚Äî Disables subroutines and subroutine definition groups, resulting in a syntax error if they\textquotesingle{}re used.
\end{DoxyItemize}

{\bfseries{{\ttfamily force}}} ‚Äî Options that, if set to {\ttfamily true}, override default settings (as well as options set on the {\ttfamily disable} object).


\begin{DoxyItemize}
\item {\bfseries{{\ttfamily v}}} ‚Äî Forces the use of flag {\ttfamily v} even when it\textquotesingle{}s not supported natively (resulting in an error). 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25163}{}\doxysubsubsubsection{\texorpdfstring{Returning a string}{Returning a string}}\label{README.md_autotoc_md25163}
Function {\ttfamily rewrite} returns an object with properties {\ttfamily pattern} and {\ttfamily flags} as strings, rather than returning a {\ttfamily Reg\+Exp} instance. This can be useful when you want to apply postprocessing to the output.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{rewrite\}\ from\ 'regex';}
\DoxyCodeLine{rewrite('\string^\ (ab\ |\ cd)',\ \{flags:\ 'm'\});}
\DoxyCodeLine{//\ ‚Üí\ \{pattern:\ '\string^(?:ab|cd)',\ flags:\ 'mv'\}}

\end{DoxyCode}


{\ttfamily rewrite} shares all of {\ttfamily regex}\textquotesingle{}s options (described above) except {\ttfamily subclass}. Providing the resulting {\ttfamily pattern} and {\ttfamily flags} to the {\ttfamily Reg\+Exp} constructor produces the same result as using the {\ttfamily regex} tag.

\begin{quote}
Since {\ttfamily rewrite} isn\textquotesingle{}t a template tag, it doesn\textquotesingle{}t provide context-\/aware interpolation and doesn\textquotesingle{}t automatically handle input as a raw string (you need to escape your backslashes). \end{quote}
\hypertarget{README.md_autotoc_md25164}{}\doxysubsubsection{\texorpdfstring{‚ö° Performance}{‚ö° Performance}}\label{README.md_autotoc_md25164}
{\ttfamily regex} transpiles its input to native {\ttfamily Reg\+Exp} instances. Therefore regexes created by {\ttfamily regex} perform equally as fast as native regexes. The use of {\ttfamily regex} can also be transpiled via a \href{https://github.com/slevithan/babel-plugin-transform-regex}{\texttt{ Babel plugin}}, avoiding the tiny overhead of transpiling at runtime.

For regexes that rely on or have the potential to trigger heavy backtracking, you can dramatically improve beyond native performance via {\ttfamily regex}\textquotesingle{}s atomic groups and possessive quantifiers.\hypertarget{README.md_autotoc_md25165}{}\doxysubsubsection{\texorpdfstring{ü™∂ Compatibility}{ü™∂ Compatibility}}\label{README.md_autotoc_md25165}
{\ttfamily regex} uses flag {\ttfamily v} ({\ttfamily unicode\+Sets}) when it\textquotesingle{}s supported natively. Flag {\ttfamily v} is supported by Node.\+js 20 and 2023-\/era browsers (\href{https://caniuse.com/mdn-javascript_builtins_regexp_unicodesets}{\texttt{ compat table}}). When {\ttfamily v} isn\textquotesingle{}t available, flag {\ttfamily u} is automatically used instead while enforcing {\ttfamily v}\textquotesingle{}s escaping rules, which extends support to Node.\+js 14 and 2020-\/era browsers or earlier. The exception is Safari, which is supported starting with v16.\+4 (released 2023-\/03-\/27).

The following edge cases rely on modern Java\+Script features\+:


\begin{DoxyItemize}
\item To ensure atomization, {\ttfamily regex} uses nested character classes (which require flag {\ttfamily v}) when interpolating more than one token at a time {\itshape inside character classes}. A descriptive error is thrown when this isn\textquotesingle{}t supported, which you can avoid by not interpolating multi-\/token patterns/strings into character classes. There\textquotesingle{}s also an easy workaround\+: put the whole character class in a {\ttfamily pattern} and interpolate a string into the pattern.
\item Using an interpolated {\ttfamily Reg\+Exp} instance with a different value for flag {\ttfamily i} than its outer regex relies on \href{https://github.com/tc39/proposal-regexp-modifiers}{\texttt{ pattern modifiers}}, an ES2025 feature available in Node.\+js 23, Chrome/\+Edge 125, Firefox 132, and Opera 111. A descriptive error is thrown in environments without support, which you can avoid by aligning the use of flag {\ttfamily i} on inner and outer regexes. Local-\/only application of other flags doesn\textquotesingle{}t rely on this feature.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md25166}{}\doxysubsubsection{\texorpdfstring{üôã FAQ}{üôã FAQ}}\label{README.md_autotoc_md25166}


{\bfseries{{\bfseries{How are you comparing regex flavors?}}}}\begin{adjustwidth}{1em}{0em}


The claim that Java\+Script with the Regex+ library is among the best regex flavors is based on a holistic view. Following are some of the aspects considered\+:


\begin{DoxyEnumerate}
\item {\bfseries{Performance\+:}} An important aspect, but not the main one since mature regex implementations are generally pretty fast. Java\+Script is strong on regex performance (at least considering V8\textquotesingle{}s Irregexp engine and Java\+Script\+Core), but it uses a backtracking engine that\textquotesingle{}s missing any syntax for backtracking control ‚Äî a major limitation that makes Re\+DoS vulnerability more common. {\ttfamily regex} adds atomic groups to native Java\+Script regexes, which is a solution to this problem and therefore can dramatically improve performance.
\item {\bfseries{Support for advanced features}} that handle common or important use cases\+: Here, Java\+Script stepped up its game with ES2018 and ES2024. Java\+Script is now best in class for some features like lookbehind (with it\textquotesingle{}s infinite-\/length support) and Unicode properties (with multicharacter "{}properties of strings"{}, set subtraction and intersection, and script extensions). These features are either not supported or not as robust in many other flavors.
\item {\bfseries{Ability to write readable and maintainable patterns\+:}} Here, native Java\+Script has long been the worst of the major flavors, since it lacks the {\ttfamily x} (extended) flag that allows insignificant whitespace and comments. {\ttfamily regex} not only adds {\ttfamily x} (and turns it on by default), but it additionally adds regex subroutines and subroutine definition groups (matched only by PCRE and Perl, although some other flavors have inferior versions) which enable powerful subpattern composition and reuse. And it includes context-\/aware interpolation of {\ttfamily Reg\+Exp} instances, escaped strings, and partial patterns, all of which can also help with composition and readability. 
\end{DoxyEnumerate}\end{adjustwidth}




{\bfseries{{\bfseries{Can {\ttfamily regex} be called as a function instead of using it with backticks?}}}}\begin{adjustwidth}{1em}{0em}


Yes, but you might not need to. If you want to use {\ttfamily regex} with dynamic input, you can interpolate a {\ttfamily pattern} call as the full expression. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{regex,\ pattern\}\ from\ 'regex';}
\DoxyCodeLine{const\ str\ =\ '‚Ä¶';}
\DoxyCodeLine{const\ re\ =\ regex('g')`\$\{pattern(str)\}`;}

\end{DoxyCode}


If you prefer to call {\ttfamily regex} as a function (rather than using it as a template tag), that requires explicitly providing the raw template strings array, as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{regex\}\ from\ 'regex';}
\DoxyCodeLine{const\ str\ =\ '‚Ä¶';}
\DoxyCodeLine{const\ re\ =\ regex('g')(\{raw:\ [str]\});}

\end{DoxyCode}
 \end{adjustwidth}




{\bfseries{{\bfseries{Why are flags added via {\ttfamily regex(\textquotesingle{}g\textquotesingle{}){\ttfamily ‚Ä¶}} rather than {\ttfamily regex{\ttfamily /‚Ä¶/g}}?}}}}\begin{adjustwidth}{1em}{0em}


The alternative syntax isn\textquotesingle{}t used because it has several disadvantages\+:


\begin{DoxyItemize}
\item It doesn\textquotesingle{}t match the {\ttfamily Reg\+Exp} constructor\textquotesingle{}s syntax.
\item It doesn\textquotesingle{}t match regex literal syntax either, since there are no multiline regex literals (and they\textquotesingle{}re not planned for the future), plus regex literals don\textquotesingle{}t allow unescaped {\ttfamily /} outside of character classes.
\item Flags-\/up-\/front can be more readable, especially with long or multiline regexes that make flags easy to miss when they\textquotesingle{}re at the end. And since some flags change the meaning of regex syntax, it can help to read them first.
\item It would most likely be incompatible if a standardized regex template tag was added to the Java\+Script language in the future. To date, TC39 discussions about a standardized tag for regexes have not favored the {\ttfamily \`{}/‚Ä¶/g\`{}} format. 
\end{DoxyItemize}\end{adjustwidth}
\hypertarget{README.md_autotoc_md25167}{}\doxysubsubsection{\texorpdfstring{üè∑Ô∏è About}{üè∑Ô∏è About}}\label{README.md_autotoc_md25167}
Regex+ was created by \href{https://github.com/slevithan}{\texttt{ Steven Levithan}} and \href{https://github.com/slevithan/regex/graphs/contributors}{\texttt{ contributors}}. Inspiration included \href{https://github.com/PCRE2Project/pcre2}{\texttt{ PCRE}}, \href{https://github.com/slevithan/xregexp}{\texttt{ XReg\+Exp}}, and \href{https://github.com/mikesamuel/regexp-make-js}{\texttt{ regexp-\/make-\/js}}.

If you want to support this project, I\textquotesingle{}d love your help by contributing improvements, sharing it with others, or \href{https://github.com/sponsors/slevithan}{\texttt{ sponsoring}} ongoing development.

¬© 2024‚Äìpresent. MIT License. 