\doxysection{node\+\_\+modules/check-\/types Directory Reference}
\hypertarget{dir_d1e6131d7a6ede106e8fe193766f1dfe}{}\label{dir_d1e6131d7a6ede106e8fe193766f1dfe}\index{node\_modules/check-\/types Directory Reference@{node\_modules/check-\/types Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://gitlab.com/philbooth/check-types.js/pipelines}{\texttt{ }} \href{https://www.npmjs.com/package/check-types}{\texttt{ }} \href{https://www.npmjs.com/package/check-types}{\texttt{ }} \href{https://opensource.org/licenses/MIT}{\texttt{ }}

A little Java\+Script library for asserting types and values, with zero dependencies.


\begin{DoxyItemize}
\item Why would I want that?
\item How little is it?
\item How do I install it?
\item How do I use it?
\begin{DoxyItemize}
\item Loading the library
\item Calling the exported functions
\begin{DoxyItemize}
\item General predicates
\item String predicates
\item Number predicates
\item Boolean predicates
\item Object predicates
\item Array predicates
\item Date predicates
\item Function predicates
\item Modifiers
\item Batch operations
\end{DoxyItemize}
\item Some examples
\end{DoxyItemize}
\item Are there Type\+Script definitions?
\item Where can I use it?
\item What changed from 10.x to 11.x?
\item What changed from 9.x to 10.x?
\item What changed from 8.x to 9.x?
\item What changed from 7.x to 8.x?
\item What changed from 6.x to 7.x?
\item What changed from 5.x to 6.x?
\item What changed from 4.x to 5.x?
\item What changed from 3.x to 4.x?
\item What changed from 2.x to 3.x?
\item What changed from 1.x to 2.x?
\item What changed from 0.x to 1.x?
\item How do I set up the build environment?
\item What license is it released under?
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10110}{}\doxysubsection{\texorpdfstring{Why would I want that?}{Why would I want that?}}\label{README.md_autotoc_md10110}
Writing explicit conditions in your functions to check arguments and throw errors is a task that swiftly becomes tiresome and adds complexity to your codebase.

The purpose of check-\/types.\+js is to remove this burden from Java\+Script application developers in an efficient and robust manner, abstracted by a simple API.\hypertarget{README.md_autotoc_md10111}{}\doxysubsection{\texorpdfstring{How little is it?}{How little is it?}}\label{README.md_autotoc_md10111}
25 kb unminified with comments, 7.\+4 kb minified, 2.\+5 kb minified + gzipped.\hypertarget{README.md_autotoc_md10112}{}\doxysubsection{\texorpdfstring{How do I install it?}{How do I install it?}}\label{README.md_autotoc_md10112}
Via npm\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ i\ check-\/types\ -\/-\/save}

\end{DoxyCode}


Or if you just want the git repo\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git\ clone\ git@gitlab.com:philbooth/check-\/types.js.git}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md10113}{}\doxysubsection{\texorpdfstring{How do I use it?}{How do I use it?}}\label{README.md_autotoc_md10113}
\hypertarget{README.md_autotoc_md10114}{}\doxysubsubsection{\texorpdfstring{Loading the library}{Loading the library}}\label{README.md_autotoc_md10114}
If you are running in Node.\+js or a Common\+JS environment, you can {\ttfamily require} check-\/types like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ check\ =\ require('check-\/types');}

\end{DoxyCode}


It also the supports the AMD-\/style format preferred by Require.\+js.

If you are including check-\/types.\+js with an HTML {\ttfamily \texorpdfstring{$<$}{<}script\texorpdfstring{$>$}{>}} tag, or neither of the above environments are detected, it will export the interface globally as {\ttfamily check}.\hypertarget{README.md_autotoc_md10115}{}\doxysubsubsection{\texorpdfstring{Calling the exported functions}{Calling the exported functions}}\label{README.md_autotoc_md10115}
Once you\textquotesingle{}ve loaded the library in your application, a whole bunch of functions are available to call.

Most of the functions are predicates, which can be executed in a number of different contexts\+:


\begin{DoxyItemize}
\item {\ttfamily check.\+xxx(thing)}\+: These functions are basic predicates, returning true or false depending on the type and value of {\ttfamily thing}.
\item {\ttfamily check.\+not.\+xxx(thing)}\+: The {\ttfamily not} modifier negates predicates, returning {\ttfamily true} if the predicate returns {\ttfamily false} and {\ttfamily false} if the predicate returns {\ttfamily true}. It is also itself a function, which simply returns the negation of its argument.
\item {\ttfamily check.\+maybe.\+xxx(thing)}\+: The {\ttfamily maybe} modifier tweaks predicates to return {\ttfamily true} if {\ttfamily thing} is {\ttfamily null} or {\ttfamily undefined}, otherwise their normal result is returned. It is also itself a function, which returns {\ttfamily true} when its argument is {\ttfamily null} or {\ttfamily undefined}, otherwise it returns its argument.
\item {\ttfamily check.\+assert.\+xxx(thing, message)}\+: The {\ttfamily assert} modifier changes predicates to throw when their result is {\ttfamily false}, otherwise it returns {\ttfamily thing}. It can be applied to the {\ttfamily not} and {\ttfamily maybe} modifiers using the forms {\ttfamily check.\+assert.\+not.\+xxx(thing, message)} and {\ttfamily check.\+assert.\+maybe.\+xxx(thing, message)}. It is also itself a function, which simply throws when its argument is false.
\item {\ttfamily check.\+array.\+of.\+xxx(thing)}\+: The {\ttfamily array.\+of} modifier first checks that it is operating on an array and then applies the modified predicate to each item of the array. If the predicate fails for any item, it returns {\ttfamily false}, otherwise it returns {\ttfamily true}. It can also be prefixed by other modifiers, so {\ttfamily check.\+maybe.\+array.\+of}, {\ttfamily check.\+not.\+array.\+of}, {\ttfamily check.\+assert.\+array.\+of}, {\ttfamily check.\+assert.\+maybe.\+array.\+of} and {\ttfamily check.\+assert.\+not.\+array.\+of} all work as you would expect them to.
\item {\ttfamily check.\+array\+Like.\+of.\+xxx(thing)}\+: The {\ttfamily array\+Like.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on array-\/like objects.
\item {\ttfamily check.\+iterable.\+of.\+xxx(thing)}\+: The {\ttfamily iterable.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on iterables.
\item {\ttfamily check.\+object.\+of.\+xxx(thing)}\+: The {\ttfamily object.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on an object\textquotesingle{}s properties.
\end{DoxyItemize}

Additionally, there are some batch operations to help you apply predicates to each value of an array or object. These are implemented by {\ttfamily check.\+map}, {\ttfamily check.\+any} and {\ttfamily check.\+all}.\hypertarget{README.md_autotoc_md10116}{}\doxysubsubsubsection{\texorpdfstring{General predicates}{General predicates}}\label{README.md_autotoc_md10116}

\begin{DoxyItemize}
\item {\ttfamily check.\+equal(thing, thang)}\+: Returns {\ttfamily true} if {\ttfamily thing === thang}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+null(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is {\ttfamily null}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+undefined(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is {\ttfamily undefined}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+assigned(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is not {\ttfamily null} or {\ttfamily undefined}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+primitive(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a primitive type, {\ttfamily false} otherwise. Primitive types are {\ttfamily null}, {\ttfamily undefined}, booleans, numbers, strings and symbols.
\item {\ttfamily check.\+has\+Length(thing, value)}\+: Returns {\ttfamily true} if {\ttfamily thing} has a length property that equals {\ttfamily value}, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10117}{}\doxysubsubsubsection{\texorpdfstring{String predicates}{String predicates}}\label{README.md_autotoc_md10117}

\begin{DoxyItemize}
\item {\ttfamily check.\+string(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a string, {\ttfamily false} otherwise.
\item {\ttfamily check.\+empty\+String(thing, options)}\+: Returns {\ttfamily true} if {\ttfamily thing} is the empty string, {\ttfamily false} otherwise.
\item {\ttfamily check.\+non\+Empty\+String(thing, options)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a non-\/empty string, {\ttfamily false} otherwise.
\item {\ttfamily check.\+contains(string, substring)}\+: Returns {\ttfamily true} if {\ttfamily string} contains {\ttfamily substring}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+in(substring, string)}\+: Returns {\ttfamily true} if {\ttfamily substring} is in {\ttfamily string}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+match(string, regex)}\+: Returns {\ttfamily true} if {\ttfamily string} matches {\ttfamily regex}, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10118}{}\doxysubsubsubsection{\texorpdfstring{Number predicates}{Number predicates}}\label{README.md_autotoc_md10118}

\begin{DoxyItemize}
\item {\ttfamily check.\+number(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number, {\ttfamily false} otherwise. Note that {\ttfamily NaN}, {\ttfamily Number.\+POSITIVE\+\_\+\+INFINITY} and {\ttfamily Number.\+NEGATIVE\+\_\+\+INFINITY} are not considered numbers here.
\item {\ttfamily check.\+integer(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an integer, {\ttfamily false} otherwise.
\item {\ttfamily check.\+float(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a non-\/integer number, {\ttfamily false} otherwise.
\item {\ttfamily check.\+zero(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is zero, {\ttfamily false} otherwise.
\item {\ttfamily check.\+one(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is one, {\ttfamily false} otherwise.
\item {\ttfamily check.\+infinity(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is positive or negative infinity, {\ttfamily false} otherwise.
\item {\ttfamily check.\+greater(thing, value)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number greater than {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+greater\+Or\+Equal(thing, value)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number greater than or equal to {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+less(thing, value)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number less than {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+less\+Or\+Equal(thing, value)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number less than or equal to {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+between(thing, a, b)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number between {\ttfamily a} and {\ttfamily b} (excluding {\ttfamily a} and {\ttfamily b}), {\ttfamily false} otherwise. The arguments {\ttfamily a} and {\ttfamily b} may be in any order, it doesn\textquotesingle{}t matter which is greater.
\item {\ttfamily check.\+in\+Range(thing, a, b)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number in the range {\ttfamily a} .. {\ttfamily b} (including {\ttfamily a} and {\ttfamily b}), {\ttfamily false} otherwise. The arguments {\ttfamily a} and {\ttfamily b} may be in any order, it doesn\textquotesingle{}t matter which is greater.
\item {\ttfamily check.\+positive(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number greater than zero, {\ttfamily false} otherwise.
\item {\ttfamily check.\+negative(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a number less than zero, {\ttfamily false} otherwise.
\item {\ttfamily check.\+odd(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an odd number, {\ttfamily false} otherwise.
\item {\ttfamily check.\+even(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an even number, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10119}{}\doxysubsubsubsection{\texorpdfstring{Boolean predicates}{Boolean predicates}}\label{README.md_autotoc_md10119}

\begin{DoxyItemize}
\item {\ttfamily check.\+boolean(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a boolean, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10120}{}\doxysubsubsubsection{\texorpdfstring{Object predicates}{Object predicates}}\label{README.md_autotoc_md10120}

\begin{DoxyItemize}
\item {\ttfamily check.\+object(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a plain-\/old Java\+Script object, {\ttfamily false} otherwise.
\item {\ttfamily check.\+empty\+Object(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an empty object, {\ttfamily false} otherwise.
\item {\ttfamily check.\+non\+Empty\+Object(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a non-\/empty object, {\ttfamily false} otherwise.
\item {\ttfamily check.\+thenable(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} has a {\ttfamily then} method, {\ttfamily false} otherwise.
\item {\ttfamily check.\+instance\+Strict(thing, prototype)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an instance of {\ttfamily prototype}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+instance(thing, prototype)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an instance of {\ttfamily prototype}, {\ttfamily false} otherwise. Falls back to testing {\ttfamily constructor.\+name} and {\ttfamily Object.\+prototype.\+to\+String} if the {\ttfamily instanceof} test fails.
\item {\ttfamily check.\+contains(object, value)}\+: Returns {\ttfamily true} if {\ttfamily object} contains {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+in(value, object)}\+: Returns {\ttfamily true} if {\ttfamily value} is in {\ttfamily object}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+contains\+Key(object, key)}\+: Returns {\ttfamily true} if {\ttfamily object} contains key {\ttfamily key}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+key\+In(key, object)}\+: Returns {\ttfamily true} if key {\ttfamily key} is in {\ttfamily object}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+like(thing, duck)}\+: Duck-\/typing checker. Returns {\ttfamily true} if {\ttfamily thing} has all of the properties of {\ttfamily duck}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+identical(thing, thang)}\+: Deep equality checker. Returns {\ttfamily true} if {\ttfamily thing} has all of the same values as {\ttfamily thang}, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10121}{}\doxysubsubsubsection{\texorpdfstring{Array predicates}{Array predicates}}\label{README.md_autotoc_md10121}

\begin{DoxyItemize}
\item {\ttfamily check.\+array(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an array, {\ttfamily false} otherwise.
\item {\ttfamily check.\+empty\+Array(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is an empty array, {\ttfamily false} otherwise.
\item {\ttfamily check.\+non\+Empty\+Array(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a non-\/empty array, {\ttfamily false} otherwise.
\item {\ttfamily check.\+array\+Like(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} has a numeric length property, {\ttfamily false} otherwise.
\item {\ttfamily check.\+iterable(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} implements the iterable protocol, {\ttfamily false} otherwise. In pre-\/\+ES6 environments, this predicate falls back to {\ttfamily array\+Like} behaviour.
\item {\ttfamily check.\+contains(array, value)}\+: Returns {\ttfamily true} if {\ttfamily array} contains {\ttfamily value}, {\ttfamily false} otherwise.
\item {\ttfamily check.\+in(value, array)}\+: Returns {\ttfamily true} if {\ttfamily value} is in {\ttfamily array}, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10122}{}\doxysubsubsubsection{\texorpdfstring{Date predicates}{Date predicates}}\label{README.md_autotoc_md10122}

\begin{DoxyItemize}
\item {\ttfamily check.\+date(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a valid date, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10123}{}\doxysubsubsubsection{\texorpdfstring{Function predicates}{Function predicates}}\label{README.md_autotoc_md10123}

\begin{DoxyItemize}
\item {\ttfamily check.\+function(thing)}\+: Returns {\ttfamily true} if {\ttfamily thing} is a function, {\ttfamily false} otherwise.
\item {\ttfamily check.\+throws(() =\texorpdfstring{$>$}{>} thing())}\+: Returns {\ttfamily true} if {\ttfamily thing} is a function that throws, {\ttfamily false} otherwise.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10124}{}\doxysubsubsubsection{\texorpdfstring{Modifiers}{Modifiers}}\label{README.md_autotoc_md10124}

\begin{DoxyItemize}
\item {\ttfamily check.\+not(value)}\+: Returns the negation of {\ttfamily value}.
\item {\ttfamily check.\+not.\+xxx(...)}\+: Returns the negation of the predicate.
\item {\ttfamily check.\+maybe(value)}\+: Returns {\ttfamily true} if {\ttfamily value} is {\ttfamily null} or {\ttfamily undefined}, otherwise it returns {\ttfamily value}.
\item {\ttfamily check.\+maybe.\+xxx(...)}\+: Returns {\ttfamily true} if {\ttfamily thing} is {\ttfamily null} or {\ttfamily undefined}, otherwise it propagates the return value from its predicate.
\item {\ttfamily check.\+array.\+of.\+xxx(value)}\+: Returns {\ttfamily true} if {\ttfamily value} is an array and the predicate is true for every item. Also works with the {\ttfamily not} and {\ttfamily maybe} modifiers.
\item {\ttfamily check.\+array\+Like.\+of.\+xxx(thing)}\+: The {\ttfamily array\+Like.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on array-\/like objects.
\item {\ttfamily check.\+iterable.\+of.\+xxx(thing)}\+: The {\ttfamily iterable.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on iterables.
\item {\ttfamily check.\+object.\+of.\+xxx(thing)}\+: The {\ttfamily object.\+of} modifier is synonymous with {\ttfamily array.\+of}, except it operates on an object\textquotesingle{}s properties.
\item {\ttfamily check.\+assert(value, message, Error\+Type)}\+: Throws a {\ttfamily Type\+Error} if {\ttfamily value} is {\itshape falsy}, otherwise it returns {\ttfamily value}. {\ttfamily message} and {\ttfamily Error\+Type} are optional arguments that control the message and type of the thrown error object.
\item {\ttfamily check.\+assert.\+xxx(...)}\+: Throws a {\ttfamily Type\+Error} if the predicate returns false, otherwise it returns the subject value. The last two arguments are an optional message and error type that control the message and type of the thrown error object. Also works with the {\ttfamily not}, {\ttfamily maybe} and {\ttfamily ...of} modifiers.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10125}{}\doxysubsubsubsection{\texorpdfstring{Batch operations}{Batch operations}}\label{README.md_autotoc_md10125}

\begin{DoxyItemize}
\item {\ttfamily check.\+map(things, predicates)}\+: Maps each value from the {\ttfamily things} array or object to the corresponding predicate and returns the array or object of results. Passing a single predicate instead of an array or object maps all of the values to the same predicate.
\item {\ttfamily check.\+all(results)}\+: Returns {\ttfamily true} if all the result values are true in an array or object returned by {\ttfamily map}.
\item {\ttfamily check.\+any(results)}\+: Returns {\ttfamily true} if any result value is true in an array or object returned by {\ttfamily map}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md10126}{}\doxysubsubsection{\texorpdfstring{Some examples}{Some examples}}\label{README.md_autotoc_md10126}

\begin{DoxyCode}{0}
\DoxyCodeLine{check.even(3);}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.not.even(3);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.maybe.even(null);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.assert.even(3);}
\DoxyCodeLine{//\ Throws\ \`{}new\ TypeError('assert\ failed:\ expected\ 3\ to\ be\ even\ number')`}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.assert.not.even(3);}
\DoxyCodeLine{//\ Doesn't\ throw}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.assert.maybe.even(null);}
\DoxyCodeLine{//\ Doesn't\ throw}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.contains('foo',\ 'oo')}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.contains('foe',\ 'oo')}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.contains(['foo',\ 'bar'],\ 'bar')}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.contains(['foo',\ 'bar'],\ 'ar')}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.like(\{\ foo:\ 'bar'\ \},\ \{\ foo:\ 'baz'\ \});}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.like(\{\ foo:\ 'bar'\ \},\ \{\ baz:\ 'qux'\ \});}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.array.of.nonEmptyString([\ 'foo',\ 'bar'\ ]);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.array.of.nonEmptyString([\ 'foo',\ 'bar',\ ''\ ]);}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.array.of.inRange([\ 0,\ 1,\ 2\ ],\ 0,\ 2);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.array.of.inRange([\ 0,\ 1,\ 2\ ],\ 0,\ 1);}
\DoxyCodeLine{//\ Returns\ false}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.assert(myFunction(),\ 'Something\ went\ wrong',\ CustomError);}
\DoxyCodeLine{//\ Throws\ \`{}new\ CustomError('Something\ went\ wrong')`\ if\ myFunction\ returns\ \`{}false`}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.map([\ 'foo',\ 'bar',\ ''\ ],\ check.nonEmptyString);}
\DoxyCodeLine{//\ Returns\ [\ true,\ true,\ false\ ]}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.map(\{}
\DoxyCodeLine{\ \ \ \ foo:\ 2,}
\DoxyCodeLine{\ \ \ \ bar:\ \{\ baz:\ 'qux'\ \}}
\DoxyCodeLine{\},\ \{}
\DoxyCodeLine{\ \ \ \ foo:\ check.odd,}
\DoxyCodeLine{\ \ \ \ bar:\ \{\ baz:\ check.nonEmptyString\ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ Returns\ \{\ foo:\ false,\ bar:\ \{\ baz:\ true\ \}\ \}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.all(}
\DoxyCodeLine{\ \ \ \ check.map(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ foo:\ 0,\ bar:\ ''\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ foo:\ check.number,\ bar:\ check.string\ \}}
\DoxyCodeLine{\ \ \ \ )}
\DoxyCodeLine{);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{check.any(}
\DoxyCodeLine{\ \ \ \ check.map(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ [\ 1,\ 2,\ 3,\ ''\ ],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ check.string}
\DoxyCodeLine{\ \ \ \ )}
\DoxyCodeLine{);}
\DoxyCodeLine{//\ Returns\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md10127}{}\doxysubsection{\texorpdfstring{Are there Type\+Script definitions?}{Are there Type\+Script definitions?}}\label{README.md_autotoc_md10127}
\href{https://www.npmjs.com/package/@types/check-types}{\texttt{ Yes}}!

Thanks to \href{https://github.com/idchlife}{\texttt{ @idchlife}}, type definitions \href{https://github.com/DefinitelyTyped/DefinitelyTyped/commit/d19ddb855dea08105a3d7450a98696c7bcd62f60}{\texttt{ were added}} to \href{https://github.com/DefinitelyTyped/DefinitelyTyped}{\texttt{ Definitely\+Typed}}. You can add them to your project via npm\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ i\ @types/check-\/types\ -\/-\/save-\/dev}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md10128}{}\doxysubsection{\texorpdfstring{Where can I use it?}{Where can I use it?}}\label{README.md_autotoc_md10128}
As of version 2.\+0, this library no longer supports ES3. That means you can\textquotesingle{}t use it in IE 7 or 8.

Everywhere else should be fine.

If those versions of IE are important to you, worry not! The 1.\+x versions all support old IE and any future 1.\+x versions will adhere to that too.

See the \href{https://gitlab.com/philbooth/check-types.js/tags}{\texttt{ releases}} for more information.\hypertarget{README.md_autotoc_md10129}{}\doxysubsection{\texorpdfstring{What changed from 10.\+x to 11.\+x?}{What changed from 10.\+x to 11.\+x?}}\label{README.md_autotoc_md10129}
Breaking changes were made to the API in version 11.\+0.\+0.

Specifically, the {\ttfamily options} argument was removed from the {\ttfamily empty\+String} and {\ttfamily non\+Empty\+String} predicates because it caused problematic behaviour in the {\ttfamily assert} modifier. Callers who were previously using {\ttfamily options.\+trim} with these predicates should call {\ttfamily check.\+match} instead\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{check.match(stringWithSpaces,\ /\string^\(\backslash\)s*\$/);}

\end{DoxyCode}


See the \href{HISTORY.md\#anchor-1100}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10130}{}\doxysubsection{\texorpdfstring{What changed from 9.\+x to 10.\+x?}{What changed from 9.\+x to 10.\+x?}}\label{README.md_autotoc_md10130}
Breaking changes were made to the API in version 10.\+0.\+0.

Specifically, the {\ttfamily includes} predicate was merged into the {\ttfamily contains} predicate and errors thrown by the {\ttfamily assert} modifier were given more useful error messages including details about the failing data.

See the \href{HISTORY.md\#anchor-1000}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10131}{}\doxysubsection{\texorpdfstring{What changed from 8.\+x to 9.\+x?}{What changed from 8.\+x to 9.\+x?}}\label{README.md_autotoc_md10131}
Breaking changes were made to the API in version 9.\+0.\+0.

Specifically, an {\ttfamily options} argument was added to the {\ttfamily empty\+String} and {\ttfamily non\+Empty\+String} predicates. In each case, if {\ttfamily options.\+trim} is truthy, strings will be trimmed before making the comparison.

See the \href{HISTORY.md\#anchor-900}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10132}{}\doxysubsection{\texorpdfstring{What changed from 7.\+x to 8.\+x?}{What changed from 7.\+x to 8.\+x?}}\label{README.md_autotoc_md10132}
Breaking changes were made to the API in version 8.\+0.\+0.

Specifically, the {\ttfamily apply} batch operation was removed and {\ttfamily map} was instead changed to work with both arrays and objects, to simplify the API surface.

See the \href{HISTORY.md\#anchor-800}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10133}{}\doxysubsection{\texorpdfstring{What changed from 6.\+x to 7.\+x?}{What changed from 6.\+x to 7.\+x?}}\label{README.md_autotoc_md10133}
Breaking changes were made to the API in version 7.\+0.\+0.

Specifically, the {\ttfamily instance} predicate was renamed to {\ttfamily instance\+Strict} and the {\ttfamily built\+In} and {\ttfamily user\+Defined} predicates were combined to form a new {\ttfamily instance} predicate.

See the \href{HISTORY.md\#anchor-70}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10134}{}\doxysubsection{\texorpdfstring{What changed from 5.\+x to 6.\+x?}{What changed from 5.\+x to 6.\+x?}}\label{README.md_autotoc_md10134}
Breaking changes were made to the API in version 6.\+0.\+0.

Specifically, the {\ttfamily either} modifier was removed. Instead, calling code can use the {\ttfamily any} function, or simply express the boolean logic in JS.

See the \href{HISTORY.md\#anchor-60}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10135}{}\doxysubsection{\texorpdfstring{What changed from 4.\+x to 5.\+x?}{What changed from 4.\+x to 5.\+x?}}\label{README.md_autotoc_md10135}
Breaking changes were made to the API in version 5.\+0.\+0.

Specifically, the predicates {\ttfamily is\+Map} and {\ttfamily error} were removed in favour of the new predicate {\ttfamily built\+In}, which can be used to test for all built-\/in objects.

See the \href{HISTORY.md\#anchor-50}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10136}{}\doxysubsection{\texorpdfstring{What changed from 3.\+x to 4.\+x?}{What changed from 3.\+x to 4.\+x?}}\label{README.md_autotoc_md10136}
Breaking changes were made to the API in version 4.\+0.\+0.

Specifically, the predicate {\ttfamily unempty\+String} was renamed to {\ttfamily non\+Empty\+String} and the predicate {\ttfamily error} was changed to support derived Error objects.

See the \href{HISTORY.md\#anchor-40}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10137}{}\doxysubsection{\texorpdfstring{What changed from 2.\+x to 3.\+x?}{What changed from 2.\+x to 3.\+x?}}\label{README.md_autotoc_md10137}
Breaking changes were made to the API in version 3.\+0.\+0.

Specifically, the predicate {\ttfamily length} was renamed to {\ttfamily has\+Length} and the predicate {\ttfamily web\+Url} was removed.

See the \href{HISTORY.md\#anchor-30}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10138}{}\doxysubsection{\texorpdfstring{What changed from 1.\+x to 2.\+x?}{What changed from 1.\+x to 2.\+x?}}\label{README.md_autotoc_md10138}
Breaking changes were made to the API in version 2.\+0.\+0.

Specifically\+:


\begin{DoxyItemize}
\item Support for ES3 was dropped
\item The predicates {\ttfamily git\+Url}, {\ttfamily email} and {\ttfamily float\+Number} were removed.
\item {\ttfamily verify} was renamed to {\ttfamily assert}.
\item {\ttfamily nulled} was renamed to {\ttfamily null}.
\item {\ttfamily odd\+Number} was renamed to {\ttfamily odd}.
\item {\ttfamily even\+Number} was renamed to {\ttfamily even}.
\item {\ttfamily positive\+Number} was renamed to {\ttfamily positive}.
\item {\ttfamily negative\+Number} was renamed to {\ttfamily negative}.
\item {\ttfamily int\+Number} was renamed to {\ttfamily integer}.
\item {\ttfamily bool} was renamed to {\ttfamily boolean}.
\item {\ttfamily defined} was swapped to become {\ttfamily undefined}.
\item {\ttfamily web\+Url} was tightened to reject more cases.
\end{DoxyItemize}

See the \href{HISTORY.md\#anchor-20}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10139}{}\doxysubsection{\texorpdfstring{What changed from 0.\+x to 1.\+x?}{What changed from 0.\+x to 1.\+x?}}\label{README.md_autotoc_md10139}
Breaking changes were made to the API in version 1.\+0.\+0.

Specifically, all of the predicates were renamed from {\ttfamily check.\+is\+Xxxx} to {\ttfamily check.\+xxx} and all of the verifiers were renamed from {\ttfamily check.\+verify\+Xxxx} to {\ttfamily check.\+verify.\+xxx}.

See the \href{HISTORY.md\#anchor-10}{\texttt{ history}} for more details.\hypertarget{README.md_autotoc_md10140}{}\doxysubsection{\texorpdfstring{How do I set up the build environment?}{How do I set up the build environment?}}\label{README.md_autotoc_md10140}
The build environment relies on \href{http://nodejs.org/}{\texttt{ Node.\+js}}, \href{https://npmjs.org/}{\texttt{ NPM}}, \href{https://github.com/jshint/node-jshint}{\texttt{ JSHint}}, \href{http://mochajs.org/}{\texttt{ Mocha}}, \href{http://chaijs.com/}{\texttt{ Chai}}, \href{https://github.com/mishoo/UglifyJS}{\texttt{ Uglify\+JS}} and \href{https://gitlab.com/philbooth/please-release-me}{\texttt{ please-\/release-\/me}}. Assuming that you already have Node.\+js and NPM set up, you just need to run {\ttfamily npm install} to install all of the dependencies as listed in {\ttfamily package.\+json}.

The unit tests are in {\ttfamily test/check-\/types.\+js}. You can run them with the command {\ttfamily npm test}. To run the tests in a web browser, open {\ttfamily test/check-\/types.\+html}.\hypertarget{README.md_autotoc_md10141}{}\doxysubsection{\texorpdfstring{What license is it released under?}{What license is it released under?}}\label{README.md_autotoc_md10141}
\href{https://gitlab.com/philbooth/check-types.js/blob/master/COPYING}{\texttt{ MIT}} 