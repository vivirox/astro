\doxysection{node\+\_\+modules/fetch-\/blob Directory Reference}
\hypertarget{dir_039b3ae20658a094871d4602a47e1820}{}\label{dir_039b3ae20658a094871d4602a47e1820}\index{node\_modules/fetch-\/blob Directory Reference@{node\_modules/fetch-\/blob Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://www.npmjs.com/package/fetch-blob}{\texttt{ }} \href{https://github.com/node-fetch/fetch-blob/actions}{\texttt{ }} \href{https://codecov.io/gh/node-fetch/fetch-blob}{\texttt{ }} \href{https://packagephobia.now.sh/result?p=fetch-blob}{\texttt{ }}

A Blob implementation in Node.\+js, originally from \href{https://github.com/node-fetch/node-fetch}{\texttt{ node-\/fetch}}.\hypertarget{README.md_autotoc_md15386}{}\doxysubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md15386}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ fetch-\/blob}

\end{DoxyCode}




{\bfseries{Upgrading from 2x to 3x}}\begin{adjustwidth}{1em}{0em}


Updating from 2 to 3 should be a breeze since there is not many changes to the blob specification. The major cause of a major release is coding standards.
\begin{DoxyItemize}
\item internal Weak\+Maps was replaced with private fields
\item internal Buffer.\+from was replaced with Text\+Encoder/\+Decoder
\item internal buffers was replaced with Uint8\+Arrays
\item Common\+JS was replaced with ESM
\item The node stream returned by calling {\ttfamily blob.\+stream()} was replaced with whatwg streams
\item (Read "{}\+Differences from other blobs"{} for more info.)
\end{DoxyItemize}

\end{adjustwidth}




{\bfseries{Differences from other Blobs}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyItemize}
\item Unlike Node\+JS {\ttfamily buffer.\+Blob} (Added in\+: v15.\+7.\+0) and browser native Blob this polyfilled version can\textquotesingle{}t be sent via Post\+Message
\item This blob version is more arbitrary, it can be constructed with blob parts that isn\textquotesingle{}t a instance of itself it has to look and behave as a blob to be accepted as a blob part.
\begin{DoxyItemize}
\item The benefit of this is that you can create other types of blobs that don\textquotesingle{}t contain any internal data that has to be read in other ways, such as the {\ttfamily Blob\+Data\+Item} created in {\ttfamily from.\+js} that wraps a file path into a blob-\/like item and read lazily (nodejs plans to \href{https://github.com/nodejs/node/issues/37340}{\texttt{ implement this}} as well)
\end{DoxyItemize}
\item The {\ttfamily blob.\+stream()} is the most noticeable differences. It returns a WHATWG stream now. to keep it as a node stream you would have to do\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{Readable\}\ from\ 'stream'}
\DoxyCodeLine{const\ stream\ =\ Readable.from(blob.stream())}

\end{DoxyCode}
 \end{adjustwidth}
\hypertarget{README.md_autotoc_md15387}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md15387}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Ways\ to\ import}
\DoxyCodeLine{//\ (PS\ it's\ dependency\ free\ ESM\ package\ so\ regular\ http-\/import\ from\ CDN\ works\ too)}
\DoxyCodeLine{import\ Blob\ from\ 'fetch-\/blob'}
\DoxyCodeLine{import\ File\ from\ 'fetch-\/blob/file.js'}
\DoxyCodeLine{}
\DoxyCodeLine{import\ \{Blob\}\ from\ 'fetch-\/blob'}
\DoxyCodeLine{import\ \{File\}\ from\ 'fetch-\/blob/file.js'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ \{Blob\}\ =\ await\ import('fetch-\/blob')}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Ways\ to\ read\ the\ blob:}
\DoxyCodeLine{const\ blob\ =\ new\ Blob(['hello,\ world'])}
\DoxyCodeLine{}
\DoxyCodeLine{await\ blob.text()}
\DoxyCodeLine{await\ blob.arrayBuffer()}
\DoxyCodeLine{for\ await\ (let\ chunk\ of\ \ blob.stream())\ \{\ ...\ \}}
\DoxyCodeLine{blob.stream().getReader().read()}
\DoxyCodeLine{blob.stream().getReader(\{mode:\ 'byob'\}).read(view)}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md15388}{}\doxysubsubsection{\texorpdfstring{Blob part backed up by filesystem}{Blob part backed up by filesystem}}\label{README.md_autotoc_md15388}
{\ttfamily fetch-\/blob/from.\+js} comes packed with tools to convert any filepath into either a Blob or a File It will not read the content into memory. It will only stat the file for last modified date and file size.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ The\ default\ export\ is\ sync\ and\ use\ fs.stat\ to\ retrieve\ size\ \&\ last\ modified\ as\ a\ blob}
\DoxyCodeLine{import\ blobFromSync\ from\ 'fetch-\/blob/from.js'}
\DoxyCodeLine{import\ \{File,\ Blob,\ blobFrom,\ blobFromSync,\ fileFrom,\ fileFromSync\}\ from\ 'fetch-\/blob/from.js'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ fsFile\ =\ fileFromSync('./2-\/GiB-\/file.bin',\ 'application/octet-\/stream')}
\DoxyCodeLine{const\ fsBlob\ =\ await\ blobFrom('./2-\/GiB-\/file.mp4')}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Not\ a\ 4\ GiB\ memory\ snapshot,\ just\ holds\ references}
\DoxyCodeLine{//\ points\ to\ where\ data\ is\ located\ on\ the\ disk}
\DoxyCodeLine{const\ blob\ =\ new\ Blob([fsFile,\ fsBlob,\ 'memory',\ new\ Uint8Array(10)])}
\DoxyCodeLine{console.log(blob.size)\ //\ \string~4\ GiB}

\end{DoxyCode}


{\ttfamily blob\+From\texorpdfstring{$\vert$}{|}blob\+From\+Sync\texorpdfstring{$\vert$}{|}file\+From\texorpdfstring{$\vert$}{|}file\+From\+Sync(path, \mbox{[}mimetype\mbox{]})}\hypertarget{README.md_autotoc_md15389}{}\doxysubsubsection{\texorpdfstring{Creating Blobs backed up by other async sources}{Creating Blobs backed up by other async sources}}\label{README.md_autotoc_md15389}
Our Blob \& File class are more generic then any other polyfills in the way that it can accept any blob look-\/a-\/like item An example of this is that our blob implementation can be constructed with parts coming from \href{https://github.com/node-fetch/fetch-blob/blob/8ef89adad40d255a3bbd55cf38b88597c1cd5480/from.js\#L32}{\texttt{ Blob\+Data\+Item}} (aka a filepath) or from \href{https://nodejs.org/api/buffer.html\#buffer_new_buffer_blob_sources_options}{\texttt{ buffer.\+Blob}}, It dose not have to implement all the methods -\/ just enough that it can be read/understood by our Blob implementation. The minium requirements is that it has {\ttfamily Symbol.\+to\+String\+Tag}, {\ttfamily size}, {\ttfamily slice()} and either a {\ttfamily stream()} or a {\ttfamily array\+Buffer()} method. If you then wrap it in our Blob or File {\ttfamily new Blob(\mbox{[}blob\+Data\+Item\mbox{]})} then you get all of the other methods that should be implemented in a blob or file

An example of this could be to create a file or blob like item coming from a remote HTTP request. Or from a Data\+Base

See the \href{https://developer.mozilla.org/en-US/docs/Web/API/Blob}{\texttt{ MDN documentation}} and \href{https://github.com/node-fetch/fetch-blob/blob/master/test.js}{\texttt{ tests}} for more details of how to use the Blob. 