\doxysection{node\+\_\+modules/regex-\/recursion Directory Reference}
\hypertarget{dir_211a313debd14ebfb247ebd2f049835d}{}\label{dir_211a313debd14ebfb247ebd2f049835d}\index{node\_modules/regex-\/recursion Directory Reference@{node\_modules/regex-\/recursion Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://npmjs.com/package/regex-recursion}{\texttt{ }} \href{https://npmjs.com/package/regex-recursion}{\texttt{ }} \href{https://bundlejs.com/?q=regex-recursion&treeshake=[*]}{\texttt{ }}

This is an official plugin for \href{https://github.com/slevithan/regex}{\texttt{ Regex+}} that adds support for recursive matching up to a specified max depth {\itshape N}, where {\itshape N} can be between 2 and 100. Generated regexes are native Java\+Script {\ttfamily Reg\+Exp} instances.

\begin{DoxyNote}{Note}
Regex flavors vary on whether they offer infinite or fixed-\/depth recursion. For example, recursion in Oniguruma uses a depth limit of 20, and doesn\textquotesingle{}t allow changing this.
\end{DoxyNote}
Recursive matching is added to a regex via one of the following (the recursion depth limit is provided in place of {\itshape {\ttfamily N}})\+:


\begin{DoxyItemize}
\item {\ttfamily (?R=N)} — Recursively match the entire regex at this position.
\item {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\&R=N\texorpdfstring{$>$}{>}} or {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}number\&R=N\texorpdfstring{$>$}{>}} — Recursively match the contents of the group referenced by name or number at this position.
\begin{DoxyItemize}
\item The {\ttfamily \textbackslash{}g} subroutine must be {\itshape within} the referenced group.
\end{DoxyItemize}
\end{DoxyItemize}

Multiple uses of recursion within the same pattern are allowed if they are non-\/overlapping. Named captures and backreferences are supported within recursion, and are independent per depth level. So e.\+g. {\ttfamily groups.\+name} on a match object is the value captured by group {\ttfamily name} at the top level of the recursion stack.\hypertarget{README.md_autotoc_md28519}{}\doxysubsection{\texorpdfstring{Install and use}{Install and use}}\label{README.md_autotoc_md28519}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ regex\ regex-\/recursion}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{regex\}\ from\ 'regex';}
\DoxyCodeLine{import\ \{recursion\}\ from\ 'regex-\/recursion';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ regex(\{plugins:\ [recursion]\})`…`;}

\end{DoxyCode}




{\bfseries{Using a global name (no import)}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyCode}{0}
\DoxyCodeLine{<script\ src="{}https://cdn.jsdelivr.net/npm/regex@6.0.1/dist/regex.min.js"{}></script>}
\DoxyCodeLine{<script\ src="{}https://cdn.jsdelivr.net/npm/regex-\/recursion@6.0.2/dist/regex-\/recursion.min.js"{}></script>}
\DoxyCodeLine{<script>}
\DoxyCodeLine{\ \ const\ \{regex\}\ =\ Regex;}
\DoxyCodeLine{\ \ const\ \{recursion\}\ =\ Regex.plugins;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ const\ re\ =\ regex(\{plugins:\ [recursion]\})`…`;}
\DoxyCodeLine{</script>}

\end{DoxyCode}
 \end{adjustwidth}
\hypertarget{README.md_autotoc_md28520}{}\doxysubsection{\texorpdfstring{Examples}{Examples}}\label{README.md_autotoc_md28520}
\hypertarget{README.md_autotoc_md28521}{}\doxysubsubsection{\texorpdfstring{Match an equal number of two different subpatterns}{Match an equal number of two different subpatterns}}\label{README.md_autotoc_md28521}
\hypertarget{README.md_autotoc_md28522}{}\doxysubsubsubsection{\texorpdfstring{Anywhere within a string}{Anywhere within a string}}\label{README.md_autotoc_md28522}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Matches\ sequences\ of\ up\ to\ 20\ 'a'\ chars\ followed\ by\ the\ same\ number\ of\ 'b'}
\DoxyCodeLine{const\ re\ =\ regex(\{plugins:\ [recursion]\})`a(?R=20)?b`;}
\DoxyCodeLine{re.exec('test\ aaaaaabbb')[0];}
\DoxyCodeLine{//\ →\ 'aaabbb'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28523}{}\doxysubsubsubsection{\texorpdfstring{As the entire string}{As the entire string}}\label{README.md_autotoc_md28523}
Use {\ttfamily \textbackslash{}g\texorpdfstring{$<$}{<}name\&R=N\texorpdfstring{$>$}{>}} to recursively match just the specified group.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ re\ =\ regex(\{plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ \string^\ (?<r>\ a\ \(\backslash\)g<r\&R=20>?\ b)\ \$}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{re.test('aaabbb');\ //\ →\ true}
\DoxyCodeLine{re.test('aaabb');\ //\ →\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28524}{}\doxysubsubsection{\texorpdfstring{Match balanced parentheses}{Match balanced parentheses}}\label{README.md_autotoc_md28524}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Matches\ all\ balanced\ parentheses\ up\ to\ depth\ 20}
\DoxyCodeLine{const\ parens\ =\ regex(\{flags:\ 'g',\ plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ \(\backslash\)(\ ([\string^\(\backslash\)(\(\backslash\))]\ |\ (?R=20))*\ \(\backslash\))}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{'test\ )\ (balanced\ ((parens)))\ ()\ ((a))\ (\ (b)'.match(parens);}
\DoxyCodeLine{/*\ →\ [}
\DoxyCodeLine{\ \ '(balanced\ ((parens)))',}
\DoxyCodeLine{\ \ '()',}
\DoxyCodeLine{\ \ '((a))',}
\DoxyCodeLine{\ \ '(b)'}
\DoxyCodeLine{]\ */}

\end{DoxyCode}


Following is an alternative that matches the same strings, but adds a nested quantifier. It then uses an atomic group to prevent this nested quantifier from creating the potential for \href{https://www.regular-expressions.info/catastrophic.html}{\texttt{ catastrophic backtracking}}. Since the example above doesn\textquotesingle{}t need a nested quantifier, this is not an improvement but merely an alternative that shows how to deal with the general problem of nested quantifiers with multiple ways to divide matches of the same strings.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ parens\ =\ regex(\{flags:\ 'g',\ plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ \(\backslash\)(\ ((?>\ [\string^\(\backslash\)(\(\backslash\))]+)\ |\ (?R=20))*\ \(\backslash\))}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Or\ with\ a\ possessive\ quantifier}
\DoxyCodeLine{const\ parens\ =\ regex(\{flags:\ 'g',\ plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ \(\backslash\)(\ ([\string^\(\backslash\)(\(\backslash\))]++\ |\ (?R=20))*\ \(\backslash\))}
\DoxyCodeLine{\`{};}

\end{DoxyCode}


The first example above matches sequences of non-\/parentheses in one step with the nested {\ttfamily +} quantifier, and avoids backtracking into these sequences by wrapping it with an atomic group {\ttfamily (?\texorpdfstring{$>$}{>}…)}. Given that what the nested quantifier {\ttfamily +} matches overlaps with what the outer group can match with its {\ttfamily \texorpdfstring{$\ast$}{*}} quantifier, the atomic group is important here. It avoids exponential backtracking when matching long strings with unbalanced parentheses.

In cases where you\textquotesingle{}re you\textquotesingle{}re repeating a single token within an atomic group, possessive quantifiers provide syntax sugar.

Atomic groups and possessive quantifiers are provided by the base Regex+ library.\hypertarget{README.md_autotoc_md28525}{}\doxysubsubsection{\texorpdfstring{Match palindromes}{Match palindromes}}\label{README.md_autotoc_md28525}
\hypertarget{README.md_autotoc_md28526}{}\doxysubsubsubsection{\texorpdfstring{Match palindromes anywhere within a string}{Match palindromes anywhere within a string}}\label{README.md_autotoc_md28526}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ palindromes\ =\ regex(\{flags:\ 'gi',\ plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ (?<char>\ \(\backslash\)w)}
\DoxyCodeLine{\ \ \#\ Recurse,\ or\ match\ a\ lone\ unbalanced\ char\ in\ the\ middle}
\DoxyCodeLine{\ \ ((?R=15)\ |\ \(\backslash\)w?)}
\DoxyCodeLine{\ \ \(\backslash\)k<char>}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{'Racecar,\ ABBA,\ and\ redivided'.match(palindromes);}
\DoxyCodeLine{//\ →\ ['Racecar',\ 'ABBA',\ 'edivide']}

\end{DoxyCode}


Palindromes are sequences that read the same backwards as forwards. In the example above, the max length of matched palindromes is 31. That\textquotesingle{}s because it sets the max recursion depth to 15 with {\ttfamily (?R=15)}. So, depth 15 × 2 chars (left + right) for each depth level + 1 optional unbalanced char in the middle = 31. To match longer palindromes, the max recursion depth can be increased to a max of 100, which would enable matching palindromes up to 201 characters long.\hypertarget{README.md_autotoc_md28527}{}\doxysubsubsubsection{\texorpdfstring{Match palindromes as complete words}{Match palindromes as complete words}}\label{README.md_autotoc_md28527}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ palindromeWords\ =\ regex(\{flags:\ 'gi',\ plugins:\ [recursion]\})`}
\DoxyCodeLine{\ \ \(\backslash\)b}
\DoxyCodeLine{\ \ (?<palindrome>}
\DoxyCodeLine{\ \ \ \ (?<char>\ \(\backslash\)w)}
\DoxyCodeLine{\ \ \ \ (\(\backslash\)g<palindrome\&R=15>\ |\ \(\backslash\)w?)}
\DoxyCodeLine{\ \ \ \ \(\backslash\)k<char>}
\DoxyCodeLine{\ \ )}
\DoxyCodeLine{\ \ \(\backslash\)b}
\DoxyCodeLine{\`{};}
\DoxyCodeLine{}
\DoxyCodeLine{'Racecar,\ ABBA,\ and\ redivided'.match(palindromeWords);}
\DoxyCodeLine{//\ →\ ['Racecar',\ 'ABBA']}

\end{DoxyCode}
 