\doxysection{node\+\_\+modules/zod Directory Reference}
\hypertarget{dir_8007011d04a98072ecf74d9aeed4fe32}{}\label{dir_8007011d04a98072ecf74d9aeed4fe32}\index{node\_modules/zod Directory Reference@{node\_modules/zod Directory Reference}}


\doxysubsection{Detailed Description}


 \doxysubsection*{Zod}



‚ú® \href{https://zod.dev}{\texttt{ https\+://zod.\+dev}} ‚ú® ~\newline
 Type\+Script-\/first schema validation with static type inference 

~\newline
 

\href{https://github.com/colinhacks/zod/actions?query=branch\%3Amaster}{\texttt{ }} \href{https://twitter.com/colinhacks}{\texttt{ }} \href{https://opensource.org/licenses/MIT}{\texttt{ }} \href{https://www.npmjs.com/package/zod}{\texttt{ }} \href{https://www.npmjs.com/package/zod}{\texttt{ }} \href{https://discord.gg/KaSRdyX2vc}{\texttt{ }} 

 \href{https://zod.dev}{\texttt{ Documentation}} ~~‚Ä¢~~ \href{https://discord.gg/RcG33DQJdf}{\texttt{ Discord}} ~~‚Ä¢~~ \href{https://www.npmjs.com/package/zod}{\texttt{ npm}} ~~‚Ä¢~~ \href{https://deno.land/x/zod}{\texttt{ deno}} ~~‚Ä¢~~ \href{https://github.com/colinhacks/zod/issues/new}{\texttt{ Issues}} ~~‚Ä¢~~ \href{https://twitter.com/colinhacks}{\texttt{ @colinhacks}} ~~‚Ä¢~~ \href{https://trpc.io}{\texttt{ t\+RPC}} ~\newline
 

~\newline
 ~\newline


\begin{quote}
These docs have been translated into Chinese. \end{quote}
\hypertarget{README.md_autotoc_md36581}{}\doxysubsubsection{\texorpdfstring{Table of contents}{Table of contents}}\label{README.md_autotoc_md36581}

\begin{DoxyItemize}
\item Table of contents
\item Introduction
\begin{DoxyItemize}
\item Sponsors
\begin{DoxyItemize}
\item Gold
\item Silver
\item Bronze
\end{DoxyItemize}
\item Ecosystem
\begin{DoxyItemize}
\item \doxylink{md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g_resources}{Resources}
\item API libraries
\item Form integrations
\item Zod to X
\item X to Zod
\item Mocking
\item Powered by Zod
\item Utilities for Zod
\end{DoxyItemize}
\end{DoxyItemize}
\item \doxylink{README.md_installation}{Installation}
\begin{DoxyItemize}
\item Requirements
\item From \`{}npm\`{} (Node/\+Bun)
\item From \`{}deno.land/x\`{} (Deno)
\end{DoxyItemize}
\item Basic usage
\item Primitives
\item Coercion for primitives
\item Literals
\item Strings
\begin{DoxyItemize}
\item ISO datetimes
\item IP addresses
\end{DoxyItemize}
\item Numbers
\item Big\+Ints
\item Na\+Ns
\item Booleans
\item Dates
\item Zod enums
\item Native enums
\item Optionals
\item Nullables
\item \doxylink{README.md_objects}{Objects}
\begin{DoxyItemize}
\item \`{}.shape\`{}
\item \`{}.keyof\`{}
\item \`{}.extend\`{}
\item \doxylink{README.md_merge}{\`{}.merge\`{}}
\item \`{}.pick/.omit\`{}
\item \`{}.partial\`{}
\item \`{}.deep\+Partial\`{}
\item \`{}.required\`{}
\item \`{}.passthrough\`{}
\item \`{}.strict\`{}
\item \`{}.strip\`{}
\item \`{}.catchall\`{}
\end{DoxyItemize}
\item Arrays
\begin{DoxyItemize}
\item \`{}.element\`{}
\item \`{}.nonempty\`{}
\item \`{}.min/.max/.length\`{}
\end{DoxyItemize}
\item Tuples
\item Unions
\item Discriminated unions
\item Records
\begin{DoxyItemize}
\item Record key type
\end{DoxyItemize}
\item Maps
\item Sets
\item Intersections
\item Recursive types
\begin{DoxyItemize}
\item Zod\+Type with Zod\+Effects
\item JSON type
\item Cyclical objects
\end{DoxyItemize}
\item Promises
\item Instanceof
\item \doxylink{tester_8cpp_a3c51ddeb3d007f204eced4cb67c52ce7}{Functions}
\item Preprocess
\item Custom schemas
\item Schema methods
\begin{DoxyItemize}
\item \`{}.parse\`{}
\item \`{}.parse\+Async\`{}
\item \`{}.safe\+Parse\`{}
\item \`{}.safe\+Parse\+Async\`{}
\item \`{}.refine\`{}
\begin{DoxyItemize}
\item Arguments
\item Customize error path
\item Asynchronous refinements
\item Relationship to transforms
\end{DoxyItemize}
\item \`{}.super\+Refine\`{}
\begin{DoxyItemize}
\item Abort early
\item Type refinements
\end{DoxyItemize}
\item \`{}.transform\`{}
\begin{DoxyItemize}
\item Chaining order
\item Validating during transform
\item Relationship to refinements
\item Async transforms
\end{DoxyItemize}
\item \`{}.default\`{}
\item \`{}.describe\`{}
\item \`{}.catch\`{}
\item \`{}.optional\`{}
\item \`{}.nullable\`{}
\item \`{}.nullish\`{}
\item \`{}.array\`{}
\item \doxylink{README.md_promise}{\`{}.promise\`{}}
\item \`{}.or\`{}
\item \`{}.and\`{}
\item \`{}.brand\`{}
\item \`{}.readonly\`{}
\item \`{}.pipe\`{}
\begin{DoxyItemize}
\item You can use \`{}.pipe()\`{} to fix common issues with \`{}z.coerce\`{}.
\end{DoxyItemize}
\end{DoxyItemize}
\item Guides and concepts
\begin{DoxyItemize}
\item Type inference
\item Writing generic functions
\begin{DoxyItemize}
\item Constraining allowable inputs
\end{DoxyItemize}
\item Error handling
\item Error formatting
\end{DoxyItemize}
\item Comparison
\begin{DoxyItemize}
\item Joi
\item Yup
\item io-\/ts
\item Runtypes
\item Ow
\end{DoxyItemize}
\item Changelog
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36583}{}\doxysubsubsection{\texorpdfstring{Introduction}{Introduction}}\label{README.md_autotoc_md36583}
Zod is a Type\+Script-\/first schema declaration and validation library. I\textquotesingle{}m using the term "{}schema"{} to broadly refer to any data type, from a simple {\ttfamily string} to a complex nested object.

Zod is designed to be as developer-\/friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator {\itshape once} and Zod will automatically infer the static Type\+Script type. It\textquotesingle{}s easy to compose simpler types into complex data structures.

Some other great aspects\+:


\begin{DoxyItemize}
\item Zero dependencies
\item Works in Node.\+js and all modern browsers
\item Tiny\+: 8kb minified + zipped
\item Immutable\+: methods (e.\+g. {\ttfamily .optional()}) return a new instance
\item Concise, chainable interface
\item Functional approach\+: \href{https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/}{\texttt{ parse, don\textquotesingle{}t validate}}
\item Works with plain Java\+Script too! You don\textquotesingle{}t need to use Type\+Script.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36584}{}\doxysubsubsubsection{\texorpdfstring{Sponsors}{Sponsors}}\label{README.md_autotoc_md36584}
Sponsorship at any level is appreciated and encouraged. For individual developers, consider the \href{https://github.com/sponsors/colinhacks}{\texttt{ Cup of Coffee tier}}. If you built a paid product using Zod, consider one of the \href{https://github.com/sponsors/colinhacks}{\texttt{ podium tiers}}.\hypertarget{README.md_autotoc_md36585}{}\doxysubsubsubsubsection{\texorpdfstring{Gold}{Gold}}\label{README.md_autotoc_md36585}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \href{https://speakeasyapi.dev/}{\texttt{  }} ~\newline
 {\bfseries{Speakeasy}} ~\newline
 \href{https://speakeasyapi.dev/}{\texttt{ speakeasyapi.\+dev}} ~\newline
 

SDKs, Terraform, Docs.~\newline
Your API made enterprise-\/ready.

&\PBS\centering \href{https://glow.app/}{\texttt{  }} ~\newline
 {\bfseries{Glow Wallet}} ~\newline
 \href{https://glow.app/}{\texttt{ glow.\+app}} ~\newline
 

Your new favorite ~\newline
 Solana wallet.

\\\cline{1-2}
\PBS\centering \href{https://deletype.com/}{\texttt{  }} ~\newline
 {\bfseries{Deletype}} ~\newline
 \href{https://deletype.com}{\texttt{ deletype.\+com}}  &\PBS\centering \href{https://trigger.dev/}{\texttt{  }} ~\newline
 {\bfseries{Trigger.\+dev}} ~\newline
 \href{https://trigger.dev}{\texttt{ trigger.\+dev}} ~\newline
 

Effortless automation for developers.

\\\cline{1-2}
\PBS\centering \href{https://transloadit.com/?utm_source=zod&utm_medium=referral&utm_campaign=sponsorship&utm_content=github}{\texttt{  }} ~\newline
 {\bfseries{Transloadit}} ~\newline
 \href{https://transloadit.com/?utm_source=zod&utm_medium=referral&utm_campaign=sponsorship&utm_content=github}{\texttt{ transloadit.\+com}} ~\newline
 

Simple file processing for developers.

&\PBS\centering \href{https://infisical.com}{\texttt{  }} ~\newline
 {\bfseries{Infisical}} ~\newline
 \href{https://infisical.com}{\texttt{ infisical.\+com}} ~\newline
 

Open-\/source platform for secret~\newline
management\+: sync secrets across your~\newline
team/infrastructure and prevent secret leaks.

\\\cline{1-2}
\PBS\centering \href{https://whop.com/}{\texttt{  }} ~\newline
 {\bfseries{Whop}} ~\newline
 \href{https://whop.com/}{\texttt{ whop.\+com}} ~\newline
 

A marketplace for really cool internet products.

\\\cline{1-2}
\end{longtabu}
\hypertarget{README.md_autotoc_md36586}{}\doxysubsubsubsubsection{\texorpdfstring{Silver}{Silver}}\label{README.md_autotoc_md36586}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\multicolumn{2}{|c|}{\PBS\centering \href{https://www.numeric.io}{\texttt{  }} ~\newline
 {\bfseries{Numeric}} ~\newline
 \href{https://www.numeric.io}{\texttt{ numeric.\+io}}  }&\PBS\centering \href{https://marcatopartners.com/}{\texttt{  }} ~\newline
 {\bfseries{Marcato Partners}} ~\newline
 \href{https://marcatopartners.com/}{\texttt{ marcatopartners.\+com}}   \\\cline{1-3}
\PBS\centering \href{https://interval.com}{\texttt{  }} ~\newline
 {\bfseries{Interval}} ~\newline
 \href{https://interval.com}{\texttt{ interval.\+com}}  &\PBS\centering \href{https://seasoned.cc}{\texttt{  }} ~\newline
 {\bfseries{Seasoned Software}} ~\newline
 \href{https://seasoned.cc}{\texttt{ seasoned.\+cc}}  &\PBS\centering \href{https://www.bamboocreative.nz/}{\texttt{  }} ~\newline
 {\bfseries{Bamboo Creative}} ~\newline
 \href{https://www.bamboocreative.nz}{\texttt{ bamboocreative.\+nz}}   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md36587}{}\doxysubsubsubsubsection{\texorpdfstring{Bronze}{Bronze}}\label{README.md_autotoc_md36587}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \href{https://twitter.com/flybayer}{\texttt{  }} ~\newline
 {\bfseries{Brandon Bayer}} ~\newline
 \href{https://twitter.com/flybayer}{\texttt{ @flybayer}}, creator of \href{https://blitzjs.com}{\texttt{ Blitz.\+js}} ~\newline
  &\PBS\centering \href{https://github.com/brabeji}{\texttt{  }} ~\newline
 {\bfseries{Ji≈ô√≠ Brabec}} ~\newline
 \href{https://github.com/brabeji}{\texttt{ @brabeji}} ~\newline
  &\PBS\centering \href{https://twitter.com/alexdotjs}{\texttt{  }} ~\newline
 {\bfseries{Alex Johansson}} ~\newline
 \href{https://twitter.com/alexdotjs}{\texttt{ @alexdotjs}}   \\\cline{1-3}
\PBS\centering \href{https://fungible.systems/}{\texttt{  }} ~\newline
 {\bfseries{Fungible Systems}} ~\newline
 \href{https://fungible.systems/}{\texttt{ fungible.\+systems}} ~\newline
  &\PBS\centering \href{https://adaptable.io/}{\texttt{  }} ~\newline
 {\bfseries{Adaptable}} ~\newline
 \href{https://adaptable.io/}{\texttt{ adaptable.\+io}} ~\newline
  &\PBS\centering \href{https://www.avanawallet.com/}{\texttt{  }} ~\newline
 {\bfseries{Avana Wallet}} ~\newline
 \href{https://www.avanawallet.com/}{\texttt{ avanawallet.\+com}}~\newline
 Solana non-\/custodial wallet ~\newline
   \\\cline{1-3}
\PBS\centering \href{https://learnwithjason.dev}{\texttt{  }} ~\newline
 {\bfseries{Jason Lengstorf}} ~\newline
 \href{https://learnwithjason.dev/}{\texttt{ learnwithjason.\+dev}} ~\newline
  &\PBS\centering \href{https://ill.inc/}{\texttt{  }} ~\newline
 {\bfseries{Global Illumination, Inc.}} ~\newline
 \href{https://ill.inc/}{\texttt{ ill.\+inc}} ~\newline
  &\PBS\centering \href{https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring}{\texttt{  }} ~\newline
 {\bfseries{Master\+Born}} ~\newline
 \href{https://www.masterborn.com/career?utm_source=github&utm_medium=referral&utm_campaign=zodsponsoring}{\texttt{ masterborn.\+com}} ~\newline
   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md36588}{}\doxysubsubsubsection{\texorpdfstring{Ecosystem}{Ecosystem}}\label{README.md_autotoc_md36588}
There are a growing number of tools that are built atop or support Zod natively! If you\textquotesingle{}ve built a tool or library on top of Zod, tell me about it \href{https://twitter.com/colinhacks}{\texttt{ on Twitter}} or \href{https://github.com/colinhacks/zod/discussions}{\texttt{ start a Discussion}}. I\textquotesingle{}ll add it below and tweet it out.\hypertarget{README.md_autotoc_md36589}{}\doxysubsubsubsubsection{\texorpdfstring{Resources}{Resources}}\label{README.md_autotoc_md36589}

\begin{DoxyItemize}
\item \href{https://www.totaltypescript.com/tutorials/zod}{\texttt{ Total Type\+Script Zod Tutorial}} by \href{https://twitter.com/mattpocockuk}{\texttt{ @mattpocockuk}}
\item \href{https://www.youtube.com/watch?v=rY_XqfSHock}{\texttt{ Fixing Type\+Script\textquotesingle{}s Blindspot\+: Runtime Typechecking}} by \href{https://twitter.com/jherr}{\texttt{ @jherr}}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36590}{}\doxysubsubsubsubsection{\texorpdfstring{API libraries}{API libraries}}\label{README.md_autotoc_md36590}

\begin{DoxyItemize}
\item \href{https://github.com/trpc/trpc}{\texttt{ {\ttfamily t\+RPC}}}\+: Build end-\/to-\/end typesafe APIs without Graph\+QL.
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs}{\texttt{ {\ttfamily @anatine/zod-\/nestjs}}}\+: Helper methods for using Zod in a Nest\+JS project.
\item \href{https://github.com/flock-community/zod-endpoints}{\texttt{ {\ttfamily zod-\/endpoints}}}\+: Contract-\/first strictly typed endpoints with Zod. Open\+API compatible.
\item \href{https://github.com/SeasonedSoftware/domain-functions/}{\texttt{ {\ttfamily domain-\/functions}}}\+: Decouple your business logic from your framework using composable functions. With first-\/class type inference from end to end powered by Zod schemas.
\item \href{https://github.com/ecyrbe/zodios}{\texttt{ {\ttfamily @zodios/core}}}\+: A typescript API client with runtime and compile time validation backed by axios and zod.
\item \href{https://github.com/RobinTail/express-zod-api}{\texttt{ {\ttfamily express-\/zod-\/api}}}\+: Build Express-\/based APIs with I/O schema validation and custom middlewares.
\item \href{https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md}{\texttt{ {\ttfamily tapiduck}}}\+: End-\/to-\/end typesafe JSON APIs with Zod and Express; a bit like t\+RPC, but simpler.
\item \href{https://github.com/JakeFenley/koa-zod-router}{\texttt{ {\ttfamily koa-\/zod-\/router}}}\+: Create typesafe routes in Koa with I/O validation using Zod.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36591}{}\doxysubsubsubsubsection{\texorpdfstring{Form integrations}{Form integrations}}\label{README.md_autotoc_md36591}

\begin{DoxyItemize}
\item \href{https://conform.guide/api/zod}{\texttt{ {\ttfamily conform}}}\+: A progressive enhancement first form validation library for Remix and React Router
\item \href{https://github.com/react-hook-form/resolvers\#zod}{\texttt{ {\ttfamily react-\/hook-\/form}}}\+: A first-\/party Zod resolver for React Hook Form.
\item \href{https://github.com/causaly/zod-validation-error}{\texttt{ {\ttfamily zod-\/validation-\/error}}}\+: Generate user-\/friendly error messages from {\ttfamily Zod\+Error}s.
\item \href{https://github.com/robertLichtnow/zod-formik-adapter}{\texttt{ {\ttfamily zod-\/formik-\/adapter}}}\+: A community-\/maintained Formik adapter for Zod.
\item \href{https://github.com/esamattis/react-zorm}{\texttt{ {\ttfamily react-\/zorm}}}\+: Standalone {\ttfamily \texorpdfstring{$<$}{<}form\texorpdfstring{$>$}{>}} generation and validation for React using Zod.
\item \href{https://github.com/rileytomasek/zodix}{\texttt{ {\ttfamily zodix}}}\+: Zod utilities for Form\+Data and URLSearch\+Params in Remix loaders and actions.
\item \href{https://github.com/kiliman/remix-params-helper}{\texttt{ {\ttfamily remix-\/params-\/helper}}}\+: Simplify integration of Zod with standard URLSearch\+Params and Form\+Data for Remix apps.
\item \href{https://github.com/glazy/formik-validator-zod}{\texttt{ {\ttfamily formik-\/validator-\/zod}}}\+: Formik-\/compliant validator library that simplifies using Zod with Formik.
\item \href{https://github.com/aiji42/zod-i18n}{\texttt{ {\ttfamily zod-\/i18n-\/map}}}\+: Useful for translating Zod error messages.
\item \href{https://github.com/fabian-hiller/modular-forms}{\texttt{ {\ttfamily @modular-\/forms/solid}}}\+: Modular form library for Solid\+JS that supports Zod for validation.
\item \href{https://github.com/crutchcorn/houseform/}{\texttt{ {\ttfamily houseform}}}\+: A React form library that uses Zod for validation.
\item \href{https://github.com/ciscoheat/sveltekit-superforms}{\texttt{ {\ttfamily sveltekit-\/superforms}}}\+: Supercharged form library for Svelte\+Kit with Zod validation.
\item \href{https://github.com/MonoidDev/mobx-zod-form}{\texttt{ {\ttfamily mobx-\/zod-\/form}}}\+: Data-\/first form builder based on MobX \& Zod.
\item \href{https://github.com/logaretm/vee-validate/tree/main/packages/zod}{\texttt{ {\ttfamily @vee-\/validate/zod}}}\+: Form library for Vue.\+js with Zod schema validation.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36592}{}\doxysubsubsubsubsection{\texorpdfstring{Zod to X}{Zod to X}}\label{README.md_autotoc_md36592}

\begin{DoxyItemize}
\item \href{https://github.com/sachinraja/zod-to-ts}{\texttt{ {\ttfamily zod-\/to-\/ts}}}\+: Generate Type\+Script definitions from Zod schemas.
\item \href{https://github.com/StefanTerdell/zod-to-json-schema}{\texttt{ {\ttfamily zod-\/to-\/json-\/schema}}}\+: Convert your Zod schemas into \href{https://json-schema.org/}{\texttt{ JSON Schemas}}.
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi}{\texttt{ {\ttfamily @anatine/zod-\/openapi}}}\+: Converts a Zod schema to an Open\+API v3.\+x {\ttfamily Schema\+Object}.
\item \href{https://github.com/DavidTimms/zod-fast-check}{\texttt{ {\ttfamily zod-\/fast-\/check}}}\+: Generate {\ttfamily fast-\/check} arbitraries from Zod schemas.
\item \href{https://github.com/kbkk/abitia/tree/master/packages/zod-dto}{\texttt{ {\ttfamily zod-\/dto}}}\+: Generate Nest.\+js DTOs from a Zod schema.
\item \href{https://github.com/turkerdev/fastify-type-provider-zod}{\texttt{ {\ttfamily fastify-\/type-\/provider-\/zod}}}\+: Create Fastify type providers from Zod schemas.
\item \href{https://github.com/asteasolutions/zod-to-openapi}{\texttt{ {\ttfamily zod-\/to-\/openapi}}}\+: Generate full Open\+API (Swagger) docs from Zod, including schemas, endpoints \& parameters.
\item \href{https://github.com/incetarik/nestjs-graphql-zod}{\texttt{ {\ttfamily nestjs-\/graphql-\/zod}}}\+: Generates Nest\+JS Graph\+QL model classes from Zod schemas. Provides Graph\+QL method decorators working with Zod schemas.
\item \href{https://github.com/samchungy/zod-openapi}{\texttt{ {\ttfamily zod-\/openapi}}}\+: Create full Open\+API v3.\+x documentation from Zod schemas.
\item \href{https://github.com/samchungy/fastify-zod-openapi}{\texttt{ {\ttfamily fastify-\/zod-\/openapi}}}\+: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.
\item \href{https://typeschema.com/}{\texttt{ {\ttfamily typeschema}}}\+: Universal adapter for schema validation.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36593}{}\doxysubsubsubsubsection{\texorpdfstring{X to Zod}{X to Zod}}\label{README.md_autotoc_md36593}

\begin{DoxyItemize}
\item \href{https://github.com/fabien0102/ts-to-zod}{\texttt{ {\ttfamily ts-\/to-\/zod}}}\+: Convert Type\+Script definitions into Zod schemas.
\item \href{https://github.com/johngeorgewright/runtyping/tree/master/packages/zod}{\texttt{ {\ttfamily @runtyping/zod}}}\+: Generate Zod from static types \& JSON schema.
\item \href{https://github.com/StefanTerdell/json-schema-to-zod}{\texttt{ {\ttfamily json-\/schema-\/to-\/zod}}}\+: Convert your \href{https://json-schema.org/}{\texttt{ JSON Schemas}} into Zod schemas. \href{https://StefanTerdell.github.io/json-schema-to-zod-react/}{\texttt{ Live demo}}.
\item \href{https://github.com/rsinohara/json-to-zod}{\texttt{ {\ttfamily json-\/to-\/zod}}}\+: Convert JSON objects into Zod schemas. \href{https://rsinohara.github.io/json-to-zod-react/}{\texttt{ Live demo}}.
\item \href{https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema}{\texttt{ {\ttfamily graphql-\/codegen-\/typescript-\/validation-\/schema}}}\+: Graph\+QL Code Generator plugin to generate form validation schema from your Graph\+QL schema.
\item \href{https://github.com/CarterGrimmeisen/zod-prisma}{\texttt{ {\ttfamily zod-\/prisma}}}\+: Generate Zod schemas from your Prisma schema.
\item \href{https://github.com/Southclaws/supervillain}{\texttt{ {\ttfamily Supervillain}}}\+: Generate Zod schemas from your Go structs.
\item \href{https://github.com/omar-dulaimi/prisma-zod-generator}{\texttt{ {\ttfamily prisma-\/zod-\/generator}}}\+: Emit Zod schemas from your Prisma schema.
\item \href{https://github.com/omar-dulaimi/prisma-trpc-generator}{\texttt{ {\ttfamily prisma-\/trpc-\/generator}}}\+: Emit fully implemented t\+RPC routers and their validation schemas using Zod.
\item \href{https://github.com/chrishoermann/zod-prisma-types}{\texttt{ {\ttfamily zod-\/prisma-\/types}}} Create Zod types from your Prisma models.
\item \href{https://app.quicktype.io/}{\texttt{ {\ttfamily quicktype}}}\+: Convert JSON objects and JSON schemas into Zod schemas.
\item \href{https://github.com/saiichihashimoto/sanity-typed/tree/main/packages/zod}{\texttt{ {\ttfamily @sanity-\/typed/zod}}}\+: Generate Zod Schemas from \href{https://www.sanity.io/docs/schema-types}{\texttt{ Sanity Schemas}}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36594}{}\doxysubsubsubsubsection{\texorpdfstring{Mocking}{Mocking}}\label{README.md_autotoc_md36594}

\begin{DoxyItemize}
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock}{\texttt{ {\ttfamily @anatine/zod-\/mock}}}\+: Generate mock data from a Zod schema. Powered by \href{https://github.com/faker-js/faker}{\texttt{ faker.\+js}}.
\item \href{https://github.com/dipasqualew/zod-mocking}{\texttt{ {\ttfamily zod-\/mocking}}}\+: Generate mock data from your Zod schemas.
\item \href{https://github.com/timdeschryver/zod-fixture}{\texttt{ {\ttfamily zod-\/fixture}}}\+: Use your zod schemas to automate the generation of non-\/relevant test fixtures in a deterministic way.
\item \href{https://zocker.sigrist.dev}{\texttt{ {\ttfamily zocker}}}\+: Generate plausible mock-\/data from your schemas.
\item \href{https://github.com/ItMaga/zodock}{\texttt{ {\ttfamily zodock}}} Generate mock data based on Zod schemas.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36595}{}\doxysubsubsubsubsection{\texorpdfstring{Powered by Zod}{Powered by Zod}}\label{README.md_autotoc_md36595}

\begin{DoxyItemize}
\item \href{https://github.com/JacobWeisenburger/freerstore}{\texttt{ {\ttfamily freerstore}}}\+: Firestore cost optimizer.
\item \href{https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible\#runtime-validation-and-static-type-inference}{\texttt{ {\ttfamily slonik}}}\+: Node.\+js Postgres client with strong Zod integration.
\item \href{https://github.com/mdbetancourt/soly}{\texttt{ {\ttfamily soly}}}\+: Create CLI applications with zod.
\item \href{https://github.com/sidwebworks/zod-xlsx}{\texttt{ {\ttfamily zod-\/xlsx}}}\+: A xlsx based resource validator using Zod schemas.
\item \href{https://github.com/lostfictions/znv}{\texttt{ {\ttfamily znv}}}\+: Type-\/safe environment parsing and validation for Node.\+js with Zod schemas.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36596}{}\doxysubsubsubsubsection{\texorpdfstring{Utilities for Zod}{Utilities for Zod}}\label{README.md_autotoc_md36596}

\begin{DoxyItemize}
\item \href{https://github.com/JacobWeisenburger/zod_utilz}{\texttt{ {\ttfamily zod\+\_\+utilz}}}\+: Framework agnostic utilities for Zod.
\item \href{https://github.com/nereumelo/zod-sandbox}{\texttt{ {\ttfamily zod-\/sandbox}}}\+: Controlled environment for testing zod schemas. \href{https://zod-sandbox.vercel.app/}{\texttt{ Live demo}}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36597}{}\doxysubsubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md36597}
\hypertarget{README.md_autotoc_md36598}{}\doxysubsubsubsection{\texorpdfstring{Requirements}{Requirements}}\label{README.md_autotoc_md36598}

\begin{DoxyItemize}
\item Type\+Script 4.\+5+!
\item You must enable {\ttfamily strict} mode in your {\ttfamily tsconfig.\+json}. This is a best practice for all Type\+Script projects.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ tsconfig.json}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ //\ ...}
\DoxyCodeLine{\ \ "{}compilerOptions"{}:\ \{}
\DoxyCodeLine{\ \ \ \ //\ ...}
\DoxyCodeLine{\ \ \ \ "{}strict"{}:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{README.md_autotoc_md36599}{}\doxysubsubsubsection{\texorpdfstring{From {\ttfamily npm} (Node/\+Bun)}{From {\ttfamily npm} (Node/\+Bun)}}\label{README.md_autotoc_md36599}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ zod\ \ \ \ \ \ \ \#\ npm}
\DoxyCodeLine{yarn\ add\ zod\ \ \ \ \ \ \ \ \ \ \#\ yarn}
\DoxyCodeLine{bun\ add\ zod\ \ \ \ \ \ \ \ \ \ \ \#\ bun}
\DoxyCodeLine{pnpm\ add\ zod\ \ \ \ \ \ \ \ \ \ \#\ pnpm}

\end{DoxyCode}


Zod also publishes a canary version on every commit. To install the canary\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ zod@canary\ \ \ \ \ \ \ \#\ npm}
\DoxyCodeLine{yarn\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \#\ yarn}
\DoxyCodeLine{bun\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \ \#\ bun}
\DoxyCodeLine{pnpm\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \#\ pnpm}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36600}{}\doxysubsubsubsection{\texorpdfstring{From {\ttfamily deno.\+land/x} (Deno)}{From {\ttfamily deno.\+land/x} (Deno)}}\label{README.md_autotoc_md36600}
Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on \href{https://deno.land/x}{\texttt{ deno.\+land/x}}. The latest version can be imported like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}https://deno.land/x/zod/mod.ts"{};}

\end{DoxyCode}


You can also specify a particular version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}https://deno.land/x/zod@v3.16.1/mod.ts"{};}

\end{DoxyCode}


\begin{quote}
The rest of this README assumes you are using npm and importing directly from the {\ttfamily "{}zod"{}} package. \end{quote}
\hypertarget{README.md_autotoc_md36601}{}\doxysubsubsection{\texorpdfstring{Basic usage}{Basic usage}}\label{README.md_autotoc_md36601}
Creating a simple string schema


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ creating\ a\ schema\ for\ strings}
\DoxyCodeLine{const\ mySchema\ =\ z.string();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ parsing}
\DoxyCodeLine{mySchema.parse("{}tuna"{});\ //\ =>\ "{}tuna"{}}
\DoxyCodeLine{mySchema.parse(12);\ //\ =>\ throws\ ZodError}
\DoxyCodeLine{}
\DoxyCodeLine{//\ "{}safe"{}\ parsing\ (doesn't\ throw\ error\ if\ validation\ fails)}
\DoxyCodeLine{mySchema.safeParse("{}tuna"{});\ //\ =>\ \{\ success:\ true;\ data:\ "{}tuna"{}\ \}}
\DoxyCodeLine{mySchema.safeParse(12);\ //\ =>\ \{\ success:\ false;\ error:\ ZodError\ \}}

\end{DoxyCode}


Creating an object schema


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ User\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{User.parse(\{\ username:\ "{}Ludwig"{}\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ extract\ the\ inferred\ type}
\DoxyCodeLine{type\ User\ =\ z.infer<typeof\ User>;}
\DoxyCodeLine{//\ \{\ username:\ string\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36602}{}\doxysubsubsection{\texorpdfstring{Primitives}{Primitives}}\label{README.md_autotoc_md36602}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ primitive\ values}
\DoxyCodeLine{z.string();}
\DoxyCodeLine{z.number();}
\DoxyCodeLine{z.bigint();}
\DoxyCodeLine{z.boolean();}
\DoxyCodeLine{z.date();}
\DoxyCodeLine{z.symbol();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ empty\ types}
\DoxyCodeLine{z.undefined();}
\DoxyCodeLine{z.null();}
\DoxyCodeLine{z.void();\ //\ accepts\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ catch-\/all\ types}
\DoxyCodeLine{//\ allows\ any\ value}
\DoxyCodeLine{z.any();}
\DoxyCodeLine{z.unknown();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ never\ type}
\DoxyCodeLine{//\ allows\ no\ values}
\DoxyCodeLine{z.never();}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36603}{}\doxysubsubsection{\texorpdfstring{Coercion for primitives}{Coercion for primitives}}\label{README.md_autotoc_md36603}
Zod now provides a more convenient way to coerce primitive values.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.coerce.string();}
\DoxyCodeLine{schema.parse("{}tuna"{});\ //\ =>\ "{}tuna"{}}
\DoxyCodeLine{schema.parse(12);\ //\ =>\ "{}12"{}}
\DoxyCodeLine{schema.parse(true);\ //\ =>\ "{}true"{}}

\end{DoxyCode}


During the parsing step, the input is passed through the {\ttfamily String()} function, which is a Java\+Script built-\/in for coercing data into strings. Note that the returned schema is a {\ttfamily Zod\+String} instance so you can use all string methods.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.coerce.string().email().min(5);}

\end{DoxyCode}


All primitive types support coercion.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.coerce.string();\ //\ String(input)}
\DoxyCodeLine{z.coerce.number();\ //\ Number(input)}
\DoxyCodeLine{z.coerce.boolean();\ //\ Boolean(input)}
\DoxyCodeLine{z.coerce.bigint();\ //\ BigInt(input)}
\DoxyCodeLine{z.coerce.date();\ //\ new\ Date(input)}

\end{DoxyCode}


{\bfseries{Boolean coercion}}

Zod\textquotesingle{}s boolean coercion is very simple! It passes the value into the {\ttfamily Boolean(value)} function, that\textquotesingle{}s it. Any truthy value will resolve to {\ttfamily true}, any falsy value will resolve to {\ttfamily false}.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.coerce.boolean().parse("{}tuna"{});\ //\ =>\ true}
\DoxyCodeLine{z.coerce.boolean().parse("{}true"{});\ //\ =>\ true}
\DoxyCodeLine{z.coerce.boolean().parse("{}false"{});\ //\ =>\ true}
\DoxyCodeLine{z.coerce.boolean().parse(1);\ //\ =>\ true}
\DoxyCodeLine{z.coerce.boolean().parse([]);\ //\ =>\ true}
\DoxyCodeLine{}
\DoxyCodeLine{z.coerce.boolean().parse(0);\ //\ =>\ false}
\DoxyCodeLine{z.coerce.boolean().parse(undefined);\ //\ =>\ false}
\DoxyCodeLine{z.coerce.boolean().parse(null);\ //\ =>\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36604}{}\doxysubsubsection{\texorpdfstring{Literals}{Literals}}\label{README.md_autotoc_md36604}
Literal schemas represent a \href{https://www.typescriptlang.org/docs/handbook/2/everyday-types.html\#literal-types}{\texttt{ literal type}}, like {\ttfamily "{}hello world"{}} or {\ttfamily 5}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ tuna\ =\ z.literal("{}tuna"{});}
\DoxyCodeLine{const\ twelve\ =\ z.literal(12);}
\DoxyCodeLine{const\ twobig\ =\ z.literal(2n);\ //\ bigint\ literal}
\DoxyCodeLine{const\ tru\ =\ z.literal(true);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ terrificSymbol\ =\ Symbol("{}terrific"{});}
\DoxyCodeLine{const\ terrific\ =\ z.literal(terrificSymbol);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ retrieve\ literal\ value}
\DoxyCodeLine{tuna.value;\ //\ "{}tuna"{}}

\end{DoxyCode}


\begin{quote}
Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue. \end{quote}
\hypertarget{README.md_autotoc_md36605}{}\doxysubsubsection{\texorpdfstring{Strings}{Strings}}\label{README.md_autotoc_md36605}
Zod includes a handful of string-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ validations}
\DoxyCodeLine{z.string().max(5);}
\DoxyCodeLine{z.string().min(5);}
\DoxyCodeLine{z.string().length(5);}
\DoxyCodeLine{z.string().email();}
\DoxyCodeLine{z.string().url();}
\DoxyCodeLine{z.string().emoji();}
\DoxyCodeLine{z.string().uuid();}
\DoxyCodeLine{z.string().cuid();}
\DoxyCodeLine{z.string().cuid2();}
\DoxyCodeLine{z.string().ulid();}
\DoxyCodeLine{z.string().regex(regex);}
\DoxyCodeLine{z.string().includes(string);}
\DoxyCodeLine{z.string().startsWith(string);}
\DoxyCodeLine{z.string().endsWith(string);}
\DoxyCodeLine{z.string().datetime();\ //\ ISO\ 8601;\ default\ is\ without\ UTC\ offset,\ see\ below\ for\ options}
\DoxyCodeLine{z.string().ip();\ //\ defaults\ to\ IPv4\ and\ IPv6,\ see\ below\ for\ options}
\DoxyCodeLine{}
\DoxyCodeLine{//\ transformations}
\DoxyCodeLine{z.string().trim();\ //\ trim\ whitespace}
\DoxyCodeLine{z.string().toLowerCase();\ //\ toLowerCase}
\DoxyCodeLine{z.string().toUpperCase();\ //\ toUpperCase}

\end{DoxyCode}


\begin{quote}
Check out \href{https://github.com/validatorjs/validator.js}{\texttt{ validator.\+js}} for a bunch of other useful string validation functions that can be used in conjunction with Refinements. \end{quote}


You can customize some common error messages when creating a string schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ name\ =\ z.string(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Name\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}Name\ must\ be\ a\ string"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


When using validation methods, you can pass in an additional argument to provide a custom error message.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().min(5,\ \{\ message:\ "{}Must\ be\ 5\ or\ more\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().max(5,\ \{\ message:\ "{}Must\ be\ 5\ or\ fewer\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().length(5,\ \{\ message:\ "{}Must\ be\ exactly\ 5\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().email(\{\ message:\ "{}Invalid\ email\ address"{}\ \});}
\DoxyCodeLine{z.string().url(\{\ message:\ "{}Invalid\ url"{}\ \});}
\DoxyCodeLine{z.string().emoji(\{\ message:\ "{}Contains\ non-\/emoji\ characters"{}\ \});}
\DoxyCodeLine{z.string().uuid(\{\ message:\ "{}Invalid\ UUID"{}\ \});}
\DoxyCodeLine{z.string().includes("{}tuna"{},\ \{\ message:\ "{}Must\ include\ tuna"{}\ \});}
\DoxyCodeLine{z.string().startsWith("{}https://"{},\ \{\ message:\ "{}Must\ provide\ secure\ URL"{}\ \});}
\DoxyCodeLine{z.string().endsWith("{}.com"{},\ \{\ message:\ "{}Only\ .com\ domains\ allowed"{}\ \});}
\DoxyCodeLine{z.string().datetime(\{\ message:\ "{}Invalid\ datetime\ string!\ Must\ be\ UTC."{}\ \});}
\DoxyCodeLine{z.string().ip(\{\ message:\ "{}Invalid\ IP\ address"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36606}{}\doxysubsubsubsection{\texorpdfstring{ISO datetimes}{ISO datetimes}}\label{README.md_autotoc_md36606}
The {\ttfamily z.\+string().datetime()} method enforces ISO 8601; default is no timezone offsets and arbitrary sub-\/second decimal precision.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime();}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123456Z"{});\ //\ pass\ (arbitrary\ precision)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00+02:00"{});\ //\ fail\ (no\ offsets\ allowed)}

\end{DoxyCode}


Timezone offsets can be allowed by setting the {\ttfamily offset} option to {\ttfamily true}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime(\{\ offset:\ true\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00+02:00"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+02:00"{});\ //\ pass\ (millis\ optional)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+0200"{});\ //\ pass\ (millis\ optional)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+02"{});\ //\ pass\ (only\ offset\ hours)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ pass\ (Z\ still\ supported)}

\end{DoxyCode}


You can additionally constrain the allowable {\ttfamily precision}. By default, arbitrary sub-\/second precision is supported (but optional).


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime(\{\ precision:\ 3\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ fail}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123456Z"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36607}{}\doxysubsubsubsection{\texorpdfstring{IP addresses}{IP addresses}}\label{README.md_autotoc_md36607}
The {\ttfamily z.\+string().ip()} method by default validate IPv4 and IPv6.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ip\ =\ z.string().ip();}
\DoxyCodeLine{}
\DoxyCodeLine{ip.parse("{}192.168.1.1"{});\ //\ pass}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"{});\ //\ pass}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1"{});\ //\ pass}
\DoxyCodeLine{}
\DoxyCodeLine{ip.parse("{}256.1.1.1"{});\ //\ fail}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003"{});\ //\ fail}

\end{DoxyCode}


You can additionally set the IP {\ttfamily version}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ipv4\ =\ z.string().ip(\{\ version:\ "{}v4"{}\ \});}
\DoxyCodeLine{ipv4.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"{});\ //\ fail}
\DoxyCodeLine{}
\DoxyCodeLine{const\ ipv6\ =\ z.string().ip(\{\ version:\ "{}v6"{}\ \});}
\DoxyCodeLine{ipv6.parse("{}192.168.1.1"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36608}{}\doxysubsubsection{\texorpdfstring{Numbers}{Numbers}}\label{README.md_autotoc_md36608}
You can customize certain error messages when creating a number schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ age\ =\ z.number(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Age\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}Age\ must\ be\ a\ number"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


Zod includes a handful of number-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.number().gt(5);}
\DoxyCodeLine{z.number().gte(5);\ //\ alias\ .min(5)}
\DoxyCodeLine{z.number().lt(5);}
\DoxyCodeLine{z.number().lte(5);\ //\ alias\ .max(5)}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().int();\ //\ value\ must\ be\ an\ integer}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().positive();\ //\ \ \ \ \ >\ 0}
\DoxyCodeLine{z.number().nonnegative();\ //\ \ >=\ 0}
\DoxyCodeLine{z.number().negative();\ //\ \ \ \ \ <\ 0}
\DoxyCodeLine{z.number().nonpositive();\ //\ \ <=\ 0}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().multipleOf(5);\ //\ Evenly\ divisible\ by\ 5.\ Alias\ .step(5)}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().finite();\ //\ value\ must\ be\ finite,\ not\ Infinity\ or\ -\/Infinity}
\DoxyCodeLine{z.number().safe();\ //\ value\ must\ be\ between\ Number.MIN\_SAFE\_INTEGER\ and\ Number.MAX\_SAFE\_INTEGER}

\end{DoxyCode}


Optionally, you can pass in a second argument to provide a custom error message.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.number().lte(5,\ \{\ message:\ "{}thisüëèisüëètooüëèbig"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36609}{}\doxysubsubsection{\texorpdfstring{Big\+Ints}{Big\+Ints}}\label{README.md_autotoc_md36609}
Zod includes a handful of bigint-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.bigint().gt(5n);}
\DoxyCodeLine{z.bigint().gte(5n);\ //\ alias\ \`{}.min(5n)`}
\DoxyCodeLine{z.bigint().lt(5n);}
\DoxyCodeLine{z.bigint().lte(5n);\ //\ alias\ \`{}.max(5n)`}
\DoxyCodeLine{}
\DoxyCodeLine{z.bigint().positive();\ //\ >\ 0n}
\DoxyCodeLine{z.bigint().nonnegative();\ //\ >=\ 0n}
\DoxyCodeLine{z.bigint().negative();\ //\ <\ 0n}
\DoxyCodeLine{z.bigint().nonpositive();\ //\ <=\ 0n}
\DoxyCodeLine{}
\DoxyCodeLine{z.bigint().multipleOf(5n);\ //\ Evenly\ divisible\ by\ 5n.}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36610}{}\doxysubsubsection{\texorpdfstring{Na\+Ns}{Na\+Ns}}\label{README.md_autotoc_md36610}
You can customize certain error messages when creating a nan schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isNaN\ =\ z.nan(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}isNaN\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}isNaN\ must\ be\ not\ a\ number"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36611}{}\doxysubsubsection{\texorpdfstring{Booleans}{Booleans}}\label{README.md_autotoc_md36611}
You can customize certain error messages when creating a boolean schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isActive\ =\ z.boolean(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}isActive\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}isActive\ must\ be\ a\ boolean"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36612}{}\doxysubsubsection{\texorpdfstring{Dates}{Dates}}\label{README.md_autotoc_md36612}
Use z.\+date() to validate {\ttfamily Date} instances.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.date().safeParse(new\ Date());\ //\ success:\ true}
\DoxyCodeLine{z.date().safeParse("{}2022-\/01-\/12T00:00:00.000Z"{});\ //\ success:\ false}

\end{DoxyCode}


You can customize certain error messages when creating a date schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myDateSchema\ =\ z.date(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Please\ select\ a\ date\ and\ time"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}That's\ not\ a\ date!"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


Zod provides a handful of date-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.date().min(new\ Date("{}1900-\/01-\/01"{}),\ \{\ message:\ "{}Too\ old"{}\ \});}
\DoxyCodeLine{z.date().max(new\ Date(),\ \{\ message:\ "{}Too\ young!"{}\ \});}

\end{DoxyCode}


{\bfseries{Coercion to Date}}

Since \href{https://github.com/colinhacks/zod/releases/tag/v3.20}{\texttt{ zod 3.\+20}}, use \`{}z.coerce.date()\`{} to pass the input through {\ttfamily new Date(input)}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ dateSchema\ =\ z.coerce.date();}
\DoxyCodeLine{type\ DateSchema\ =\ z.infer<typeof\ dateSchema>;}
\DoxyCodeLine{//\ type\ DateSchema\ =\ Date}
\DoxyCodeLine{}
\DoxyCodeLine{/*\ valid\ dates\ */}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/01-\/10T00:00:00.000Z"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/01-\/10"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}1/10/23"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse(new\ Date("{}1/10/23"{})).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{/*\ invalid\ dates\ */}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/13-\/10"{}).success);\ //\ false}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}0000-\/00-\/00"{}).success);\ //\ false}

\end{DoxyCode}


For older zod versions, use \`{}z.preprocess\`{} like \href{https://github.com/colinhacks/zod/discussions/879\#discussioncomment-2036276}{\texttt{ described in this thread}}.\hypertarget{README.md_autotoc_md36613}{}\doxysubsubsection{\texorpdfstring{Zod enums}{Zod enums}}\label{README.md_autotoc_md36613}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}]);}
\DoxyCodeLine{type\ FishEnum\ =\ z.infer<typeof\ FishEnum>;}
\DoxyCodeLine{//\ 'Salmon'\ |\ 'Tuna'\ |\ 'Trout'}

\end{DoxyCode}


{\ttfamily z.\+enum} is a Zod-\/native way to declare a schema with a fixed set of allowable {\itshape string} values. Pass the array of values directly into {\ttfamily z.\+enum()}. Alternatively, use {\ttfamily as const} to define your enum values as a tuple of strings. See the \href{https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html\#const-assertions}{\texttt{ const assertion docs}} for details.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ VALUES\ =\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}]\ as\ const;}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(VALUES);}

\end{DoxyCode}


This is not allowed, since Zod isn\textquotesingle{}t able to infer the exact values of each element.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ fish\ =\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}];}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(fish);}

\end{DoxyCode}


{\bfseries{Autocompletion}}

To get autocompletion with a Zod enum, use the {\ttfamily .enum} property of your schema\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FishEnum.enum.Salmon;\ //\ =>\ autocompletes}
\DoxyCodeLine{}
\DoxyCodeLine{FishEnum.enum;}
\DoxyCodeLine{/*}
\DoxyCodeLine{=>\ \{}
\DoxyCodeLine{\ \ Salmon:\ "{}Salmon"{},}
\DoxyCodeLine{\ \ Tuna:\ "{}Tuna"{},}
\DoxyCodeLine{\ \ Trout:\ "{}Trout"{},}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}


You can also retrieve the list of options as a tuple with the {\ttfamily .options} property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FishEnum.options;\ //\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}];}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36614}{}\doxysubsubsection{\texorpdfstring{Native enums}{Native enums}}\label{README.md_autotoc_md36614}
Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-\/party library (or you don\textquotesingle{}t want to rewrite your existing enums) you can use {\ttfamily z.\+native\+Enum()}.

{\bfseries{Numeric enums}}


\begin{DoxyCode}{0}
\DoxyCodeLine{enum\ Fruits\ \{}
\DoxyCodeLine{\ \ Apple,}
\DoxyCodeLine{\ \ Banana,}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ Fruits}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse(Fruits.Apple);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(Fruits.Banana);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(0);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(1);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(3);\ //\ fails}

\end{DoxyCode}


{\bfseries{String enums}}


\begin{DoxyCode}{0}
\DoxyCodeLine{enum\ Fruits\ \{}
\DoxyCodeLine{\ \ Apple\ =\ "{}apple"{},}
\DoxyCodeLine{\ \ Banana\ =\ "{}banana"{},}
\DoxyCodeLine{\ \ Cantaloupe,\ //\ you\ can\ mix\ numerical\ and\ string\ enums}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ Fruits}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse(Fruits.Apple);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(Fruits.Cantaloupe);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}apple"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}banana"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(0);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}Cantaloupe"{});\ //\ fails}

\end{DoxyCode}


{\bfseries{Const enums}}

The {\ttfamily .native\+Enum()} function works for {\ttfamily as const} objects as well. ‚ö†Ô∏è {\ttfamily as const} requires Type\+Script 3.\+4+!


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Fruits\ =\ \{}
\DoxyCodeLine{\ \ Apple:\ "{}apple"{},}
\DoxyCodeLine{\ \ Banana:\ "{}banana"{},}
\DoxyCodeLine{\ \ Cantaloupe:\ 3,}
\DoxyCodeLine{\}\ as\ const;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ "{}apple"{}\ |\ "{}banana"{}\ |\ 3}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse("{}apple"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}banana"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(3);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}Cantaloupe"{});\ //\ fails}

\end{DoxyCode}


You can access the underlying object with the {\ttfamily .enum} property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FruitEnum.enum.Apple;\ //\ "{}apple"{}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36615}{}\doxysubsubsection{\texorpdfstring{Optionals}{Optionals}}\label{README.md_autotoc_md36615}
You can make any schema optional with {\ttfamily z.\+optional()}. This wraps the schema in a {\ttfamily Zod\+Optional} instance and returns the result.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.optional(z.string());}
\DoxyCodeLine{}
\DoxyCodeLine{schema.parse(undefined);\ //\ =>\ returns\ undefined}
\DoxyCodeLine{type\ A\ =\ z.infer<typeof\ schema>;\ //\ string\ |\ undefined}

\end{DoxyCode}


For convenience, you can also call the {\ttfamily .optional()} method on an existing schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string().optional(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{type\ C\ =\ z.infer<typeof\ user>;\ //\ \{\ username?:\ string\ |\ undefined\ \};}

\end{DoxyCode}


You can extract the wrapped schema from a {\ttfamily Zod\+Optional} instance with {\ttfamily .unwrap()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{const\ optionalString\ =\ stringSchema.optional();}
\DoxyCodeLine{optionalString.unwrap()\ ===\ stringSchema;\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36616}{}\doxysubsubsection{\texorpdfstring{Nullables}{Nullables}}\label{README.md_autotoc_md36616}
Similarly, you can create nullable types with {\ttfamily z.\+nullable()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullableString\ =\ z.nullable(z.string());}
\DoxyCodeLine{nullableString.parse("{}asdf"{});\ //\ =>\ "{}asdf"{}}
\DoxyCodeLine{nullableString.parse(null);\ //\ =>\ null}

\end{DoxyCode}


Or use the {\ttfamily .nullable()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ E\ =\ z.string().nullable();\ //\ equivalent\ to\ nullableString}
\DoxyCodeLine{type\ E\ =\ z.infer<typeof\ E>;\ //\ string\ |\ null}

\end{DoxyCode}


Extract the inner schema with {\ttfamily .unwrap()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{const\ nullableString\ =\ stringSchema.nullable();}
\DoxyCodeLine{nullableString.unwrap()\ ===\ stringSchema;\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36617}{}\doxysubsubsection{\texorpdfstring{Objects}{Objects}}\label{README.md_autotoc_md36617}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ all\ properties\ are\ required\ by\ default}
\DoxyCodeLine{const\ Dog\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\ \ age:\ z.number(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ extract\ the\ inferred\ type\ like\ this}
\DoxyCodeLine{type\ Dog\ =\ z.infer<typeof\ Dog>;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to:}
\DoxyCodeLine{type\ Dog\ =\ \{}
\DoxyCodeLine{\ \ name:\ string;}
\DoxyCodeLine{\ \ age:\ number;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36618}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .shape}}{{\ttfamily .shape}}}\label{README.md_autotoc_md36618}
Use {\ttfamily .shape} to access the schemas for a particular key.


\begin{DoxyCode}{0}
\DoxyCodeLine{Dog.shape.name;\ //\ =>\ string\ schema}
\DoxyCodeLine{Dog.shape.age;\ //\ =>\ number\ schema}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36619}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .keyof}}{{\ttfamily .keyof}}}\label{README.md_autotoc_md36619}
Use {\ttfamily .keyof} to create a {\ttfamily Zod\+Enum} schema from the keys of an object schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ keySchema\ =\ Dog.keyof();}
\DoxyCodeLine{keySchema;\ //\ ZodEnum<["{}name"{},\ "{}age"{}]>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36620}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .extend}}{{\ttfamily .extend}}}\label{README.md_autotoc_md36620}
You can add additional fields to an object schema with the {\ttfamily .extend} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ DogWithBreed\ =\ Dog.extend(\{}
\DoxyCodeLine{\ \ breed:\ z.string(),}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can use {\ttfamily .extend} to overwrite fields! Be careful with this power!\hypertarget{README.md_autotoc_md36621}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .merge}}{{\ttfamily .merge}}}\label{README.md_autotoc_md36621}
Equivalent to {\ttfamily A.\+extend(B.\+shape)}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ BaseTeacher\ =\ z.object(\{\ students:\ z.array(z.string())\ \});}
\DoxyCodeLine{const\ HasID\ =\ z.object(\{\ id:\ z.string()\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ Teacher\ =\ BaseTeacher.merge(HasID);}
\DoxyCodeLine{type\ Teacher\ =\ z.infer<typeof\ Teacher>;\ //\ =>\ \{\ students:\ string[],\ id:\ string\ \}}

\end{DoxyCode}


\begin{quote}
If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "{}unknown\+Keys"{} policy (strip/strict/passthrough) and the catchall schema of B. \end{quote}
\hypertarget{README.md_autotoc_md36622}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .pick/.omit}}{{\ttfamily .pick/.omit}}}\label{README.md_autotoc_md36622}
Inspired by Type\+Script\textquotesingle{}s built-\/in {\ttfamily Pick} and {\ttfamily Omit} utility types, all Zod object schemas have {\ttfamily .pick} and {\ttfamily .omit} methods that return a modified version. Consider this Recipe schema\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Recipe\ =\ z.object(\{}
\DoxyCodeLine{\ \ id:\ z.string(),}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\ \ ingredients:\ z.array(z.string()),}
\DoxyCodeLine{\});}

\end{DoxyCode}


To only keep certain keys, use {\ttfamily .pick} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ JustTheName\ =\ Recipe.pick(\{\ name:\ true\ \});}
\DoxyCodeLine{type\ JustTheName\ =\ z.infer<typeof\ JustTheName>;}
\DoxyCodeLine{//\ =>\ \{\ name:\ string\ \}}

\end{DoxyCode}


To remove certain keys, use {\ttfamily .omit} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ NoIDRecipe\ =\ Recipe.omit(\{\ id:\ true\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ NoIDRecipe\ =\ z.infer<typeof\ NoIDRecipe>;}
\DoxyCodeLine{//\ =>\ \{\ name:\ string,\ ingredients:\ string[]\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36623}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .partial}}{{\ttfamily .partial}}}\label{README.md_autotoc_md36623}
Inspired by the built-\/in Type\+Script utility type \href{https://www.typescriptlang.org/docs/handbook/utility-types.html\#partialtype}{\texttt{ Partial}}, the {\ttfamily .partial} method makes all properties optional.

Starting from this object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ email:\ z.string(),}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ \{\ email:\ string;\ username:\ string\ \}}

\end{DoxyCode}


We can create a partial version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ partialUser\ =\ user.partial();}
\DoxyCodeLine{//\ \{\ email?:\ string\ |\ undefined;\ username?:\ string\ |\ undefined\ \}}

\end{DoxyCode}


You can also specify which properties to make optional\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalEmail\ =\ user.partial(\{}
\DoxyCodeLine{\ \ email:\ true,}
\DoxyCodeLine{\});}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ email?:\ string\ |\ undefined;}
\DoxyCodeLine{\ \ username:\ string}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36624}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .deep\+Partial}}{{\ttfamily .deep\+Partial}}}\label{README.md_autotoc_md36624}
The {\ttfamily .partial} method is shallow ‚Äî it only applies one level deep. There is also a "{}deep"{} version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\ \ location:\ z.object(\{}
\DoxyCodeLine{\ \ \ \ latitude:\ z.number(),}
\DoxyCodeLine{\ \ \ \ longitude:\ z.number(),}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{\ \ strings:\ z.array(z.object(\{\ value:\ z.string()\ \})),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ deepPartialUser\ =\ user.deepPartial();}
\DoxyCodeLine{}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ username?:\ string\ |\ undefined,}
\DoxyCodeLine{\ \ location?:\ \{}
\DoxyCodeLine{\ \ \ \ latitude?:\ number\ |\ undefined;}
\DoxyCodeLine{\ \ \ \ longitude?:\ number\ |\ undefined;}
\DoxyCodeLine{\ \ \}\ |\ undefined,}
\DoxyCodeLine{\ \ strings?:\ \{\ value?:\ string\}[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}


\begin{quote}
Important limitation\+: deep partials only work as expected in hierarchies of objects, arrays, and tuples. \end{quote}
\hypertarget{README.md_autotoc_md36625}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .required}}{{\ttfamily .required}}}\label{README.md_autotoc_md36625}
Contrary to the {\ttfamily .partial} method, the {\ttfamily .required} method makes all properties required.

Starting from this object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ email:\ z.string(),}
\DoxyCodeLine{\ \ \ \ username:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .partial();}
\DoxyCodeLine{//\ \{\ email?:\ string\ |\ undefined;\ username?:\ string\ |\ undefined\ \}}

\end{DoxyCode}


We can create a required version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ requiredUser\ =\ user.required();}
\DoxyCodeLine{//\ \{\ email:\ string;\ username:\ string\ \}}

\end{DoxyCode}


You can also specify which properties to make required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ requiredEmail\ =\ user.required(\{}
\DoxyCodeLine{\ \ email:\ true,}
\DoxyCodeLine{\});}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ email:\ string;}
\DoxyCodeLine{\ \ username?:\ string\ |\ undefined;}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36626}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .passthrough}}{{\ttfamily .passthrough}}}\label{README.md_autotoc_md36626}
By default Zod object schemas strip out unrecognized keys during parsing.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ \{\ name:\ "{}bob\ dylan"{}\ \}}
\DoxyCodeLine{//\ extraKey\ has\ been\ stripped}

\end{DoxyCode}


Instead, if you want to pass through unknown keys, use {\ttfamily .passthrough()} .


\begin{DoxyCode}{0}
\DoxyCodeLine{person.passthrough().parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ \{\ name:\ "{}bob\ dylan"{},\ extraKey:\ 61\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36627}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .strict}}{{\ttfamily .strict}}}\label{README.md_autotoc_md36627}
By default Zod object schemas strip out unrecognized keys during parsing. You can {\itshape disallow} unknown keys with {\ttfamily .strict()} . If there are any unknown keys in the input, Zod will throw an error.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .strict();}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ throws\ ZodError}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36628}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .strip}}{{\ttfamily .strip}}}\label{README.md_autotoc_md36628}
You can use the {\ttfamily .strip} method to reset an object schema to the default behavior (stripping unrecognized keys).\hypertarget{README.md_autotoc_md36629}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .catchall}}{{\ttfamily .catchall}}}\label{README.md_autotoc_md36629}
You can pass a "{}catchall"{} schema into an object schema. All unknown keys will be validated against it.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .catchall(z.number());}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ validExtraKey:\ 61,\ //\ works\ fine}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ validExtraKey:\ false,\ //\ fails}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ throws\ ZodError}

\end{DoxyCode}


Using {\ttfamily .catchall()} obviates {\ttfamily .passthrough()} , {\ttfamily .strip()} , or {\ttfamily .strict()}. All keys are now considered "{}known"{}.\hypertarget{README.md_autotoc_md36630}{}\doxysubsubsection{\texorpdfstring{Arrays}{Arrays}}\label{README.md_autotoc_md36630}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringArray\ =\ z.array(z.string());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent}
\DoxyCodeLine{const\ stringArray\ =\ z.string().array();}

\end{DoxyCode}


Be careful with the {\ttfamily .array()} method. It returns a new {\ttfamily Zod\+Array} instance. This means the {\itshape order} in which you call methods matters. For instance\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().optional().array();\ //\ (string\ |\ undefined)[]}
\DoxyCodeLine{z.string().array().optional();\ //\ string[]\ |\ undefined}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36631}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .element}}{{\ttfamily .element}}}\label{README.md_autotoc_md36631}
Use {\ttfamily .element} to access the schema for an element of the array.


\begin{DoxyCode}{0}
\DoxyCodeLine{stringArray.element;\ //\ =>\ string\ schema}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36632}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nonempty}}{{\ttfamily .nonempty}}}\label{README.md_autotoc_md36632}
If you want to ensure that an array contains at least one element, use {\ttfamily .nonempty()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nonEmptyStrings\ =\ z.string().array().nonempty();}
\DoxyCodeLine{//\ the\ inferred\ type\ is\ now}
\DoxyCodeLine{//\ [string,\ ...string[]]}
\DoxyCodeLine{}
\DoxyCodeLine{nonEmptyStrings.parse([]);\ //\ throws:\ "{}Array\ cannot\ be\ empty"{}}
\DoxyCodeLine{nonEmptyStrings.parse(["{}Ariana\ Grande"{}]);\ //\ passes}

\end{DoxyCode}


You can optionally specify a custom error message\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ optional\ custom\ error\ message}
\DoxyCodeLine{const\ nonEmptyStrings\ =\ z.string().array().nonempty(\{}
\DoxyCodeLine{\ \ message:\ "{}Can't\ be\ empty!"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36633}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .min/.max/.length}}{{\ttfamily .min/.max/.length}}}\label{README.md_autotoc_md36633}

\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().array().min(5);\ //\ must\ contain\ 5\ or\ more\ items}
\DoxyCodeLine{z.string().array().max(5);\ //\ must\ contain\ 5\ or\ fewer\ items}
\DoxyCodeLine{z.string().array().length(5);\ //\ must\ contain\ 5\ items\ exactly}

\end{DoxyCode}


Unlike {\ttfamily .nonempty()} these methods do not change the inferred type.\hypertarget{README.md_autotoc_md36634}{}\doxysubsubsection{\texorpdfstring{Tuples}{Tuples}}\label{README.md_autotoc_md36634}
Unlike arrays, tuples have a fixed number of elements and each element can have a different type.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ athleteSchema\ =\ z.tuple([}
\DoxyCodeLine{\ \ z.string(),\ //\ name}
\DoxyCodeLine{\ \ z.number(),\ //\ jersey\ number}
\DoxyCodeLine{\ \ z.object(\{}
\DoxyCodeLine{\ \ \ \ pointsScored:\ z.number(),}
\DoxyCodeLine{\ \ \}),\ //\ statistics}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Athlete\ =\ z.infer<typeof\ athleteSchema>;}
\DoxyCodeLine{//\ type\ Athlete\ =\ [string,\ number,\ \{\ pointsScored:\ number\ \}]}

\end{DoxyCode}


A variadic ("{}rest"{}) argument can be added with the {\ttfamily .rest} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ variadicTuple\ =\ z.tuple([z.string()]).rest(z.number());}
\DoxyCodeLine{const\ result\ =\ variadicTuple.parse(["{}hello"{},\ 1,\ 2,\ 3]);}
\DoxyCodeLine{//\ =>\ [string,\ ...number[]];}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36635}{}\doxysubsubsection{\texorpdfstring{Unions}{Unions}}\label{README.md_autotoc_md36635}
Zod includes a built-\/in {\ttfamily z.\+union} method for composing "{}\+OR"{} types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.union([z.string(),\ z.number()]);}
\DoxyCodeLine{}
\DoxyCodeLine{stringOrNumber.parse("{}foo"{});\ //\ passes}
\DoxyCodeLine{stringOrNumber.parse(14);\ //\ passes}

\end{DoxyCode}


Zod will test the input against each of the "{}options"{} in order and return the first value that validates successfully.

For convenience, you can also use the \`{}.or\`{} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.string().or(z.number());}

\end{DoxyCode}


{\bfseries{Optional string validation\+:}}

To validate an optional form input, you can union the desired string validation with an empty string literal.

This example validates an input that is optional but needs to contain a valid URL\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalUrl\ =\ z.union([z.string().url().nullish(),\ z.literal("{}"{})]);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(optionalUrl.safeParse(undefined).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse(null).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}"{}).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}https://zod.dev"{}).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}not\ a\ valid\ url"{}).success);\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36636}{}\doxysubsubsection{\texorpdfstring{Discriminated unions}{Discriminated unions}}\label{README.md_autotoc_md36636}
A discriminated union is a union of object schemas that all share a particular key.


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ MyUnion\ =}
\DoxyCodeLine{\ \ |\ \{\ status:\ "{}success"{};\ data:\ string\ \}}
\DoxyCodeLine{\ \ |\ \{\ status:\ "{}failed"{};\ error:\ Error\ \};}

\end{DoxyCode}


Such unions can be represented with the {\ttfamily z.\+discriminated\+Union} method. This enables faster evaluation, because Zod can check the {\itshape discriminator key} ({\ttfamily status} in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.

With the basic union method, the input is tested against each of the provided "{}options"{}, and in the case of invalidity, issues for all the "{}options"{} are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "{}options"{}, testing against it, and showing only the issues related to this "{}option"{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myUnion\ =\ z.discriminatedUnion("{}status"{},\ [}
\DoxyCodeLine{\ \ z.object(\{\ status:\ z.literal("{}success"{}),\ data:\ z.string()\ \}),}
\DoxyCodeLine{\ \ z.object(\{\ status:\ z.literal("{}failed"{}),\ error:\ z.instanceof(Error)\ \}),}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{myUnion.parse(\{\ status:\ "{}success"{},\ data:\ "{}yippie\ ki\ yay"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36637}{}\doxysubsubsection{\texorpdfstring{Records}{Records}}\label{README.md_autotoc_md36637}
Record schemas are used to validate types such as {\ttfamily \{ \mbox{[}k\+: string\mbox{]}\+: number \}}.

If you want to validate the {\itshape values} of an object against some schema but don\textquotesingle{}t care about the keys, use {\ttfamily z.\+record(value\+Type)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ NumberCache\ =\ z.record(z.number());}
\DoxyCodeLine{}
\DoxyCodeLine{type\ NumberCache\ =\ z.infer<typeof\ NumberCache>;}
\DoxyCodeLine{//\ =>\ \{\ [k:\ string]:\ number\ \}}

\end{DoxyCode}


This is particularly useful for storing or caching items by ID.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ userSchema\ =\ z.object(\{\ name:\ z.string()\ \});}
\DoxyCodeLine{const\ userStoreSchema\ =\ z.record(userSchema);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ UserStore\ =\ z.infer<typeof\ userStoreSchema>;}
\DoxyCodeLine{//\ =>\ type\ UserStore\ =\ \{\ [\ x:\ string\ ]:\ \{\ name:\ string\ \}\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ userStore:\ UserStore\ =\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{userStore["{}77d2586b-\/9e8e-\/4ecf-\/8b21-\/ea7e0530eadd"{}]\ =\ \{}
\DoxyCodeLine{\ \ name:\ "{}Carlotta"{},}
\DoxyCodeLine{\};\ //\ passes}
\DoxyCodeLine{}
\DoxyCodeLine{userStore["{}77d2586b-\/9e8e-\/4ecf-\/8b21-\/ea7e0530eadd"{}]\ =\ \{}
\DoxyCodeLine{\ \ whatever:\ "{}Ice\ cream\ sundae"{},}
\DoxyCodeLine{\};\ //\ TypeError}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36638}{}\doxysubsubsubsection{\texorpdfstring{Record key type}{Record key type}}\label{README.md_autotoc_md36638}
If you want to validate both the keys and the values, use {\ttfamily z.\+record(key\+Type, value\+Type)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ NoEmptyKeysSchema\ =\ z.record(z.string().min(1),\ z.number());}
\DoxyCodeLine{NoEmptyKeysSchema.parse(\{\ count:\ 1\ \});\ //\ =>\ \{\ 'count':\ 1\ \}}
\DoxyCodeLine{NoEmptyKeysSchema.parse(\{\ "{}"{}:\ 1\ \});\ //\ fails}

\end{DoxyCode}


{\itshape (Notice how when passing two arguments, {\ttfamily value\+Type} is the second argument)}

{\bfseries{A note on numerical keys}}

While {\ttfamily z.\+record(key\+Type, value\+Type)} is able to accept numerical key types and Type\+Script\textquotesingle{}s built-\/in Record type is {\ttfamily Record\texorpdfstring{$<$}{<}Key\+Type, Value\+Type\texorpdfstring{$>$}{>}}, it\textquotesingle{}s hard to represent the Type\+Script type {\ttfamily Record\texorpdfstring{$<$}{<}number, any\texorpdfstring{$>$}{>}} in Zod.

As it turns out, Type\+Script\textquotesingle{}s behavior surrounding {\ttfamily \mbox{[}k\+: number\mbox{]}} is a little unintuitive\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ testMap:\ \{\ [k:\ number]:\ string\ \}\ =\ \{}
\DoxyCodeLine{\ \ 1:\ "{}one"{},}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{for\ (const\ key\ in\ testMap)\ \{}
\DoxyCodeLine{\ \ console.log(`\$\{key\}:\ \$\{typeof\ key\}`);}
\DoxyCodeLine{\}}
\DoxyCodeLine{//\ prints:\ \`{}1:\ string`}

\end{DoxyCode}


As you can see, Java\+Script automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn\textquotesingle{}t make sense to provide a way of creating a record schema with numerical keys, since there\textquotesingle{}s no such thing as a numerical key in runtime Java\+Script.\hypertarget{README.md_autotoc_md36639}{}\doxysubsubsection{\texorpdfstring{Maps}{Maps}}\label{README.md_autotoc_md36639}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringNumberMap\ =\ z.map(z.string(),\ z.number());}
\DoxyCodeLine{}
\DoxyCodeLine{type\ StringNumberMap\ =\ z.infer<typeof\ stringNumberMap>;}
\DoxyCodeLine{//\ type\ StringNumberMap\ =\ Map<string,\ number>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36640}{}\doxysubsubsection{\texorpdfstring{Sets}{Sets}}\label{README.md_autotoc_md36640}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberSet\ =\ z.set(z.number());}
\DoxyCodeLine{type\ NumberSet\ =\ z.infer<typeof\ numberSet>;}
\DoxyCodeLine{//\ type\ NumberSet\ =\ Set<number>}

\end{DoxyCode}


Set schemas can be further constrained with the following utility methods.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.set(z.string()).nonempty();\ //\ must\ contain\ at\ least\ one\ item}
\DoxyCodeLine{z.set(z.string()).min(5);\ //\ must\ contain\ 5\ or\ more\ items}
\DoxyCodeLine{z.set(z.string()).max(5);\ //\ must\ contain\ 5\ or\ fewer\ items}
\DoxyCodeLine{z.set(z.string()).size(5);\ //\ must\ contain\ 5\ items\ exactly}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36641}{}\doxysubsubsection{\texorpdfstring{Intersections}{Intersections}}\label{README.md_autotoc_md36641}
Intersections are useful for creating "{}logical AND"{} types. This is useful for intersecting two object types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Person\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ Employee\ =\ z.object(\{}
\DoxyCodeLine{\ \ role:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ EmployedPerson\ =\ z.intersection(Person,\ Employee);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to:}
\DoxyCodeLine{const\ EmployedPerson\ =\ Person.and(Employee);}

\end{DoxyCode}


Though in many cases, it is recommended to use {\ttfamily A.\+merge(\+B)} to merge two objects. The {\ttfamily .merge} method returns a new {\ttfamily Zod\+Object} instance, whereas {\ttfamily A.\+and(\+B)} returns a less useful {\ttfamily Zod\+Intersection} instance that lacks common object methods like {\ttfamily pick} and {\ttfamily omit}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ a\ =\ z.union([z.number(),\ z.string()]);}
\DoxyCodeLine{const\ b\ =\ z.union([z.number(),\ z.boolean()]);}
\DoxyCodeLine{const\ c\ =\ z.intersection(a,\ b);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ c\ =\ z.infer<typeof\ c>;\ //\ =>\ number}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36642}{}\doxysubsubsection{\texorpdfstring{Recursive types}{Recursive types}}\label{README.md_autotoc_md36642}
You can define a recursive schema in Zod, but because of a limitation of Type\+Script, their type can\textquotesingle{}t be statically inferred. Instead you\textquotesingle{}ll need to define the type definition manually, and provide it to Zod as a "{}type hint"{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ baseCategorySchema\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Category\ =\ z.infer<typeof\ baseCategorySchema>\ \&\ \{}
\DoxyCodeLine{\ \ subcategories:\ Category[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ categorySchema:\ z.ZodType<Category>\ =\ baseCategorySchema.extend(\{}
\DoxyCodeLine{\ \ subcategories:\ z.lazy(()\ =>\ categorySchema.array()),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{categorySchema.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}People"{},}
\DoxyCodeLine{\ \ subcategories:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ name:\ "{}Politicians"{},}
\DoxyCodeLine{\ \ \ \ \ \ subcategories:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ name:\ "{}Presidents"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ subcategories:\ [],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ ],}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ ],}
\DoxyCodeLine{\});\ //\ passes}

\end{DoxyCode}


Thanks to \href{https://github.com/crasite}{\texttt{ crasite}} for this example.\hypertarget{README.md_autotoc_md36643}{}\doxysubsubsubsection{\texorpdfstring{Zod\+Type with Zod\+Effects}{Zod\+Type with Zod\+Effects}}\label{README.md_autotoc_md36643}
When using {\ttfamily z.\+Zod\+Type} with {\ttfamily z.\+Zod\+Effects} ( \href{https://github.com/colinhacks/zod\#refine}{\texttt{ {\ttfamily .refine}}}, \href{https://github.com/colinhacks/zod\#transform}{\texttt{ {\ttfamily .transform}}}, \href{https://github.com/colinhacks/zod\#preprocess}{\texttt{ {\ttfamily preprocess}}}, etc... ), you will need to define the input and output types of the schema. {\ttfamily z.\+Zod\+Type\texorpdfstring{$<$}{<}Output, z.\+Zod\+Type\+Def, Input\texorpdfstring{$>$}{>}}


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isValidId\ =\ (id:\ string):\ id\ is\ \`{}\$\{string\}/\$\{string\}`\ =>}
\DoxyCodeLine{\ \ id.split("{}/"{}).length\ ===\ 2;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ baseSchema\ =\ z.object(\{}
\DoxyCodeLine{\ \ id:\ z.string().refine(isValidId),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Input\ =\ z.input<typeof\ baseSchema>\ \&\ \{}
\DoxyCodeLine{\ \ children:\ Input[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Output\ =\ z.output<typeof\ baseSchema>\ \&\ \{}
\DoxyCodeLine{\ \ children:\ Output[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ schema:\ z.ZodType<Output,\ z.ZodTypeDef,\ Input>\ =\ baseSchema.extend(\{}
\DoxyCodeLine{\ \ children:\ z.lazy(()\ =>\ schema.array()),}
\DoxyCodeLine{\});}

\end{DoxyCode}


Thanks to \href{https://github.com/marcus13371337}{\texttt{ marcus13371337}} and \href{https://github.com/JoelBeeldi}{\texttt{ Joel\+Beeldi}} for this example.\hypertarget{README.md_autotoc_md36644}{}\doxysubsubsubsection{\texorpdfstring{JSON type}{JSON type}}\label{README.md_autotoc_md36644}
If you want to validate any JSON value, you can use the snippet below.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ literalSchema\ =\ z.union([z.string(),\ z.number(),\ z.boolean(),\ z.null()]);}
\DoxyCodeLine{type\ Literal\ =\ z.infer<typeof\ literalSchema>;}
\DoxyCodeLine{type\ Json\ =\ Literal\ |\ \{\ [key:\ string]:\ Json\ \}\ |\ Json[];}
\DoxyCodeLine{const\ jsonSchema:\ z.ZodType<Json>\ =\ z.lazy(()\ =>}
\DoxyCodeLine{\ \ z.union([literalSchema,\ z.array(jsonSchema),\ z.record(jsonSchema)])}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{jsonSchema.parse(data);}

\end{DoxyCode}


Thanks to \href{https://github.com/ggoodman}{\texttt{ ggoodman}} for suggesting this.\hypertarget{README.md_autotoc_md36645}{}\doxysubsubsubsection{\texorpdfstring{Cyclical objects}{Cyclical objects}}\label{README.md_autotoc_md36645}
Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop.\hypertarget{README.md_autotoc_md36646}{}\doxysubsubsection{\texorpdfstring{Promises}{Promises}}\label{README.md_autotoc_md36646}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberPromise\ =\ z.promise(z.number());}

\end{DoxyCode}


"{}\+Parsing"{} works a little differently with promise schemas. Validation happens in two parts\+:


\begin{DoxyEnumerate}
\item Zod synchronously checks that the input is an instance of Promise (i.\+e. an object with {\ttfamily .then} and {\ttfamily .catch} methods.).
\item Zod uses {\ttfamily .then} to attach an additional validation step onto the existing Promise. You\textquotesingle{}ll have to use {\ttfamily .catch} on the returned Promise to handle validation failures.
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{numberPromise.parse("{}tuna"{});}
\DoxyCodeLine{//\ ZodError:\ Non-\/Promise\ type:\ string}
\DoxyCodeLine{}
\DoxyCodeLine{numberPromise.parse(Promise.resolve("{}tuna"{}));}
\DoxyCodeLine{//\ =>\ Promise<number>}
\DoxyCodeLine{}
\DoxyCodeLine{const\ test\ =\ async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ await\ numberPromise.parse(Promise.resolve("{}tuna"{}));}
\DoxyCodeLine{\ \ //\ ZodError:\ Non-\/number\ type:\ string}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ await\ numberPromise.parse(Promise.resolve(3.14));}
\DoxyCodeLine{\ \ //\ =>\ 3.14}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36647}{}\doxysubsubsection{\texorpdfstring{Instanceof}{Instanceof}}\label{README.md_autotoc_md36647}
You can use {\ttfamily z.\+instanceof} to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-\/party libraries.


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ Test\ \{}
\DoxyCodeLine{\ \ name:\ string;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ TestSchema\ =\ z.instanceof(Test);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ blob:\ any\ =\ "{}whatever"{};}
\DoxyCodeLine{TestSchema.parse(new\ Test());\ //\ passes}
\DoxyCodeLine{TestSchema.parse("{}blob"{});\ //\ throws}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36648}{}\doxysubsubsection{\texorpdfstring{Functions}{Functions}}\label{README.md_autotoc_md36648}
Zod also lets you define "{}function schemas"{}. This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "{}business logic"{}.

You can create a function schema with {\ttfamily z.\+function(args, return\+Type)} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z.function();}
\DoxyCodeLine{}
\DoxyCodeLine{type\ myFunction\ =\ z.infer<typeof\ myFunction>;}
\DoxyCodeLine{//\ =>\ ()=>unknown}

\end{DoxyCode}


Define inputs and outputs.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string(),\ z.number())\ //\ accepts\ an\ arbitrary\ number\ of\ arguments}
\DoxyCodeLine{\ \ .returns(z.boolean());}
\DoxyCodeLine{}
\DoxyCodeLine{type\ myFunction\ =\ z.infer<typeof\ myFunction>;}
\DoxyCodeLine{//\ =>\ (arg0:\ string,\ arg1:\ number)=>boolean}

\end{DoxyCode}


Function schemas have an {\ttfamily .implement()} method which accepts a function and returns a new function that automatically validates its inputs and outputs.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ trimmedLength\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string())\ //\ accepts\ an\ arbitrary\ number\ of\ arguments}
\DoxyCodeLine{\ \ .returns(z.number())}
\DoxyCodeLine{\ \ .implement((x)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ TypeScript\ knows\ x\ is\ a\ string!}
\DoxyCodeLine{\ \ \ \ return\ x.trim().length;}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{trimmedLength("{}sandwich"{});\ //\ =>\ 8}
\DoxyCodeLine{trimmedLength("{}\ asdf\ "{});\ //\ =>\ 4}

\end{DoxyCode}


If you only care about validating inputs, just don\textquotesingle{}t call the {\ttfamily .returns()} method. The output type will be inferred from the implementation.

\begin{quote}
You can use the special {\ttfamily z.\+void()} option if your function doesn\textquotesingle{}t return anything. This will let Zod properly infer the type of void-\/returning functions. (Void-\/returning functions actually return undefined.) \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string())}
\DoxyCodeLine{\ \ .implement((arg)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ return\ [arg.length];}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{myFunction;\ //\ (arg:\ string)=>number[]}

\end{DoxyCode}


Extract the input and output schemas from a function schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{myFunction.parameters();}
\DoxyCodeLine{//\ =>\ ZodTuple<[ZodString,\ ZodNumber]>}
\DoxyCodeLine{}
\DoxyCodeLine{myFunction.returnType();}
\DoxyCodeLine{//\ =>\ ZodBoolean}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36649}{}\doxysubsubsection{\texorpdfstring{Preprocess}{Preprocess}}\label{README.md_autotoc_md36649}
\begin{quote}
Zod now supports primitive coercion without the need for {\ttfamily .preprocess()}. See the coercion docs for more information. \end{quote}


Typically Zod operates under a "{}parse then transform"{} paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the .transform docs.)

But sometimes you want to apply some transform to the input {\itshape before} parsing happens. A common use case\+: type coercion. Zod enables this with the {\ttfamily z.\+preprocess()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ castToString\ =\ z.preprocess((val)\ =>\ String(val),\ z.string());}

\end{DoxyCode}


This returns a {\ttfamily Zod\+Effects} instance. {\ttfamily Zod\+Effects} is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.\hypertarget{README.md_autotoc_md36650}{}\doxysubsubsection{\texorpdfstring{Custom schemas}{Custom schemas}}\label{README.md_autotoc_md36650}
You can create a Zod schema for any Type\+Script type by using {\ttfamily z.\+custom()}. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ px\ =\ z.custom<`\$\{number\}px`>((val)\ =>\ \{}
\DoxyCodeLine{\ \ return\ typeof\ val\ ===\ "{}string"{}\ ?\ /\string^\(\backslash\)d+px\$/.test(val)\ :\ false;}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ px\ =\ z.infer<typeof\ px>;\ //\ \`{}\$\{number\}px`}
\DoxyCodeLine{}
\DoxyCodeLine{px.parse("{}42px"{});\ //\ "{}42px"{}}
\DoxyCodeLine{px.parse("{}42vw"{});\ //\ throws;}

\end{DoxyCode}


If you don\textquotesingle{}t provide a validation function, Zod will allow any value. This can be dangerous!


\begin{DoxyCode}{0}
\DoxyCodeLine{z.custom<\{\ arg:\ string\ \}>();\ //\ performs\ no\ validation}

\end{DoxyCode}


You can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of \`{}.refine\`{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.custom<...>((val)\ =>\ ...,\ "{}custom\ error\ message"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36651}{}\doxysubsubsection{\texorpdfstring{Schema methods}{Schema methods}}\label{README.md_autotoc_md36651}
All Zod schemas contain certain methods.\hypertarget{README.md_autotoc_md36652}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .parse}}{{\ttfamily .parse}}}\label{README.md_autotoc_md36652}
{\ttfamily .parse(data\+: unknown)\+: T}

Given any Zod schema, you can call its {\ttfamily .parse} method to check {\ttfamily data} is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.

\begin{quote}
IMPORTANT\+: The value returned by {\ttfamily .parse} is a {\itshape deep clone} of the variable you passed in. \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{}
\DoxyCodeLine{stringSchema.parse("{}fish"{});\ //\ =>\ returns\ "{}fish"{}}
\DoxyCodeLine{stringSchema.parse(12);\ //\ throws\ error}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36653}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .parse\+Async}}{{\ttfamily .parse\+Async}}}\label{README.md_autotoc_md36653}
{\ttfamily .parse\+Async(data\+:unknown)\+: Promise\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}

If you use asynchronous refinements or transforms (more on those later), you\textquotesingle{}ll need to use {\ttfamily .parse\+Async}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string().refine(async\ (val)\ =>\ val.length\ <=\ 8);}
\DoxyCodeLine{}
\DoxyCodeLine{await\ stringSchema.parseAsync("{}hello"{});\ //\ =>\ returns\ "{}hello"{}}
\DoxyCodeLine{await\ stringSchema.parseAsync("{}hello\ world"{});\ //\ =>\ throws\ error}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36654}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .safe\+Parse}}{{\ttfamily .safe\+Parse}}}\label{README.md_autotoc_md36654}
{\ttfamily .safe\+Parse(data\+:unknown)\+: \{ success\+: true; data\+: T; \} \texorpdfstring{$\vert$}{|} \{ success\+: false; error\+: Zod\+Error; \}}

If you don\textquotesingle{}t want Zod to throw errors when validation fails, use {\ttfamily .safe\+Parse}. This method returns an object containing either the successfully parsed data or a Zod\+Error instance containing detailed information about the validation problems.


\begin{DoxyCode}{0}
\DoxyCodeLine{stringSchema.safeParse(12);}
\DoxyCodeLine{//\ =>\ \{\ success:\ false;\ error:\ ZodError\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{stringSchema.safeParse("{}billie"{});}
\DoxyCodeLine{//\ =>\ \{\ success:\ true;\ data:\ 'billie'\ \}}

\end{DoxyCode}


The result is a {\itshape discriminated union}, so you can handle errors very conveniently\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ stringSchema.safeParse("{}billie"{});}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ //\ handle\ error\ then\ return}
\DoxyCodeLine{\ \ result.error;}
\DoxyCodeLine{\}\ else\ \{}
\DoxyCodeLine{\ \ //\ do\ something}
\DoxyCodeLine{\ \ result.data;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36655}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .safe\+Parse\+Async}}{{\ttfamily .safe\+Parse\+Async}}}\label{README.md_autotoc_md36655}
\begin{quote}
Alias\+: {\ttfamily .spa} \end{quote}


An asynchronous version of {\ttfamily safe\+Parse}.


\begin{DoxyCode}{0}
\DoxyCodeLine{await\ stringSchema.safeParseAsync("{}billie"{});}

\end{DoxyCode}


For convenience, this has been aliased to {\ttfamily .spa}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{await\ stringSchema.spa("{}billie"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36656}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .refine}}{{\ttfamily .refine}}}\label{README.md_autotoc_md36656}
{\ttfamily .refine(validator\+: (data\+:T)=\texorpdfstring{$>$}{>}any, params?\+: Refine\+Params)}

Zod lets you provide custom validation logic via {\itshape refinements}. (For advanced features like creating multiple issues and customizing error codes, see \`{}.super\+Refine\`{}.)

Zod was designed to mirror Type\+Script as closely as possible. But there are many so-\/called "{}refinement types"{} you may wish to check for that can\textquotesingle{}t be represented in Type\+Script\textquotesingle{}s type system. For instance\+: checking that a number is an integer or that a string is a valid email address.

For example, you can define a custom validation check on {\itshape any} Zod schema with {\ttfamily .refine} \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myString\ =\ z.string().refine((val)\ =>\ val.length\ <=\ 255,\ \{}
\DoxyCodeLine{\ \ message:\ "{}String\ can't\ be\ more\ than\ 255\ characters"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
‚ö†Ô∏è Refinement functions should not throw. Instead they should return a falsy value to signal failure. \end{quote}
\hypertarget{README.md_autotoc_md36657}{}\doxysubsubsubsubsection{\texorpdfstring{Arguments}{Arguments}}\label{README.md_autotoc_md36657}
As you can see, {\ttfamily .refine} takes two arguments.


\begin{DoxyEnumerate}
\item The first is the validation function. This function takes one input (of type {\ttfamily T} ‚Äî the inferred type of the schema) and returns {\ttfamily any}. Any truthy value will pass validation. (Prior to zod@1.\+6.\+2 the validation function had to return a boolean.)
\item The second argument accepts some options. You can use this to customize certain error-\/handling behavior\+:
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ RefineParams\ =\ \{}
\DoxyCodeLine{\ \ //\ override\ error\ message}
\DoxyCodeLine{\ \ message?:\ string;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ appended\ to\ error\ path}
\DoxyCodeLine{\ \ path?:\ (string\ |\ number)[];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ params\ object\ you\ can\ use\ to\ customize\ message}
\DoxyCodeLine{\ \ //\ in\ error\ map}
\DoxyCodeLine{\ \ params?:\ object;}
\DoxyCodeLine{\};}

\end{DoxyCode}


For advanced cases, the second argument can also be a function that returns {\ttfamily Refine\+Params}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ longString\ =\ z.string().refine(}
\DoxyCodeLine{\ \ (val)\ =>\ val.length\ >\ 10,}
\DoxyCodeLine{\ \ (val)\ =>\ (\{\ message:\ \`{}\$\{val\}\ is\ not\ more\ than\ 10\ characters`\ \})}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36658}{}\doxysubsubsubsubsection{\texorpdfstring{Customize error path}{Customize error path}}\label{README.md_autotoc_md36658}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ passwordForm\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ password:\ z.string(),}
\DoxyCodeLine{\ \ \ \ confirm:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .refine((data)\ =>\ data.password\ ===\ data.confirm,\ \{}
\DoxyCodeLine{\ \ \ \ message:\ "{}Passwords\ don't\ match"{},}
\DoxyCodeLine{\ \ \ \ path:\ ["{}confirm"{}],\ //\ path\ of\ error}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{passwordForm.parse(\{\ password:\ "{}asdf"{},\ confirm:\ "{}qwer"{}\ \});}

\end{DoxyCode}


Because you provided a {\ttfamily path} parameter, the resulting error will be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZodError\ \{}
\DoxyCodeLine{\ \ issues:\ [\{}
\DoxyCodeLine{\ \ \ \ "{}code"{}:\ "{}custom"{},}
\DoxyCodeLine{\ \ \ \ "{}path"{}:\ [\ "{}confirm"{}\ ],}
\DoxyCodeLine{\ \ \ \ "{}message"{}:\ "{}Passwords\ don't\ match"{}}
\DoxyCodeLine{\ \ \}]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36659}{}\doxysubsubsubsubsection{\texorpdfstring{Asynchronous refinements}{Asynchronous refinements}}\label{README.md_autotoc_md36659}
Refinements can also be async\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ userId\ =\ z.string().refine(async\ (id)\ =>\ \{}
\DoxyCodeLine{\ \ //\ verify\ that\ ID\ exists\ in\ database}
\DoxyCodeLine{\ \ return\ true;}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
‚ö†Ô∏è If you use async refinements, you must use the {\ttfamily .parse\+Async} method to parse data! Otherwise Zod will throw an error. \end{quote}
\hypertarget{README.md_autotoc_md36660}{}\doxysubsubsubsubsection{\texorpdfstring{Relationship to transforms}{Relationship to transforms}}\label{README.md_autotoc_md36660}
Transforms and refinements can be interleaved\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.length)}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val\ >\ 25);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36661}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .super\+Refine}}{{\ttfamily .super\+Refine}}}\label{README.md_autotoc_md36661}
The {\ttfamily .refine} method is actually syntactic sugar atop a more versatile (and verbose) method called {\ttfamily super\+Refine}. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Strings\ =\ z.array(z.string()).superRefine((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (val.length\ >\ 3)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.too\_big,}
\DoxyCodeLine{\ \ \ \ \ \ maximum:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ type:\ "{}array"{},}
\DoxyCodeLine{\ \ \ \ \ \ inclusive:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}Too\ many\ items\ üò°"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (val.length\ !==\ new\ Set(val).size)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ \`{}No\ duplicates\ allowed.`,}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can add as many issues as you like. If {\ttfamily ctx.\+add\+Issue} is {\itshape not} called during the execution of the function, validation passes.

Normally refinements always create issues with a {\ttfamily Zod\+Issue\+Code.\+custom} error code, but with {\ttfamily super\+Refine} it\textquotesingle{}s possible to throw issues of any {\ttfamily Zod\+Issue\+Code}. Each issue code is described in detail in the Error Handling guide\+: ERROR\+\_\+\+HANDLING.md.\hypertarget{README.md_autotoc_md36662}{}\doxysubsubsubsubsection{\texorpdfstring{Abort early}{Abort early}}\label{README.md_autotoc_md36662}
By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to {\itshape abort early} to prevent later refinements from being executed. To achieve this, pass the {\ttfamily fatal} flag to {\ttfamily ctx.\+add\+Issue} and return {\ttfamily z.\+NEVER}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.number().superRefine((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (val\ <\ 10)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}should\ be\ >=\ 10"{},}
\DoxyCodeLine{\ \ \ \ \ \ fatal:\ true,}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (val\ !==\ 12)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}should\ be\ twelve"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36663}{}\doxysubsubsubsubsection{\texorpdfstring{Type refinements}{Type refinements}}\label{README.md_autotoc_md36663}
If you provide a \href{https://www.typescriptlang.org/docs/handbook/2/narrowing.html\#using-type-predicates}{\texttt{ type predicate}} to {\ttfamily .refine()} or {\ttfamily .super\+Refine()}, the resulting type will be narrowed down to your predicate\textquotesingle{}s type. This is useful if you are mixing multiple chained refinements and transformations\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ first:\ z.string(),}
\DoxyCodeLine{\ \ \ \ second:\ z.number(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .nullable()}
\DoxyCodeLine{\ \ .superRefine((arg,\ ctx):\ arg\ is\ \{\ first:\ string;\ second:\ number\ \}\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (!arg)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ code:\ z.ZodIssueCode.custom,\ //\ customize\ your\ issue}
\DoxyCodeLine{\ \ \ \ \ \ \ \ message:\ "{}object\ should\ exist"{},}
\DoxyCodeLine{\ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;\ //\ The\ return\ value\ is\ not\ used,\ but\ we\ need\ to\ return\ something\ to\ satisfy\ the\ typing}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ //\ here,\ TS\ knows\ that\ arg\ is\ not\ null}
\DoxyCodeLine{\ \ .refine((arg)\ =>\ arg.first\ ===\ "{}bob"{},\ "{}`first`\ is\ not\ \`{}bob`!"{});}

\end{DoxyCode}


\begin{quote}
‚ö†Ô∏è You {\bfseries{must}} use {\ttfamily ctx.\+add\+Issue()} instead of returning a boolean value to indicate whether the validation passes. If {\ttfamily ctx.\+add\+Issue} is {\itshape not} called during the execution of the function, validation passes. \end{quote}
\hypertarget{README.md_autotoc_md36664}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .transform}}{{\ttfamily .transform}}}\label{README.md_autotoc_md36664}
To transform data after parsing, use the {\ttfamily transform} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringToNumber\ =\ z.string().transform((val)\ =>\ val.length);}
\DoxyCodeLine{}
\DoxyCodeLine{stringToNumber.parse("{}string"{});\ //\ =>\ 6}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36665}{}\doxysubsubsubsubsection{\texorpdfstring{Chaining order}{Chaining order}}\label{README.md_autotoc_md36665}
Note that {\ttfamily string\+To\+Number} above is an instance of the {\ttfamily Zod\+Effects} subclass. It is NOT an instance of {\ttfamily Zod\+String}. If you want to use the built-\/in methods of {\ttfamily Zod\+String} (e.\+g. {\ttfamily .email()}) you must apply those methods {\itshape before} any transforms.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ emailToDomain\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .email()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.split("{}@"{})[1]);}
\DoxyCodeLine{}
\DoxyCodeLine{emailToDomain.parse("{}colinhacks@example.com"{});\ //\ =>\ example.com}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36666}{}\doxysubsubsubsubsection{\texorpdfstring{Validating during transform}{Validating during transform}}\label{README.md_autotoc_md36666}
The {\ttfamily .transform} method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining {\ttfamily transform} and {\ttfamily refine}.

As with {\ttfamily .super\+Refine}, the transform function receives a {\ttfamily ctx} object with an {\ttfamily add\+Issue} method that can be used to register validation issues.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberInString\ =\ z.string().transform((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ const\ parsed\ =\ parseInt(val);}
\DoxyCodeLine{\ \ if\ (isNaN(parsed))\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}Not\ a\ number"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ This\ is\ a\ special\ symbol\ you\ can\ use\ to}
\DoxyCodeLine{\ \ \ \ //\ return\ early\ from\ the\ transform\ function.}
\DoxyCodeLine{\ \ \ \ //\ It\ has\ type\ \`{}never`\ so\ it\ does\ not\ affect\ the}
\DoxyCodeLine{\ \ \ \ //\ inferred\ return\ type.}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ return\ parsed;}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36667}{}\doxysubsubsubsubsection{\texorpdfstring{Relationship to refinements}{Relationship to refinements}}\label{README.md_autotoc_md36667}
Transforms and refinements can be interleaved. These will be executed in the order they are declared.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nameToGreeting\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.toUpperCase())}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val.length\ >\ 15)}
\DoxyCodeLine{\ \ .transform((val)\ =>\ \`{}Hello\ \$\{val\}`)}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val.indexOf("{}!"{})\ ===\ -\/1);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36668}{}\doxysubsubsubsubsection{\texorpdfstring{Async transforms}{Async transforms}}\label{README.md_autotoc_md36668}
Transforms can also be async.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ IdToUser\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .uuid()}
\DoxyCodeLine{\ \ .transform(async\ (id)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ return\ await\ getUserById(id);}
\DoxyCodeLine{\ \ \});}

\end{DoxyCode}


\begin{quote}
‚ö†Ô∏è If your schema contains asynchronous transforms, you must use .parse\+Async() or .safe\+Parse\+Async() to parse data. Otherwise Zod will throw an error. \end{quote}
\hypertarget{README.md_autotoc_md36669}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .default}}{{\ttfamily .default}}}\label{README.md_autotoc_md36669}
You can use transforms to implement the concept of "{}default values"{} in Zod.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringWithDefault\ =\ z.string().default("{}tuna"{});}
\DoxyCodeLine{}
\DoxyCodeLine{stringWithDefault.parse(undefined);\ //\ =>\ "{}tuna"{}}

\end{DoxyCode}


Optionally, you can pass a function into {\ttfamily .default} that will be re-\/executed whenever a default value needs to be generated\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithRandomDefault\ =\ z.number().default(Math.random);}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.4413456736055323}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.1871840107401901}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.7223408162401552}

\end{DoxyCode}


Conceptually, this is how Zod processes default values\+:


\begin{DoxyEnumerate}
\item If the input is {\ttfamily undefined}, the default value is returned
\item Otherwise, the data is parsed using the base schema
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36670}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .describe}}{{\ttfamily .describe}}}\label{README.md_autotoc_md36670}
Use {\ttfamily .describe()} to add a {\ttfamily description} property to the resulting schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ documentedString\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .describe("{}A\ useful\ bit\ of\ text,\ if\ you\ know\ what\ to\ do\ with\ it."{});}
\DoxyCodeLine{documentedString.description;\ //\ A\ useful\ bit\ of\ text‚Ä¶}

\end{DoxyCode}


This can be useful for documenting a field, for example in a JSON Schema using a library like \href{https://github.com/StefanTerdell/zod-to-json-schema}{\texttt{ {\ttfamily zod-\/to-\/json-\/schema}}}).\hypertarget{README.md_autotoc_md36671}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .catch}}{{\ttfamily .catch}}}\label{README.md_autotoc_md36671}
Use {\ttfamily .catch()} to provide a "{}catch value"{} to be returned in the event of a parsing error.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithCatch\ =\ z.number().catch(42);}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithCatch.parse(5);\ //\ =>\ 5}
\DoxyCodeLine{numberWithCatch.parse("{}tuna"{});\ //\ =>\ 42}

\end{DoxyCode}


Optionally, you can pass a function into {\ttfamily .catch} that will be re-\/executed whenever a default value needs to be generated. A {\ttfamily ctx} object containing the caught error will be passed into this function.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithRandomCatch\ =\ z.number().catch((ctx)\ =>\ \{}
\DoxyCodeLine{\ \ ctx.error;\ //\ the\ caught\ ZodError}
\DoxyCodeLine{\ \ return\ Math.random();}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.4413456736055323}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.1871840107401901}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.7223408162401552}

\end{DoxyCode}


Conceptually, this is how Zod processes "{}catch values"{}\+:


\begin{DoxyEnumerate}
\item The data is parsed using the base schema
\item If the parsing fails, the "{}catch value"{} is returned
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36672}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .optional}}{{\ttfamily .optional}}}\label{README.md_autotoc_md36672}
A convenience method that returns an optional version of a schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalString\ =\ z.string().optional();\ //\ string\ |\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.optional(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36673}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nullable}}{{\ttfamily .nullable}}}\label{README.md_autotoc_md36673}
A convenience method that returns a nullable version of a schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullableString\ =\ z.string().nullable();\ //\ string\ |\ null}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.nullable(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36674}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nullish}}{{\ttfamily .nullish}}}\label{README.md_autotoc_md36674}
A convenience method that returns a "{}nullish"{} version of a schema. Nullish schemas will accept both {\ttfamily undefined} and {\ttfamily null}. Read more about the concept of "{}nullish"{} \href{https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html\#nullish-coalescing}{\texttt{ in the Type\+Script 3.\+7 release notes}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullishString\ =\ z.string().nullish();\ //\ string\ |\ null\ |\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.string().nullable().optional();}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36675}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .array}}{{\ttfamily .array}}}\label{README.md_autotoc_md36675}
A convenience method that returns an array schema for the given type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringArray\ =\ z.string().array();\ //\ string[]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.array(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36676}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .promise}}{{\ttfamily .promise}}}\label{README.md_autotoc_md36676}
A convenience method for promise types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringPromise\ =\ z.string().promise();\ //\ Promise<string>}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.promise(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36677}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .or}}{{\ttfamily .or}}}\label{README.md_autotoc_md36677}
A convenience method for union types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.string().or(z.number());\ //\ string\ |\ number}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.union([z.string(),\ z.number()]);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36678}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .and}}{{\ttfamily .and}}}\label{README.md_autotoc_md36678}
A convenience method for creating intersection types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nameAndAge\ =\ z}
\DoxyCodeLine{\ \ .object(\{\ name:\ z.string()\ \})}
\DoxyCodeLine{\ \ .and(z.object(\{\ age:\ z.number()\ \}));\ //\ \{\ name:\ string\ \}\ \&\ \{\ age:\ number\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.intersection(z.object(\{\ name:\ z.string()\ \}),\ z.object(\{\ age:\ z.number()\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36679}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .brand}}{{\ttfamily .brand}}}\label{README.md_autotoc_md36679}
{\ttfamily .brand\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}() =\texorpdfstring{$>$}{>} Zod\+Branded\texorpdfstring{$<$}{<}this, B\texorpdfstring{$>$}{>}}

Type\+Script\textquotesingle{}s type system is structural, which means that any two types that are structurally equivalent are considered the same.


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Cat\ =\ \{\ name:\ string\ \};}
\DoxyCodeLine{type\ Dog\ =\ \{\ name:\ string\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ petCat\ =\ (cat:\ Cat)\ =>\ \{\};}
\DoxyCodeLine{const\ fido:\ Dog\ =\ \{\ name:\ "{}fido"{}\ \};}
\DoxyCodeLine{petCat(fido);\ //\ works\ fine}

\end{DoxyCode}


In some cases, its can be desirable to simulate {\itshape nominal typing} inside Type\+Script. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with {\itshape branded types} (AKA {\itshape opaque types}).


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Cat\ =\ z.object(\{\ name:\ z.string()\ \}).brand<"{}Cat"{}>();}
\DoxyCodeLine{type\ Cat\ =\ z.infer<typeof\ Cat>;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ petCat\ =\ (cat:\ Cat)\ =>\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ works}
\DoxyCodeLine{const\ simba\ =\ Cat.parse(\{\ name:\ "{}simba"{}\ \});}
\DoxyCodeLine{petCat(simba);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ doesn't}
\DoxyCodeLine{petCat(\{\ name:\ "{}fido"{}\ \});}

\end{DoxyCode}


Under the hood, this works by attaching a "{}brand"{} to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Cat\ =\ z.object(\{\ name:\ z.string()\ \}).brand<"{}Cat"{}>();}
\DoxyCodeLine{type\ Cat\ =\ z.infer<typeof\ Cat>;}
\DoxyCodeLine{//\ \{name:\ string\}\ \&\ \{[symbol]:\ "{}Cat"{}\}}

\end{DoxyCode}


Note that branded types do not affect the runtime result of {\ttfamily .parse}. It is a static-\/only construct.\hypertarget{README.md_autotoc_md36680}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .readonly}}{{\ttfamily .readonly}}}\label{README.md_autotoc_md36680}
{\ttfamily .readonly() =\texorpdfstring{$>$}{>} Zod\+Readonly\texorpdfstring{$<$}{<}this\texorpdfstring{$>$}{>}}

This method returns a {\ttfamily Zod\+Readonly} schema instance that parses the input using the base schema, then calls {\ttfamily Object.\+freeze()} on the result. The inferred type is also marked as {\ttfamily readonly}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.object(\{\ name:\ string\ \}).readonly();}
\DoxyCodeLine{type\ schema\ =\ z.infer<typeof\ schema>;}
\DoxyCodeLine{//\ Readonly<\{name:\ string\}>}
\DoxyCodeLine{}
\DoxyCodeLine{const\ result\ =\ schema.parse(\{\ name:\ "{}fido"{}\ \});}
\DoxyCodeLine{result.name\ =\ "{}simba"{};\ //\ error}

\end{DoxyCode}


The inferred type uses Type\+Script\textquotesingle{}s built-\/in readonly types when relevant.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.array(z.string()).readonly();}
\DoxyCodeLine{//\ readonly\ string[]}
\DoxyCodeLine{}
\DoxyCodeLine{z.tuple([z.string(),\ z.number()]).readonly();}
\DoxyCodeLine{//\ readonly\ [string,\ number]}
\DoxyCodeLine{}
\DoxyCodeLine{z.map(z.string(),\ z.date()).readonly();}
\DoxyCodeLine{//\ ReadonlyMap<string,\ Date>}
\DoxyCodeLine{}
\DoxyCodeLine{z.set(z.string()).readonly();}
\DoxyCodeLine{//\ ReadonlySet<Promise<string>>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36681}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .pipe}}{{\ttfamily .pipe}}}\label{README.md_autotoc_md36681}
Schemas can be chained into validation "{}pipelines"{}. It\textquotesingle{}s useful for easily validating the result after a {\ttfamily .transform()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.length)}
\DoxyCodeLine{\ \ .pipe(z.number().min(5));}

\end{DoxyCode}


The {\ttfamily .pipe()} method returns a {\ttfamily Zod\+Pipeline} instance.\hypertarget{README.md_autotoc_md36682}{}\doxysubsubsubsubsection{\texorpdfstring{You can use {\ttfamily .pipe()} to fix common issues with {\ttfamily z.\+coerce}.}{You can use {\ttfamily .pipe()} to fix common issues with {\ttfamily z.\+coerce}.}}\label{README.md_autotoc_md36682}
You can constrain the input to types that work well with your chosen coercion. Then use {\ttfamily .pipe()} to apply the coercion.

without constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toDate\ =\ z.coerce.date();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ works\ intuitively}
\DoxyCodeLine{console.log(toDate.safeParse("{}2023-\/01-\/01"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ might\ not\ be\ what\ you\ want}
\DoxyCodeLine{console.log(toDate.safeParse(null).success);\ //\ true}

\end{DoxyCode}


with constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datelike\ =\ z.union([z.number(),\ z.string(),\ z.date()]);}
\DoxyCodeLine{const\ datelikeToDate\ =\ datelike.pipe(z.coerce.date());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ still\ works\ intuitively}
\DoxyCodeLine{console.log(datelikeToDate.safeParse("{}2023-\/01-\/01"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ more\ likely\ what\ you\ want}
\DoxyCodeLine{console.log(datelikeToDate.safeParse(null).success);\ //\ false}

\end{DoxyCode}


You can also use this technique to avoid coercions that throw uncaught errors.

without constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toBigInt\ =\ z.coerce.bigint();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ works\ intuitively}
\DoxyCodeLine{console.log(toBigInt.safeParse("{}42"{}));\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ probably\ not\ what\ you\ want}
\DoxyCodeLine{console.log(toBigInt.safeParse(null));\ //\ throws\ uncaught\ error}

\end{DoxyCode}


with constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toNumber\ =\ z.number().or(z.string()).pipe(z.coerce.number());}
\DoxyCodeLine{const\ toBigInt\ =\ z.bigint().or(toNumber).pipe(z.coerce.bigint());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ still\ works\ intuitively}
\DoxyCodeLine{console.log(toBigInt.safeParse("{}42"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ error\ handled\ by\ zod,\ more\ likely\ what\ you\ want}
\DoxyCodeLine{console.log(toBigInt.safeParse(null).success);\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36683}{}\doxysubsubsection{\texorpdfstring{Guides and concepts}{Guides and concepts}}\label{README.md_autotoc_md36683}
\hypertarget{README.md_autotoc_md36684}{}\doxysubsubsubsection{\texorpdfstring{Type inference}{Type inference}}\label{README.md_autotoc_md36684}
You can extract the Type\+Script type of any schema with {\ttfamily z.\+infer\texorpdfstring{$<$}{<}typeof my\+Schema\texorpdfstring{$>$}{>}} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ A\ =\ z.string();}
\DoxyCodeLine{type\ A\ =\ z.infer<typeof\ A>;\ //\ string}
\DoxyCodeLine{}
\DoxyCodeLine{const\ u:\ A\ =\ 12;\ //\ TypeError}
\DoxyCodeLine{const\ u:\ A\ =\ "{}asdf"{};\ //\ compiles}

\end{DoxyCode}


{\bfseries{What about transforms?}}

In reality each Zod schema internally tracks {\bfseries{two}} types\+: an input and an output. For most schemas (e.\+g. {\ttfamily z.\+string()}) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance {\ttfamily z.\+string().transform(val =\texorpdfstring{$>$}{>} val.\+length)} has an input of {\ttfamily string} and an output of {\ttfamily number}.

You can separately extract the input and output types like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringToNumber\ =\ z.string().transform((val)\ =>\ val.length);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ‚ö†Ô∏è\ Important:\ z.infer\ returns\ the\ OUTPUT\ type!}
\DoxyCodeLine{type\ input\ =\ z.input<typeof\ stringToNumber>;\ //\ string}
\DoxyCodeLine{type\ output\ =\ z.output<typeof\ stringToNumber>;\ //\ number}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to\ z.output!}
\DoxyCodeLine{type\ inferred\ =\ z.infer<typeof\ stringToNumber>;\ //\ number}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36685}{}\doxysubsubsubsection{\texorpdfstring{Writing generic functions}{Writing generic functions}}\label{README.md_autotoc_md36685}
When attempting to write a function that accepts a Zod schema as an input, it\textquotesingle{}s common to try something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ makeSchemaOptional<T>(schema:\ z.ZodType<T>)\ \{}
\DoxyCodeLine{\ \ return\ schema.optional();}
\DoxyCodeLine{\}}

\end{DoxyCode}


This approach has some issues. The {\ttfamily schema} variable in this function is typed as an instance of {\ttfamily Zod\+Type}, which is an abstract class that all Zod schemas inherit from. This approach loses type information, namely {\itshape which subclass} the input actually is.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ arg\ =\ makeSchemaOptional(z.string());}
\DoxyCodeLine{arg.unwrap();}

\end{DoxyCode}


A better approach is for the generic parameter to refer to {\itshape the schema as a whole}.


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ makeSchemaOptional<T\ extends\ z.ZodTypeAny>(schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema.optional();}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
{\ttfamily Zod\+Type\+Any} is just a shorthand for {\ttfamily Zod\+Type\texorpdfstring{$<$}{<}any, any, any\texorpdfstring{$>$}{>}}, a type that is broad enough to match any Zod schema. \end{quote}


As you can see, {\ttfamily schema} is now fully and properly typed.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ arg\ =\ makeSchemaOptional(z.string());}
\DoxyCodeLine{arg.unwrap();\ //\ ZodString}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36686}{}\doxysubsubsubsubsection{\texorpdfstring{Constraining allowable inputs}{Constraining allowable inputs}}\label{README.md_autotoc_md36686}
The {\ttfamily Zod\+Type} class has three generic parameters.


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ ZodType<}
\DoxyCodeLine{\ \ Output\ =\ any,}
\DoxyCodeLine{\ \ Def\ extends\ ZodTypeDef\ =\ ZodTypeDef,}
\DoxyCodeLine{\ \ Input\ =\ Output}
\DoxyCodeLine{>\ \{\ ...\ \}}

\end{DoxyCode}


By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ makeSchemaOptional<T\ extends\ z.ZodType<string>>(schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema.optional();}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{makeSchemaOptional(z.string());}
\DoxyCodeLine{//\ works\ fine}
\DoxyCodeLine{}
\DoxyCodeLine{makeSchemaOptional(z.number());}
\DoxyCodeLine{//\ Error:\ 'ZodNumber'\ is\ not\ assignable\ to\ parameter\ of\ type\ 'ZodType<string,\ ZodTypeDef,\ string>'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36687}{}\doxysubsubsubsection{\texorpdfstring{Error handling}{Error handling}}\label{README.md_autotoc_md36687}
Zod provides a subclass of Error called {\ttfamily Zod\+Error}. Zod\+Errors contain an {\ttfamily issues} array containing detailed information about the validation problems.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .safeParse(\{\ name:\ 12\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ result.error.issues;}
\DoxyCodeLine{\ \ /*\ [}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}code"{}:\ "{}invalid\_type"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}expected"{}:\ "{}string"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}received"{}:\ "{}number"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}path"{}:\ [\ "{}name"{}\ ],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}message"{}:\ "{}Expected\ string,\ received\ number"{}}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ ]\ */}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide\+: ERROR\+\_\+\+HANDLING.md \end{quote}


Zod\textquotesingle{}s error reporting emphasizes {\itshape completeness} and {\itshape correctness}. If you are looking to present a useful error message to the end user, you should either override Zod\textquotesingle{}s error messages using an error map (described in detail in the Error Handling guide) or use a third-\/party library like \href{https://github.com/causaly/zod-validation-error}{\texttt{ {\ttfamily zod-\/validation-\/error}}}\hypertarget{README.md_autotoc_md36688}{}\doxysubsubsubsection{\texorpdfstring{Error formatting}{Error formatting}}\label{README.md_autotoc_md36688}
You can use the {\ttfamily .\doxylink{utilities_8cc_abe24116ee0a218908696f43fe118e24b}{format()}} method to convert this error into a nested object.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .safeParse(\{\ name:\ 12\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ const\ formatted\ =\ result.error.format();}
\DoxyCodeLine{\ \ /*\ \{}
\DoxyCodeLine{\ \ \ \ name:\ \{\ \_errors:\ [\ 'Expected\ string,\ received\ number'\ ]\ \}}
\DoxyCodeLine{\ \ \}\ */}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ formatted.name?.\_errors;}
\DoxyCodeLine{\ \ //\ =>\ ["{}Expected\ string,\ received\ number"{}]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36689}{}\doxysubsubsection{\texorpdfstring{Comparison}{Comparison}}\label{README.md_autotoc_md36689}
There are a handful of other widely-\/used validation libraries, but all of them have certain design limitations that make for a non-\/ideal developer experience.\hypertarget{README.md_autotoc_md36690}{}\doxysubsubsubsection{\texorpdfstring{Joi}{Joi}}\label{README.md_autotoc_md36690}
\href{https://github.com/hapijs/joi}{\texttt{ https\+://github.\+com/hapijs/joi}}

Doesn\textquotesingle{}t support static type inference üòï\hypertarget{README.md_autotoc_md36691}{}\doxysubsubsubsection{\texorpdfstring{Yup}{Yup}}\label{README.md_autotoc_md36691}
\href{https://github.com/jquense/yup}{\texttt{ https\+://github.\+com/jquense/yup}}

Yup is a full-\/featured library that was implemented first in vanilla JS, and later rewritten in Type\+Script.


\begin{DoxyItemize}
\item Supports casting and transforms
\item All object fields are optional by default
\item Missing promise schemas
\item Missing function schemas
\item Missing union \& intersection schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36692}{}\doxysubsubsubsection{\texorpdfstring{io-\/ts}{io-\/ts}}\label{README.md_autotoc_md36692}
\href{https://github.com/gcanti/io-ts}{\texttt{ https\+://github.\+com/gcanti/io-\/ts}}

io-\/ts is an excellent library by gcanti. The API of io-\/ts heavily inspired the design of Zod.

In our experience, io-\/ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-\/ts particularly hard to integrate into an existing codebase with a more procedural or object-\/oriented bias. For instance, consider how to define an object with optional properties in io-\/ts\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ t\ from\ "{}io-\/ts"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ A\ =\ t.type(\{}
\DoxyCodeLine{\ \ foo:\ t.string,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ B\ =\ t.partial(\{}
\DoxyCodeLine{\ \ bar:\ t.number,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ C\ =\ t.intersection([A,\ B]);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ C\ =\ t.TypeOf<typeof\ C>;}
\DoxyCodeLine{//\ returns\ \{\ foo:\ string;\ bar?:\ number\ |\ undefined\ \}}

\end{DoxyCode}


You must define the required and optional props in separate object validators, pass the optionals through {\ttfamily t.\+partial} (which marks all properties as optional), then combine them with {\ttfamily t.\+intersection} .

Consider the equivalent in Zod\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ C\ =\ z.object(\{}
\DoxyCodeLine{\ \ foo:\ z.string(),}
\DoxyCodeLine{\ \ bar:\ z.number().optional(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ C\ =\ z.infer<typeof\ C>;}
\DoxyCodeLine{//\ returns\ \{\ foo:\ string;\ bar?:\ number\ |\ undefined\ \}}

\end{DoxyCode}


This more declarative API makes schema definitions vastly more concise.

{\ttfamily io-\/ts} also requires the use of gcanti\textquotesingle{}s functional programming library {\ttfamily fp-\/ts} to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on {\ttfamily fp-\/ts} necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the {\ttfamily fp-\/ts} nomenclature to use the library.


\begin{DoxyItemize}
\item Supports codecs with serialization \& deserialization transforms
\item Supports branded types
\item Supports advanced functional programming, higher-\/kinded types, {\ttfamily fp-\/ts} compatibility
\item Missing object methods\+: (pick, omit, partial, deep\+Partial, merge, extend)
\item Missing nonempty arrays with proper typing ({\ttfamily \mbox{[}T, ...T\mbox{[}\mbox{]}\mbox{]}})
\item Missing promise schemas
\item Missing function schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36693}{}\doxysubsubsubsection{\texorpdfstring{Runtypes}{Runtypes}}\label{README.md_autotoc_md36693}
\href{https://github.com/pelotom/runtypes}{\texttt{ https\+://github.\+com/pelotom/runtypes}}

Good type inference support.


\begin{DoxyItemize}
\item Supports "{}pattern matching"{}\+: computed properties that distribute over unions
\item Missing object methods\+: (deep\+Partial, merge)
\item Missing nonempty arrays with proper typing ({\ttfamily \mbox{[}T, ...T\mbox{[}\mbox{]}\mbox{]}})
\item Missing promise schemas
\item Missing error customization
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36694}{}\doxysubsubsubsection{\texorpdfstring{Ow}{Ow}}\label{README.md_autotoc_md36694}
\href{https://github.com/sindresorhus/ow}{\texttt{ https\+://github.\+com/sindresorhus/ow}}

Ow is focused on function input validation. It\textquotesingle{}s a library that makes it easy to express complicated assert statements, but it doesn\textquotesingle{}t let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-\/to-\/one mapping with Type\+Script\textquotesingle{}s type system, whereas ow lets you validate several highly-\/specific types out of the box (e.\+g. {\ttfamily int32\+Array} , see full list in their README).

If you want to validate function inputs, use function schemas in Zod! It\textquotesingle{}s a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-\/pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won\textquotesingle{}t be any unexpected data passed downstream.\hypertarget{README.md_autotoc_md36695}{}\doxysubsubsection{\texorpdfstring{Changelog}{Changelog}}\label{README.md_autotoc_md36695}
View the changelog at \doxylink{tests_2security_2node__modules_2_8pnpm_2axios_0d1_88_83_2node__modules_2axios_2_c_h_a_n_g_e_l_o_g_8md}{CHANGELOG.md} 