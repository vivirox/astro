\doxysection{node\+\_\+modules/swr-\/store Directory Reference}
\hypertarget{dir_d5c5f2594be2834666bd368c1b284e7f}{}\label{dir_d5c5f2594be2834666bd368c1b284e7f}\index{node\_modules/swr-\/store Directory Reference@{node\_modules/swr-\/store Directory Reference}}


\doxysubsection{Detailed Description}
\begin{quote}
Reactive SWR stores for data-\/fetching. \end{quote}


\href{https://www.npmjs.com/package/swr-store}{\texttt{ }} \href{https://github.com/airbnb/javascript}{\texttt{ }}\hypertarget{README.md_autotoc_md31756}{}\doxysubsection{\texorpdfstring{Install}{Install}}\label{README.md_autotoc_md31756}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ -\/-\/save\ swr-\/store}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{yarn\ add\ swr-\/store}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31757}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md31757}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createSWRStore,\ trigger\ \}\ from\ 'swr-\/store';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ dogAPI\ =\ createSWRStore<APIResult,\ [string]>(\{}
\DoxyCodeLine{\ \ //\ Fetch\ data\ based\ on\ breed}
\DoxyCodeLine{\ \ get:\ async\ (breed:\ string)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ const\ response\ =\ await\ fetch(`\$\{API\}\$\{breed\}\$\{API\_SUFFIX\}`);}
\DoxyCodeLine{\ \ \ \ return\ (await\ response.json())\ as\ APIResult;}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ //\ Allow\ us\ to\ revalidate\ the\ data}
\DoxyCodeLine{\ \ //\ whenever\ the\ page\ gets\ focused}
\DoxyCodeLine{\ \ revalidateOnFocus:\ true,}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Revalidate\ the\ data\ when\ the\ network\ goes}
\DoxyCodeLine{\ \ //\ back\ online}
\DoxyCodeLine{\ \ revalidateOnNetwork:\ true,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Will\ be\ pending\ initially.}
\DoxyCodeLine{//\ The\ result\ will\ change\ once\ dogAPI.get\ is\ called\ again}
\DoxyCodeLine{//\ sometime\ after\ the\ fetch\ has\ assumed\ to\ be\ resolved.}
\DoxyCodeLine{const\ result\ =\ dogAPI.get(['shiba']);}
\DoxyCodeLine{}
\DoxyCodeLine{if\ (result.status\ ===\ 'pending')\ \{}
\DoxyCodeLine{\ \ displaySkeleton();}
\DoxyCodeLine{\}\ else\ if\ (result.status\ ===\ 'failure')\ \{}
\DoxyCodeLine{\ \ displayFallback();}
\DoxyCodeLine{\}\ else\ if\ (result.status\ ===\ 'success')\ \{}
\DoxyCodeLine{\ \ displayUI(result.data);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ When\ click\ is\ triggered,\ we\ prompt\ a\ revalidation\ process}
\DoxyCodeLine{document.getElementById('\#refresh').addEventListener('click',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ //\ We\ can\ do\ local\ revalidation}
\DoxyCodeLine{\ \ dogAPI.trigger(['shiba']);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Or\ a\ global\ revalidation}
\DoxyCodeLine{\ \ trigger('shiba');}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31758}{}\doxysubsection{\texorpdfstring{Features}{Features}}\label{README.md_autotoc_md31758}
\hypertarget{README.md_autotoc_md31759}{}\doxysubsubsection{\texorpdfstring{Key Generation}{Key Generation}}\label{README.md_autotoc_md31759}
SWR stores may derive keys based on received arguments. These keys are used to locate cache references. By default, arguments are serialized through {\ttfamily JSON.\+stringify}, but can be overriden by providing {\ttfamily options.\+key}, where the {\ttfamily key} function receives the arguments and may return a string.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ store\ =\ createSWRStore(\{}
\DoxyCodeLine{\ \ //\ Only\ select\ the\ key}
\DoxyCodeLine{\ \ //\ note\ that\ keys\ are\ globally\ shared.}
\DoxyCodeLine{\ \ key:\ (id)\ =>\ id,}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ //\ An\ auth-\/based\ endpoint}
\DoxyCodeLine{\ \ get:\ (id,\ token)\ =>\ getUserPrivateData(\{}
\DoxyCodeLine{\ \ \ \ userId:\ id,}
\DoxyCodeLine{\ \ \ \ token,}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ...}
\DoxyCodeLine{const\ privateData\ =\ store.get(userId,\ userToken);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31760}{}\doxysubsubsection{\texorpdfstring{Subscriptions}{Subscriptions}}\label{README.md_autotoc_md31760}
SWR store allows subscriptions to subscribe for cache updates. Subscribing returns a callback that allows unsubscribing to the cache updates.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Local\ subscription}
\DoxyCodeLine{const\ unsubscribe\ =\ userDetails.subscribe([userId],\ (result)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (result.status\ ===\ 'pending')\ \{}
\DoxyCodeLine{\ \ \ \ displaySkeleton();}
\DoxyCodeLine{\ \ \}\ else\ if\ (result.status\ ===\ 'failure')\ \{}
\DoxyCodeLine{\ \ \ \ displayFallback();}
\DoxyCodeLine{\ \ \}\ else\ if\ (result.status\ ===\ 'success')\ \{}
\DoxyCodeLine{\ \ \ \ displayUI(result.data);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ global\ subscription}
\DoxyCodeLine{import\ \{\ subscribe\ \}\ from\ 'swr-\/store';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ unsubscribe\ =\ subscribe(`/user/\$\{userId\}`,\ (result)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (result.status\ ===\ 'pending')\ \{}
\DoxyCodeLine{\ \ \ \ displaySkeleton();}
\DoxyCodeLine{\ \ \}\ else\ if\ (result.status\ ===\ 'failure')\ \{}
\DoxyCodeLine{\ \ \ \ displayFallback();}
\DoxyCodeLine{\ \ \}\ else\ if\ (result.status\ ===\ 'success')\ \{}
\DoxyCodeLine{\ \ \ \ displayUI(result.data);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31761}{}\doxysubsubsection{\texorpdfstring{Hydration}{Hydration}}\label{README.md_autotoc_md31761}
SWR store may present an initial data through {\ttfamily options.\+initial\+Data}. This data is used only when the store finds an empty cache value. Initial data is also useful for opting-\/out of initial pending phase and providing a way for SSR pages to hydrate stores.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ userDetails\ =\ createSWRStore(\{}
\DoxyCodeLine{\ \ get:\ (id)\ =>\ getUserDetails(id),}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ initialData:\ prefetchedData,}
\DoxyCodeLine{\});}

\end{DoxyCode}


Stores can also be hydrated manually through {\ttfamily mutate}.

Calling {\ttfamily store.\+get} also allows lazy hydration, in which the provided initial data is preferred rather than {\ttfamily options.\+initial\+Data}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ userDetails.get([userId],\ \{}
\DoxyCodeLine{\ \ //\ If\ there's\ no\ cache,\ prefetched\ data\ is\ used}
\DoxyCodeLine{\ \ //\ then\ attempts\ revalidation}
\DoxyCodeLine{\ \ initialData:\ prefetchedData,}
\DoxyCodeLine{\});}

\end{DoxyCode}


Do note that {\ttfamily options.\+initial\+Data} won\textquotesingle{}t hydrate the actual store but present a fallback data when the result is still pending. You can use {\ttfamily options.\+hydrate} to overwrite the current cached data.\hypertarget{README.md_autotoc_md31762}{}\doxysubsubsection{\texorpdfstring{Lazy Revalidation}{Lazy Revalidation}}\label{README.md_autotoc_md31762}
SWR stores are lazily revalidated whenever {\ttfamily store.\+get} is called.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Initial\ fetch}
\DoxyCodeLine{const\ result\ =\ store.get([]);}
\DoxyCodeLine{}
\DoxyCodeLine{setTimeout(()\ =>\ \{}
\DoxyCodeLine{\ \ //\ May\ contain\ the\ resolved\ result}
\DoxyCodeLine{\ \ //\ or\ a\ new\ one\ if\ the\ cache\ has\ been\ invalidated.}
\DoxyCodeLine{\ \ const\ newResult\ =\ store.get([]);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Revalidation on {\ttfamily get} may be opt-\/out by providing {\ttfamily should\+Revalidate}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ store.get([],\ \{}
\DoxyCodeLine{\ \ shouldRevalidate:\ false,}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31763}{}\doxysubsubsection{\texorpdfstring{Global Revalidation}{Global Revalidation}}\label{README.md_autotoc_md31763}
SWR stores share the same global cache, and can be prompted with a global manual revalidation. {\ttfamily trigger} and {\ttfamily mutate} are similar to store\textquotesingle{}s {\ttfamily store.\+trigger} and {\ttfamily store.\+mutate} except that they accept the cache key instead of the store\textquotesingle{}s expected arguments.

Stores subscribers are may be notified ({\ttfamily trigger} does not guarantee a notification, while {\ttfamily mutate} guarantees a notification) for the cache update.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ trigger,\ mutate\ \}\ from\ 'swr-\/store';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ userDetails\ =\ createSWRStore(\{}
\DoxyCodeLine{\ \ //\ Transform\ id\ into\ a\ cache\ key}
\DoxyCodeLine{\ \ key:\ (id)\ =>\ \`{}/user/\$\{id\}`,}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ //\ An\ auth-\/based\ endpoint}
\DoxyCodeLine{\ \ get:\ (id)\ =>\ getUserDetails(id),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ...}
\DoxyCodeLine{//\ Global\ trigger}
\DoxyCodeLine{trigger(`/user/\$\{userId\}`);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Or\ mutate}
\DoxyCodeLine{mutate(`/user/\$\{userId\}`,\ \{}
\DoxyCodeLine{\ \ data:\ \{}
\DoxyCodeLine{\ \ \ \ name:\ 'John\ Doe',}
\DoxyCodeLine{\ \ \ \ age:\ 16,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ status:\ 'success',}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31764}{}\doxysubsubsection{\texorpdfstring{Local Revalidation}{Local Revalidation}}\label{README.md_autotoc_md31764}
SWR stores can be manually revalidated by calling {\ttfamily store.\+trigger} or {\ttfamily store.\+mutate}.


\begin{DoxyItemize}
\item {\ttfamily store.\+trigger(args, should\+Revalidate = true)}\+: Triggers a revalidation from the given arguments. Arguments are passed to {\ttfamily options.\+key} to locate the cache.
\item {\ttfamily store.\+mutate(args, result, should\+Revalidate = true)}\+: Mutates the cache with {\ttfamily result}. Cache is located based on the key generated from the arguments passed to {\ttfamily options.\+key}.
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Local\ revalidation}
\DoxyCodeLine{userDetails.trigger([userId]);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ is\ the\ same\ as\ }
\DoxyCodeLine{trigger(`/user/\$\{userId\}`);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Since\ userDetails\ yields\ the\ same\ key\ format.}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31765}{}\doxysubsubsection{\texorpdfstring{Auto Revalidation}{Auto Revalidation}}\label{README.md_autotoc_md31765}
SWR stores are able to automatically revalidate data based on DOM events. This feature can be activated based on the following options\+:


\begin{DoxyItemize}
\item {\ttfamily options.\+revalidate\+On\+Focus}\+: Automatically revalidates data when the window `\textquotesingle{}focus'{\ttfamily event is triggered. Defaults to}false{\ttfamily . -\/}options.\+revalidate\+On\+Visibility{\ttfamily \+: Automatically revalidates data when the document}\textquotesingle{}visibilitychange\textquotesingle{}{\ttfamily event is triggered, specifically, if the page is}\textquotesingle{}visible\textquotesingle{}{\ttfamily . Defaults to}false{\ttfamily . -\/}options.\+revalidate\+On\+Network{\ttfamily \+: Automatically revalidates data when the window}\textquotesingle{}online\textquotesingle{}{\ttfamily event is triggered. Defaults to}false\`{}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md31766}{}\doxysubsubsection{\texorpdfstring{Polling Revalidation}{Polling Revalidation}}\label{README.md_autotoc_md31766}
SWR stores are able to poll for revalidation. They are different to event-\/based revalidation as polling revalidation happens in intervals.

This behavior can be activated through the following options\+:


\begin{DoxyItemize}
\item {\ttfamily options.\+refresh\+Interval}\+: Amount of time (in milliseconds) the revalidation goes through in intervals. Defaults to {\ttfamily undefined} (Does not poll). Polling begins immediately after the lazy setup has been triggered.
\end{DoxyItemize}

The default behavior can be overriden by the following options\+:


\begin{DoxyItemize}
\item {\ttfamily options.\+refresh\+When\+Hidden}\+: Overrides the default polling behavior and only begins polling after the page becomes hidden (triggered by document {\ttfamily visibilitychange} event.). Once the document becomes visible, polling halts.
\item {\ttfamily options.\+refresh\+When\+Blurred}\+: Overrides the default polling behavior and only begins polling after the page loses focus (triggered by window {\ttfamily blur} and {\ttfamily focus} events). Once the page is focused again, polling halts.
\item {\ttfamily options.\+refresh\+When\+Offline}\+: Overrides the default polling behavior and only begins polling after the page becomes offline (triggered by window {\ttfamily offline} and {\ttfamily online} events). Once the page is focused again, polling halts.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md31767}{}\doxysubsubsection{\texorpdfstring{Lazy Setup}{Lazy Setup}}\label{README.md_autotoc_md31767}
SWR stores are lazily setup\+: polling and automatic revalidation only begins when there are subscribers to the stores. Once a store receives a subscriber (through {\ttfamily store.\+subscribe} method), the store lazily sets up the revalidation processes, this way, automatic processes are conserved and are only added when needed.

Stores also halt from automatic revalidation if they lose all subscribers through reference-\/counting.\hypertarget{README.md_autotoc_md31768}{}\doxysubsubsection{\texorpdfstring{Cache Age}{Cache Age}}\label{README.md_autotoc_md31768}
SWR stores can define how \textquotesingle{}fresh\textquotesingle{} or \textquotesingle{}stale\textquotesingle{} the cache is, which can alter the revalidation behavior\+:


\begin{DoxyItemize}
\item If the cache is \textquotesingle{}fresh\textquotesingle{}, revalidation phases skips the fetching stage.
\item If the cache is \textquotesingle{}stale\textquotesingle{}, revalidation phases goes through, but the result does not return to `\textquotesingle{}pending'\`{} state.
\end{DoxyItemize}

These behavior can be defined through the following options\+:


\begin{DoxyItemize}
\item {\ttfamily options.\+fresh\+Age}\+: Defines how long the cache stays \textquotesingle{}fresh\textquotesingle{}, in milliseconds. Defaults to {\ttfamily 2000}. (2 seconds).
\item {\ttfamily options.\+stale\+Age}\+: Defines how long the cache stays \textquotesingle{}stale\textquotesingle{} after becoming \textquotesingle{}fresh\textquotesingle{}, in milliseconds. Defaults to {\ttfamily 30000} (30 seconds).
\end{DoxyItemize}

A cache is \textquotesingle{}fresh\textquotesingle{} when the time between the cache was updated and was read is between the {\ttfamily options.\+fresh\+Age} value, otherwise, the cache automatically becomes \textquotesingle{}stale\textquotesingle{}. A cache that has been \textquotesingle{}stale\textquotesingle{} will continue being \textquotesingle{}stale\textquotesingle{} until the time between the cache became \textquotesingle{}stale\textquotesingle{} and was read is between the {\ttfamily options.\+stale\+Age}.

Cache invalidation always happen lazily\+: checking for cache age only happens when the revalidation process is requested upon (usually automatically through polling or revalidation on events) or manually ({\ttfamily mutate} or {\ttfamily trigger}).\hypertarget{README.md_autotoc_md31769}{}\doxysubsubsection{\texorpdfstring{Deduplication}{Deduplication}}\label{README.md_autotoc_md31769}
SWR Stores throttles data fetching processes through the caching strategy. Cache maintain a timestamp internally, marking valid requests and cache references, establishing race conditions.\hypertarget{README.md_autotoc_md31770}{}\doxysubsubsection{\texorpdfstring{CSR-\/\+Only Revalidation and Fetching}{CSR-\/\+Only Revalidation and Fetching}}\label{README.md_autotoc_md31770}
SWR stores\textquotesingle{} cache revalidation and data-\/fetching only happens on client-\/side.\hypertarget{README.md_autotoc_md31771}{}\doxysubsubsection{\texorpdfstring{Success Bailouts}{Success Bailouts}}\label{README.md_autotoc_md31771}
SWR stores, by default, deeply compare success data in between cache updates. This behavior prevents re-\/notifying subscribers when the contents of the data remains the same. This behavior can be overriden by providing a compare function in {\ttfamily options.\+compare}.

{\ttfamily mutate} accepts an custom compare function to override this behavior as a fourth parameter.\hypertarget{README.md_autotoc_md31772}{}\doxysubsubsection{\texorpdfstring{Retries}{Retries}}\label{README.md_autotoc_md31772}
SWR stores implements the exponential backoff algorithm for retry intervals whenever a request fails. By default, SWR stores retry indefinitely until the request resolves successfully at a maximum interval of {\ttfamily 5000ms}. Limit can be defined through {\ttfamily options.\+max\+Retry\+Count} and the interval can be overriden with {\ttfamily options.\+max\+Retry\+Interval}.\hypertarget{README.md_autotoc_md31773}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md31773}
MIT © \href{https://github.com/lxsmnsyc}{\texttt{ lxsmnsyc}} 