\doxysection{node\+\_\+modules/zod-\/to-\/json-\/schema Directory Reference}
\hypertarget{dir_a3ee01472ce8b3f89e14777cf1798715}{}\label{dir_a3ee01472ce8b3f89e14777cf1798715}\index{node\_modules/zod-\/to-\/json-\/schema Directory Reference@{node\_modules/zod-\/to-\/json-\/schema Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_e2a3dbeb33fb0d92c897cb4ff591a53e}{node\+\_\+modules}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\href{https://npmjs.org/package/zod-to-json-schema}{\texttt{ }} \href{https://npmjs.org/package/zod-to-json-schema}{\texttt{ }}

{\itshape Looking for the exact opposite? Check out \href{https://npmjs.org/package/json-schema-to-zod}{\texttt{ json-\/schema-\/to-\/zod}}}\hypertarget{README.md_autotoc_md36436}{}\doxysubsection{\texorpdfstring{Summary}{Summary}}\label{README.md_autotoc_md36436}
Does what it says on the tin; converts \href{https://github.com/colinhacks/zod}{\texttt{ Zod schemas}} into \href{https://json-schema.org/}{\texttt{ JSON schemas}}!


\begin{DoxyItemize}
\item Supports all relevant schema types, basic string, number and array length validations and string patterns.
\item Resolves recursive and recurring schemas with internal {\ttfamily \$ref}s.
\item Supports targeting legacy Open API 3.\+0 specification (3.\+1 supports regular Json Schema).
\item Supports Open AI strict mode schemas (Optional object properties are replaced with required but nullable ones).
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36437}{}\doxysubsection{\texorpdfstring{Sponsors}{Sponsors}}\label{README.md_autotoc_md36437}
A great big thank you to our amazing sponsors! Please consider joining them through my \href{https://github.com/sponsors/StefanTerdell}{\texttt{ Git\+Hub Sponsors page}}. Every cent helps, but these fellas have really gone above and beyond ðŸ’š\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\PBS\centering 





\href{https://retool.com/?ref=stefanterdell&utm_source=github&utm_medium=referral&utm_campaign=stefanterdell}{\texttt{   }} ~\newline
 ~\newline
 Build AI apps and workflows with \href{https://retool.com/products/ai?ref=stefanterdell&utm_source=github&utm_medium=referral&utm_campaign=stefanterdell}{\texttt{ Retool AI}} ~\newline
 \href{https://retool.com/?ref=stefanterdell&utm_source=github&utm_medium=referral&utm_campaign=stefanterdell}{\texttt{ retool.\+com}} 





\\\cline{1-1}
\PBS\centering 





 \href{https://www.coderabbit.ai/}{\texttt{   }}  ~\newline
 ~\newline
 Cut code review time \& bugs in half ~\newline
 \href{https://www.coderabbit.ai/}{\texttt{ coderabbit.\+ai}} 





\\\cline{1-1}
\end{longtabu}
\hypertarget{README.md_autotoc_md36438}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md36438}
\hypertarget{README.md_autotoc_md36439}{}\doxysubsubsection{\texorpdfstring{Basic example}{Basic example}}\label{README.md_autotoc_md36439}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{import\ \{\ zodToJsonSchema\ \}\ from\ "{}zod-\/to-\/json-\/schema"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ mySchema\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ myString:\ z.string().min(5),}
\DoxyCodeLine{\ \ \ \ myUnion:\ z.union([z.number(),\ z.boolean()]),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .describe("{}My\ neat\ object\ schema"{});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ jsonSchema\ =\ zodToJsonSchema(mySchema,\ "{}mySchema"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36440}{}\doxysubsubsubsection{\texorpdfstring{Expected output}{Expected output}}\label{README.md_autotoc_md36440}

\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}\$schema"{}:\ "{}http://json-\/schema.org/draft-\/07/schema\#"{},}
\DoxyCodeLine{\ \ "{}\$ref"{}:\ "{}\#/definitions/mySchema"{},}
\DoxyCodeLine{\ \ "{}definitions"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}mySchema"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}description"{}:\ "{}My\ neat\ object\ schema"{},}
\DoxyCodeLine{\ \ \ \ \ \ "{}type"{}:\ "{}object"{},}
\DoxyCodeLine{\ \ \ \ \ \ "{}properties"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}myString"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}type"{}:\ "{}string"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}minLength"{}:\ 5}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}myUnion"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ "{}type"{}:\ ["{}number"{},\ "{}boolean"{}]}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ "{}additionalProperties"{}:\ false,}
\DoxyCodeLine{\ \ \ \ \ \ "{}required"{}:\ ["{}myString"{},\ "{}myUnion"{}]}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36441}{}\doxysubsection{\texorpdfstring{Options}{Options}}\label{README.md_autotoc_md36441}
\hypertarget{README.md_autotoc_md36442}{}\doxysubsubsection{\texorpdfstring{Schema name}{Schema name}}\label{README.md_autotoc_md36442}
You can pass a string as the second parameter of the main zod\+To\+Json\+Schema function. If you do, your schema will end up inside a definitions object property on the root and referenced from there. Alternatively, you can pass the name as the {\ttfamily name} property of the options object (see below).\hypertarget{README.md_autotoc_md36443}{}\doxysubsubsection{\texorpdfstring{Options object}{Options object}}\label{README.md_autotoc_md36443}
Instead of the schema name (or nothing), you can pass an options object as the second parameter. The following options are available\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Effect    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Effect    }\\\cline{1-2}
\endhead
{\bfseries{name}}?\+: {\itshape string}   &As described above.    \\\cline{1-2}
{\bfseries{name\+Strategy}}?\+: "{}ref"{} $|$ "{}title"{}   &Adds name as "{}title"{} meta instead of as a ref as described above    \\\cline{1-2}
{\bfseries{base\+Path}}?\+: string\mbox{[}\mbox{]}   &The base path of the root reference builder. Defaults to \mbox{[}"{}\#"{}\mbox{]}.    \\\cline{1-2}
{\bfseries{\$ref\+Strategy}}?\+: "{}root"{} $|$ "{}relative"{} $|$ "{}seen"{} $|$ "{}none"{}   &The reference builder strategy; 
\begin{DoxyItemize}
\item {\bfseries{"{}root"{}}} resolves \$refs from the root up, ie\+: "{}\#/definitions/my\+Schema"{}.
\item {\bfseries{"{}relative"{}}} uses \href{https://tools.ietf.org/id/draft-handrews-relative-json-pointer-00.html}{\texttt{ relative JSON pointers}}. {\itshape See known issues!}
\item {\bfseries{"{}seen"{}}} reuses the output of any "{}seen"{} Zod schema. In theory it\textquotesingle{}s a more performant version of "{}none"{}, but in practice this behaviour can cause issues with nested schemas and has now gotten its own option. 
\item {\bfseries{"{}none"{}}} ignores referencing all together, creating a new schema branch even on "{}seen"{} schemas. Recursive references defaults to "{}any"{}, ie {\ttfamily \{\}}.
\end{DoxyItemize}Defaults to "{}root"{}.    \\\cline{1-2}
{\bfseries{effect\+Strategy}}?\+: "{}input"{} $|$ "{}any"{}   &The effects output strategy. Defaults to "{}input"{}. {\itshape See known issues!}    \\\cline{1-2}
{\bfseries{date\+Strategy}}?\+: "{}format\+:date"{} $|$ "{}format\+:date-\/time"{} $|$ "{}string"{} $|$ "{}integer"{}   &Date strategy, integer allow to specify in unix-\/time min and max values. "{}format\+:date"{} creates a string schema with format\+: "{}date"{}. "{}format\+:date-\/time"{} creates a string schema with format\+: "{}date-\/time"{}. "{}string"{} is intepreted as "{}format\+:date-\/time"{}. "{}integer"{} creates an integer schema with format "{}unix-\/time"{} (unless target "{}open\+Api3"{} is used min max checks are also respected)   \\\cline{1-2}
\end{longtabu}
\texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{email\+Strategy}}?\+: "{}format\+:email"{} $|$ "{}format\+:idn-\/email"{} $|$ "{}pattern\+:zod"{} \texorpdfstring{$\vert$}{|} Choose how to handle the email string check. Defaults to "{}format\+:email"{}. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{base64\+Strategy}}?\+: "{}format\+:binary"{} $|$ "{}content\+Enconding\+:base64"{} $|$ "{}pattern\+:zod"{} \texorpdfstring{$\vert$}{|} Choose how to handle the base64 string check. Defaults to "{}content\+Encoding\+:base64"{} as described \href{https://json-schema.org/understanding-json-schema/reference/non_json_data\#contentencoding}{\texttt{ here}}. Note that "{}format\+:binary"{} is not represented in the output type as it\textquotesingle{}s not part of the JSON Schema spec and only intended to be used when targeting Open\+API 3.\+0. Later versions of Open\+API support content\+Encoding. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{definition\+Path}}?\+: "{}definitions"{} $|$ "{}\$defs"{} \texorpdfstring{$\vert$}{|} The name of the definitions property when name is passed. Defaults to "{}definitions"{}. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{target}}?\+: "{}json\+Schema7"{} $|$ "{}json\+Schema2019-\/09"{} $|$ "{}open\+Api3"{} $|$ "{}open\+Ai"{} \texorpdfstring{$\vert$}{|} Which spec to target. Defaults to "{}json\+Schema7"{} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{strict\+Unions}}?\+: boolean \texorpdfstring{$\vert$}{|} Scrubs unions of any-\/like json schemas, like {\ttfamily \{\}} or {\ttfamily true}. Multiple zod types may result in these out of necessity, such as z.\+instanceof() \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{definitions}}?\+: Record$<$string, Zod\+Schema$>$ \texorpdfstring{$\vert$}{|} See separate section below \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{error\+Messages}}?\+: boolean \texorpdfstring{$\vert$}{|} Include custom error messages created via chained function checks for supported zod types. See section below \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{markdown\+Description}}?\+: boolean \texorpdfstring{$\vert$}{|} Copies the {\ttfamily description} meta to {\ttfamily markdown\+Description} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{pattern\+Strategy}}?\+: "{}escape"{} $|$ "{}preserve"{} \texorpdfstring{$\vert$}{|} The Zod string validations {\ttfamily .includes()}, {\ttfamily .starts\+With()}, and {\ttfamily .ends\+With()} must be converted to regex to be compatible with JSON Schema\textquotesingle{}s {\ttfamily pattern}. For safety, all non-\/alphanumeric characters are {\ttfamily escape}d by default (consider {\ttfamily z.\+string().includes("{}."{})}), but this can occasionally cause problems with Unicode-\/flagged regex parsers. Use {\ttfamily preserve} to prevent this escaping behaviour and preserve the exact string written, even if it results in an inaccurate regex. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{apply\+Regex\+Flags}}?\+: boolean \texorpdfstring{$\vert$}{|} JSON Schema\textquotesingle{}s {\ttfamily pattern} doesn\textquotesingle{}t support Reg\+Exp flags, but Zod\textquotesingle{}s {\ttfamily z.\+string().regex()} does. When this option is true (default false), a best-\/effort is made to transform regexes into a flag-\/independent form (e.\+g. {\ttfamily /x/i =\texorpdfstring{$>$}{>} /\mbox{[}xX\mbox{]}/} ). Supported flags\+: {\ttfamily i} (basic Latin only), {\ttfamily m}, {\ttfamily s}. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{pipe\+Strategy}}?\+: "{}all"{} $|$ "{}input"{} $|$ "{}output"{} \texorpdfstring{$\vert$}{|} Decide which types should be included when using {\ttfamily z.\+pipe}, for example {\ttfamily z.\+string().pipe(z.\+number())} would return both {\ttfamily string} and {\ttfamily number} by default, only {\ttfamily string} for "{}input"{} and only {\ttfamily number} for "{}output"{}. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{remove\+Additional\+Strategy}}?\+: "{}passthrough"{} $|$ "{}strict"{} \texorpdfstring{$\vert$}{|} Decide when {\ttfamily additional\+Properties} should be allowed. See the section on additional properties for details. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{allowed\+Additional\+Properties}}?\+: {\ttfamily true} $|$ {\ttfamily undefined} \texorpdfstring{$\vert$}{|} What value to give {\ttfamily additional\+Properties} when allowed. See the section on additional properties for details. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{rejected\+Additional\+Properties}}?\+: {\ttfamily false} $|$ {\ttfamily undefined} \texorpdfstring{$\vert$}{|} What value to give {\ttfamily additional\+Properties} when rejected. See the section on additional properties for details. \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{override}}?\+: callback \texorpdfstring{$\vert$}{|} See section \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\bfseries{post\+Process}}?\+: callback \texorpdfstring{$\vert$}{|} See section \texorpdfstring{$\vert$}{|}\hypertarget{README.md_autotoc_md36444}{}\doxysubsubsection{\texorpdfstring{Definitions}{Definitions}}\label{README.md_autotoc_md36444}
The definitions option lets you manually add recurring schemas into definitions for cleaner outputs. It\textquotesingle{}s fully compatible with named schemas, changed definitions path and base path. Here\textquotesingle{}s a simple example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myRecurringSchema\ =\ z.string();}
\DoxyCodeLine{const\ myObjectSchema\ =\ z.object(\{\ a:\ myRecurringSchema,\ b:\ myRecurringSchema\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ myJsonSchema\ =\ zodToJsonSchema(myObjectSchema,\ \{}
\DoxyCodeLine{\ \ definitions:\ \{\ myRecurringSchema\ \},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36445}{}\doxysubsubsubsection{\texorpdfstring{Result}{Result}}\label{README.md_autotoc_md36445}

\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}type"{}:\ "{}object"{},}
\DoxyCodeLine{\ \ "{}properties"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}a"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}\$ref"{}:\ "{}\#/definitions/myRecurringSchema"{}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ "{}b"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}\$ref"{}:\ "{}\#/definitions/myRecurringSchema"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ "{}definitions"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}myRecurringSchema"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}type"{}:\ "{}string"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36446}{}\doxysubsubsection{\texorpdfstring{Error Messages}{Error Messages}}\label{README.md_autotoc_md36446}
This feature allows optionally including error messages created via chained function calls for supported zod types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ string\ schema\ with\ additional\ chained\ function\ call\ checks}
\DoxyCodeLine{const\ EmailSchema\ =\ z.string().email("{}Invalid\ email"{}).min(5,\ "{}Too\ short"{});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ jsonSchema\ =\ zodToJsonSchema(EmailSchema,\ \{\ errorMessages:\ true\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36447}{}\doxysubsubsubsection{\texorpdfstring{Result}{Result}}\label{README.md_autotoc_md36447}

\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}\$schema"{}:\ "{}http://json-\/schema.org/draft-\/07/schema\#"{},}
\DoxyCodeLine{\ \ "{}type"{}:\ "{}string"{},}
\DoxyCodeLine{\ \ "{}format"{}:\ "{}email"{},}
\DoxyCodeLine{\ \ "{}minLength"{}:\ 5,}
\DoxyCodeLine{\ \ "{}errorMessage"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}format"{}:\ "{}Invalid\ email"{},}
\DoxyCodeLine{\ \ \ \ "{}minLength"{}:\ "{}Too\ short"{}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This allows for field specific, validation step specific error messages which can be useful for building forms and such. This format is accepted by {\ttfamily react-\/hook-\/form}\textquotesingle{}s ajv resolver (and therefor {\ttfamily ajv-\/errors} which it uses under the hood). Note that if using AJV with this format will require \href{https://ajv.js.org/packages/ajv-errors.html\#usage}{\texttt{ enabling {\ttfamily ajv-\/errors}}} as vanilla AJV does not accept this format by default.\hypertarget{README.md_autotoc_md36448}{}\doxysubsubsubsection{\texorpdfstring{Custom Error Message Support}{Custom Error Message Support}}\label{README.md_autotoc_md36448}

\begin{DoxyItemize}
\item Zod\+String
\begin{DoxyItemize}
\item regex
\item min, max
\item email, cuid, uuid, url
\item ends\+With, starts\+With
\end{DoxyItemize}
\item Zod\+Number
\begin{DoxyItemize}
\item min, max, lt, lte, gt, gte,
\item int
\item multiple\+Of
\end{DoxyItemize}
\item Zod\+Set
\begin{DoxyItemize}
\item min, max
\end{DoxyItemize}
\item Zod\+Array
\begin{DoxyItemize}
\item min, max
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36449}{}\doxysubsubsection{\texorpdfstring{Additional properties}{Additional properties}}\label{README.md_autotoc_md36449}
By default, Zod removes undeclared properties when parsing object schemas. In order to replicate the expected output of this behaviour, the default for behaviour of zod\+To\+Json\+Schema is to set {\ttfamily "{}additional\+Properties"{}} to {\ttfamily false} (although the correctness of this can be debated). If you wish to allow undeclared properties you can either\+:


\begin{DoxyItemize}
\item Set {\ttfamily remove\+Additional\+Strategy} to {\ttfamily "{}strict"{}}. This will allow additional properties for any object schema that is not declared with {\ttfamily .strict()}.
\item Leave {\ttfamily remove\+Additional\+Strategy} set to its default value of {\ttfamily "{}passthrough"{}}, and add {\ttfamily .passtrough()} to your object schema.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36450}{}\doxysubsubsubsection{\texorpdfstring{Removing the {\ttfamily additional\+Properties} keyword using the {\ttfamily allowed\+Additional\+Properties} and/or {\ttfamily rejected\+Additional\+Properties} options.}{Removing the {\ttfamily additional\+Properties} keyword using the {\ttfamily allowed\+Additional\+Properties} and/or {\ttfamily rejected\+Additional\+Properties} options.}}\label{README.md_autotoc_md36450}
Some schema definitions (like Googles Gen AI API for instance) does not allow the {\ttfamily additional\+Properties} keyword at all. Luckily the JSON Schema spec allows for this\+: leaving the keyword undefined {\itshape should} have the same effect as setting it to true (as per usual YMMV). To enable this behaviour, set the option {\ttfamily allowed\+Additional\+Properties} to {\ttfamily undefined}.

To exclude the keyword even when additional properties are {\itshape not} allowed, set the {\ttfamily rejected\+Additional\+Properties} to {\ttfamily undefined} as well.

{\itshape Heads up âš ï¸\+: Both of these options will be ignored if your schema is declared with {\ttfamily .catchall(...)} as the provided schema will be used instead (if valid).}\hypertarget{README.md_autotoc_md36451}{}\doxysubsubsubsection{\texorpdfstring{Expected outputs}{Expected outputs}}\label{README.md_autotoc_md36451}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily z.\+object(\{\})} + option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily "{}additional\+Properties"{}} value    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily z.\+object(\{\})} + option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily "{}additional\+Properties"{}} value    }\\\cline{1-2}
\endhead
{\ttfamily .strip()} (default)   &{\ttfamily false} if strategy is {\ttfamily "{}passtrough"{}}, {\ttfamily true} if {\ttfamily "{}strict"{}}    \\\cline{1-2}
{\ttfamily .passtrough()}   &{\ttfamily true}    \\\cline{1-2}
{\ttfamily .strict()}   &{\ttfamily false}    \\\cline{1-2}
{\ttfamily .catchall(z.\+string())}   &{\ttfamily \{ "{}type"{}\+: "{}string"{} \}}    \\\cline{1-2}
{\ttfamily .catchall(z.\+function())}   &{\ttfamily undefined} (function schemas are not currently parseable)   \\\cline{1-2}
\end{longtabu}


Substitute {\ttfamily true} and {\ttfamily false} for {\ttfamily undefined} according to {\ttfamily allowed\+Additional\+Properties} and/or {\ttfamily rejected\+Additional\+Properties} respectively.\hypertarget{README.md_autotoc_md36452}{}\doxysubsubsection{\texorpdfstring{{\ttfamily override}}{{\ttfamily override}}}\label{README.md_autotoc_md36452}
This options takes a callback receiving a Zod schema definition, the current reference object (containing the current ref path and other options), an argument containing inforation about wether or not the schema has been encountered before, and a force\+Resolution argument.

Important\+: if you don\textquotesingle{}t want to override the current item you have to return the {\ttfamily ignore\+Override} symbol exported from the index. This is because {\ttfamily undefined} is a valid option to return when you want the property to be excluded from the resulting JSON schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ zodToJsonSchema,\ \{\ ignoreOverride\ \}\ from\ "{}zod-\/to-\/json-\/schema"{};}
\DoxyCodeLine{}
\DoxyCodeLine{zodToJsonSchema(}
\DoxyCodeLine{\ \ z.object(\{}
\DoxyCodeLine{\ \ \ \ ignoreThis:\ z.string(),}
\DoxyCodeLine{\ \ \ \ overrideThis:\ z.string(),}
\DoxyCodeLine{\ \ \ \ removeThis:\ z.string(),}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ override:\ (def,\ refs)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ const\ path\ =\ refs.currentPath.join("{}/"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ if\ (path\ ===\ "{}\#/properties/overrideThis"{})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ type:\ "{}integer"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ if\ (path\ ===\ "{}\#/properties/removeThis"{})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ undefined;}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ //\ Important!\ Do\ not\ return\ \`{}undefined`\ or\ void\ unless\ you\ want\ to\ remove\ the\ property\ from\ the\ resulting\ schema\ completely.}
\DoxyCodeLine{\ \ \ \ \ \ return\ ignoreOverride;}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{);}

\end{DoxyCode}


Expected output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}type"{}:\ "{}object"{},}
\DoxyCodeLine{\ \ "{}required"{}:\ ["{}ignoreThis"{},\ "{}overrideThis"{}],}
\DoxyCodeLine{\ \ "{}properties"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}ignoreThis"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}type"{}:\ "{}string"{}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ "{}overrideThis"{}:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ "{}type"{}:\ "{}integer"{}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ "{}additionalProperties"{}:\ false}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36453}{}\doxysubsubsection{\texorpdfstring{{\ttfamily post\+Process}}{{\ttfamily post\+Process}}}\label{README.md_autotoc_md36453}
Besided receiving all arguments of the {\ttfamily override} callback, the {\ttfamily post\+Process} callback also receives the generated schema. It should always return a JSON Schema, or {\ttfamily undefined} if you wish to filter it out. Unlike the {\ttfamily override} callback you do not have to return {\ttfamily ignore\+Override} if you are happy with the produced schema; simply return it unchanged.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ zodToJsonSchema,\ \{\ PostProcessCallback\ \}\ from\ "{}zod-\/to-\/json-\/schema"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Define\ the\ callback\ to\ be\ used\ to\ process\ the\ output\ using\ the\ PostProcessCallback\ type:}
\DoxyCodeLine{const\ postProcess:\ PostProcessCallback\ =\ (}
\DoxyCodeLine{\ \ //\ The\ original\ output\ produced\ by\ the\ package\ itself:}
\DoxyCodeLine{\ \ jsonSchema,}
\DoxyCodeLine{\ \ //\ The\ ZodSchema\ def\ used\ to\ produce\ the\ original\ schema:}
\DoxyCodeLine{\ \ def,}
\DoxyCodeLine{\ \ //\ The\ refs\ object\ containing\ the\ current\ path,\ passed\ options,\ etc.}
\DoxyCodeLine{\ \ refs,}
\DoxyCodeLine{)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (!jsonSchema)\ \{}
\DoxyCodeLine{\ \ \ \ return\ jsonSchema;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Try\ to\ expand\ description\ as\ JSON\ meta:}
\DoxyCodeLine{\ \ if\ (jsonSchema.description)\ \{}
\DoxyCodeLine{\ \ \ \ try\ \{}
\DoxyCodeLine{\ \ \ \ \ \ jsonSchema\ =\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ...jsonSchema,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ...JSON.parse(jsonSchema.description),}
\DoxyCodeLine{\ \ \ \ \ \ \};}
\DoxyCodeLine{\ \ \ \ \}\ catch\ \{\}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Make\ all\ numbers\ nullable:}
\DoxyCodeLine{\ \ if\ ("{}type"{}\ in\ jsonSchema!\ \&\&\ jsonSchema.type\ ===\ "{}number"{})\ \{}
\DoxyCodeLine{\ \ \ \ jsonSchema.type\ =\ ["{}number"{},\ "{}null"{}];}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Add\ the\ refs\ path,\ just\ because}
\DoxyCodeLine{\ \ (jsonSchema\ as\ any).path\ =\ refs.currentPath;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ return\ jsonSchema;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ jsonSchema\ =\ zodToJsonSchema(zodSchema,\ \{\ postProcess\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36454}{}\doxysubsubsubsection{\texorpdfstring{Using {\ttfamily post\+Process} for including examples and other meta}{Using {\ttfamily post\+Process} for including examples and other meta}}\label{README.md_autotoc_md36454}
Adding support for examples and other JSON Schema meta keys are among the most commonly requested features for this project. Unfortunately the current Zod major (3) has pretty anemic support for this, so some userland hacking is required. Since this is such a common usecase I\textquotesingle{}ve included a helper function that simply tries to parse any description as JSON and expand it into the resulting schema.

Simply stringify whatever you want added to the output schema as the description, then import and use {\ttfamily json\+Description} as the post\+Process option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ zodToJsonSchema,\ \{\ jsonDescription\ \}\ from\ "{}zod-\/to-\/json-\/schema"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ zodSchema\ =\ z.string().describe(}
\DoxyCodeLine{\ \ JSON.stringify(\{}
\DoxyCodeLine{\ \ \ \ title:\ "{}My\ string"{},}
\DoxyCodeLine{\ \ \ \ description:\ "{}My\ description"{},}
\DoxyCodeLine{\ \ \ \ examples:\ ["{}Foo"{},\ "{}Bar"{}],}
\DoxyCodeLine{\ \ \ \ whatever:\ 123,}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ jsonSchema\ =\ zodToJsonSchema(zodSchema,\ \{}
\DoxyCodeLine{\ \ postProcess:\ jsonDescription,}
\DoxyCodeLine{\});}

\end{DoxyCode}


Expected output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ "{}\$schema"{}:\ "{}http://json-\/schema.org/draft-\/07/schema\#"{},}
\DoxyCodeLine{\ \ "{}type"{}:\ "{}string"{},}
\DoxyCodeLine{\ \ "{}title"{}:\ "{}My\ string"{},}
\DoxyCodeLine{\ \ "{}description"{}:\ "{}My\ description"{},}
\DoxyCodeLine{\ \ "{}examples"{}:\ ["{}Foo"{},\ "{}Bar"{}],}
\DoxyCodeLine{\ \ "{}whatever"{}:\ 123}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36455}{}\doxysubsection{\texorpdfstring{Known issues}{Known issues}}\label{README.md_autotoc_md36455}

\begin{DoxyItemize}
\item The Open\+AI target should be considered experimental for now, as some combination of options may break the compatibility.
\item When using {\ttfamily .transform}, the return type is inferred from the supplied function. In other words, there is no schema for the return type, and there is no way to convert it in runtime. Currently the JSON schema will therefore reflect the input side of the Zod schema and not necessarily the output (the latter aka. {\ttfamily z.\+infer}). If this causes problems with your schema, consider using the effect\+Strategy "{}any"{}, which will allow any type of output.
\item JSON Schemas does not support any other key type than strings for objects. When using {\ttfamily z.\+record} with any other key type, this will be ignored. An exception to this rule is {\ttfamily z.\+enum} as is supported since 3.\+11.\+3
\item Relative JSON pointers, while published alongside \href{https://json-schema.org/specification.html}{\texttt{ JSON schema draft 2020-\/12}}, is not technically a part of it. Currently, most resolvers do not handle them at all.
\item Since v3, the Object parser uses {\ttfamily .is\+Optional()} to check if a property should be included in {\ttfamily required} or not. This has the potentially dangerous behavior of calling {\ttfamily .safe\+Parse} with {\ttfamily undefined}. To work around this, make sure your {\ttfamily preprocess} and other effects callbacks are pure and not liable to throw errors. An issue has been logged in the Zod repo and can be \href{https://github.com/colinhacks/zod/issues/1460}{\texttt{ tracked here}}.
\item JSON Schema version 2020-\/12 is not yet officially supported. However, you should be able to use this library to obtain a compatible schema for the 2020-\/12 format just by changing the returned schema\textquotesingle{}s {\ttfamily \$schema} field to\+: "{}https\+://json-\/schema.\+org/draft/2020-\/12/schema\#"{}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36456}{}\doxysubsection{\texorpdfstring{Versioning}{Versioning}}\label{README.md_autotoc_md36456}
This package {\itshape does not} follow semantic versioning. The major and minor versions of this package instead reflects feature parity with the \href{http://npmjs.com/package/zod}{\texttt{ Zod package}}.

I will do my best to keep API-\/breaking changes to an absolute minimum, but new features may appear as "{}patches"{}, such as introducing the options pattern in 3.\+9.\+1.\hypertarget{README.md_autotoc_md36457}{}\doxysubsection{\texorpdfstring{Changelog}{Changelog}}\label{README.md_autotoc_md36457}
\href{https://github.com/StefanTerdell/zod-to-json-schema/blob/master/changelog.md}{\texttt{ https\+://github.\+com/\+Stefan\+Terdell/zod-\/to-\/json-\/schema/blob/master/changelog.\+md}} 