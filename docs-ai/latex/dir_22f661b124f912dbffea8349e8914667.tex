\doxysection{node\+\_\+modules/zod-\/to-\/ts/node\+\_\+modules/zod Directory Reference}
\hypertarget{dir_22f661b124f912dbffea8349e8914667}{}\label{dir_22f661b124f912dbffea8349e8914667}\index{node\_modules/zod-\/to-\/ts/node\_modules/zod Directory Reference@{node\_modules/zod-\/to-\/ts/node\_modules/zod Directory Reference}}


\doxysubsection{Detailed Description}


 \doxysubsection*{Zod}



âœ¨ \href{https://zod.dev}{\texttt{ https\+://zod.\+dev}} âœ¨ ~\newline
 Type\+Script-\/first schema validation with static type inference 

~\newline
 

\href{https://github.com/colinhacks/zod/actions?query=branch\%3Amain}{\texttt{ }} \href{https://twitter.com/colinhacks}{\texttt{ }} \href{https://opensource.org/licenses/MIT}{\texttt{ }} \href{https://www.npmjs.com/package/zod}{\texttt{ }} \href{https://github.com/colinhacks/zod}{\texttt{ }} 

 \href{https://zod.dev}{\texttt{ Documentation}} ~~â€¢~~ \href{https://discord.gg/RcG33DQJdf}{\texttt{ Discord}} ~~â€¢~~ \href{https://www.npmjs.com/package/zod}{\texttt{ npm}} ~~â€¢~~ \href{https://deno.land/x/zod}{\texttt{ deno}} ~~â€¢~~ \href{https://github.com/colinhacks/zod/issues/new}{\texttt{ Issues}} ~~â€¢~~ \href{https://twitter.com/colinhacks}{\texttt{ @colinhacks}} ~~â€¢~~ \href{https://trpc.io}{\texttt{ t\+RPC}} ~\newline
 

~\newline
 ~\newline


\href{https://go.clerk.com/hqN4rp7}{\texttt{ }}

~\newline
\hypertarget{README.md_autotoc_md36461}{}\doxysubsubsection{\texorpdfstring{Table of contents}{Table of contents}}\label{README.md_autotoc_md36461}
\begin{quote}
These docs have been translated into Chinese and Korean. \end{quote}



\begin{DoxyItemize}
\item Table of contents
\item Introduction
\begin{DoxyItemize}
\item Sponsors
\begin{DoxyItemize}
\item Platinum
\item Gold
\item Silver
\item Bronze
\item Copper
\end{DoxyItemize}
\item Ecosystem
\begin{DoxyItemize}
\item \doxylink{md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g_resources}{Resources}
\item API libraries
\item Form integrations
\item Zod to X
\item X to Zod
\item Mocking
\item Powered by Zod
\item Utilities for Zod
\end{DoxyItemize}
\end{DoxyItemize}
\item \doxylink{README.md_installation}{Installation}
\begin{DoxyItemize}
\item Requirements
\item From \`{}npm\`{}
\end{DoxyItemize}
\item Basic usage
\item Primitives
\item Coercion for primitives
\item Literals
\item Strings
\begin{DoxyItemize}
\item Datetimes
\item Dates
\item Times
\item IP addresses
\item IP ranges
\end{DoxyItemize}
\item Numbers
\item Big\+Ints
\item Na\+Ns
\item Booleans
\item Dates
\item Zod enums
\item Native enums
\item Optionals
\item Nullables
\item \doxylink{README.md_objects}{Objects}
\begin{DoxyItemize}
\item \`{}.shape\`{}
\item \`{}.keyof\`{}
\item \`{}.extend\`{}
\item \doxylink{README.md_merge}{\`{}.merge\`{}}
\item \`{}.pick/.omit\`{}
\item \`{}.partial\`{}
\item \`{}.deep\+Partial\`{}
\item \`{}.required\`{}
\item \`{}.passthrough\`{}
\item \`{}.strict\`{}
\item \`{}.strip\`{}
\item \`{}.catchall\`{}
\end{DoxyItemize}
\item Arrays
\begin{DoxyItemize}
\item \`{}.element\`{}
\item \`{}.nonempty\`{}
\item \`{}.min/.max/.length\`{}
\end{DoxyItemize}
\item Tuples
\item Unions
\item Discriminated unions
\item Records
\begin{DoxyItemize}
\item Record key type
\end{DoxyItemize}
\item Maps
\item Sets
\item Intersections
\item Recursive types
\begin{DoxyItemize}
\item Zod\+Type with Zod\+Effects
\item JSON type
\item Cyclical objects
\end{DoxyItemize}
\item Promises
\item Instanceof
\item \doxylink{tester_8cpp_a3c51ddeb3d007f204eced4cb67c52ce7}{Functions}
\item Preprocess
\item Custom schemas
\item Schema methods
\begin{DoxyItemize}
\item \`{}.parse\`{}
\item \`{}.parse\+Async\`{}
\item \`{}.safe\+Parse\`{}
\item \`{}.safe\+Parse\+Async\`{}
\item \`{}.refine\`{}
\begin{DoxyItemize}
\item Arguments
\item Customize error path
\item Asynchronous refinements
\item Relationship to transforms
\end{DoxyItemize}
\item \`{}.super\+Refine\`{}
\begin{DoxyItemize}
\item Abort early
\item Type refinements
\end{DoxyItemize}
\item \`{}.transform\`{}
\begin{DoxyItemize}
\item Chaining order
\item Validating during transform
\item Relationship to refinements
\item Async transforms
\end{DoxyItemize}
\item \`{}.default\`{}
\item \`{}.describe\`{}
\item \`{}.catch\`{}
\item \`{}.optional\`{}
\item \`{}.nullable\`{}
\item \`{}.nullish\`{}
\item \`{}.array\`{}
\item \doxylink{README.md_promise}{\`{}.promise\`{}}
\item \`{}.or\`{}
\item \`{}.and\`{}
\item \`{}.brand\`{}
\item \`{}.readonly\`{}
\item \`{}.pipe\`{}
\begin{DoxyItemize}
\item You can use \`{}.pipe()\`{} to fix common issues with \`{}z.coerce\`{}.
\end{DoxyItemize}
\end{DoxyItemize}
\item Guides and concepts
\begin{DoxyItemize}
\item Type inference
\item Writing generic functions
\begin{DoxyItemize}
\item Constraining allowable inputs
\end{DoxyItemize}
\item Error handling
\item Error formatting
\end{DoxyItemize}
\item Comparison
\begin{DoxyItemize}
\item Joi
\item Yup
\item io-\/ts
\item Runtypes
\item Ow
\end{DoxyItemize}
\item Changelog
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36462}{}\doxysubsubsection{\texorpdfstring{Introduction}{Introduction}}\label{README.md_autotoc_md36462}
Zod is a Type\+Script-\/first schema declaration and validation library. I\textquotesingle{}m using the term "{}schema"{} to broadly refer to any data type, from a simple {\ttfamily string} to a complex nested object.

Zod is designed to be as developer-\/friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator {\itshape once} and Zod will automatically infer the static Type\+Script type. It\textquotesingle{}s easy to compose simpler types into complex data structures.

Some other great aspects\+:


\begin{DoxyItemize}
\item Zero dependencies
\item Works in Node.\+js and all modern browsers
\item Tiny\+: 8kb minified + zipped
\item Immutable\+: methods (e.\+g. {\ttfamily .optional()}) return a new instance
\item Concise, chainable interface
\item Functional approach\+: \href{https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/}{\texttt{ parse, don\textquotesingle{}t validate}}
\item Works with plain Java\+Script too! You don\textquotesingle{}t need to use Type\+Script.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36463}{}\doxysubsubsection{\texorpdfstring{Sponsors}{Sponsors}}\label{README.md_autotoc_md36463}
Sponsorship at any level is appreciated and encouraged. If you built a paid product using Zod, consider one of the \href{https://github.com/sponsors/colinhacks}{\texttt{ corporate tiers}}.

~\newline
 \doxysubsubsubsection*{Diamond}

~\newline


 \href{https://go.clerk.com/PKHrcwh}{\texttt{   }} ~\newline
 ~\newline
 

 The most comprehensive User Management Platform ~\newline
 \href{https://go.clerk.com/PKHrcwh}{\texttt{ clerk.\+com}} 

 

~\newline
 ~\newline


\doxysubsubsubsection*{Platinum}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\PBS\centering 





\href{https://www.coderabbit.ai/}{\texttt{   }} ~\newline
 ~\newline
 Cut code review time \& bugs in half ~\newline
 \href{https://www.coderabbit.ai/}{\texttt{ coderabbit.\+ai}} 





\\\cline{1-1}
\end{longtabu}


~\newline


\doxysubsubsubsection*{Gold}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering 





\href{https://www.courier.com/?utm_source=zod&utm_campaign=osssponsors}{\texttt{   }} ~\newline
 ~\newline
 The API platform for sending notifications ~\newline
 \href{https://www.courier.com/?utm_source=zod&utm_campaign=osssponsors}{\texttt{ courier.\+com}} 





&\PBS\centering 





\href{https://liblab.com/?utm_source=zod}{\texttt{   }} ~\newline
 ~\newline
 Generate better SDKs for your APIs ~\newline
 \href{https://liblab.com/?utm_source=zod}{\texttt{ liblab.\+com}} 





\\\cline{1-2}
\PBS\centering 





\href{https://neon.tech}{\texttt{   }} ~\newline
 ~\newline
 Serverless Postgres â€” Ship faster ~\newline
 \href{https://neon.tech}{\texttt{ neon.\+tech}} 





&\PBS\centering 





\href{https://retool.com/?utm_source=github&utm_medium=referral&utm_campaign=zod}{\texttt{   }} ~\newline
 ~\newline
 Build AI apps and workflows with \href{https://retool.com/products/ai?utm_source=github&utm_medium=referral&utm_campaign=zod}{\texttt{ Retool AI}} ~\newline
 \href{https://retool.com/?utm_source=github&utm_medium=referral&utm_campaign=zod}{\texttt{ retool.\+com}} 





\\\cline{1-2}
\PBS\centering 





\href{https://stainlessapi.com}{\texttt{   }} ~\newline
 ~\newline
 Generate best-\/in-\/class SDKs ~\newline
 \href{https://stainlessapi.com}{\texttt{ stainlessapi.\+com}} 





&\PBS\centering 





\href{https://speakeasy.com/?utm_source=zod+docs}{\texttt{   }} ~\newline
 ~\newline
 SDKs \& Terraform providers for your API ~\newline
 \href{https://speakeasy.com/?utm_source=zod+docs}{\texttt{ speakeasy.\+com}} 





\\\cline{1-2}
\end{longtabu}


~\newline


\doxysubsubsubsection*{Silver}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering  ~\newline
 \href{https://nitric.io/}{\texttt{ Nitric}}  &\PBS\centering  ~\newline
 \href{https://www.propelauth.com/}{\texttt{ Propel\+Auth}}  &\PBS\centering  ~\newline
 \href{https://cerbos.dev/}{\texttt{ Cerbos}}  &\PBS\centering  ~\newline
 \href{https://scalar.com/}{\texttt{ Scalar}}  \\\cline{1-4}
\PBS\centering  ~\newline
 \href{https://trigger.dev}{\texttt{ Trigger.\+dev}}  &\PBS\centering  ~\newline
 \href{https://transloadit.com/?utm_source=zod&utm_medium=refe
    rral&utm_campaign=sponsorship&utm_content=github}{\texttt{ Transloadit}}  &\PBS\centering  ~\newline
 \href{https://infisical.com}{\texttt{ Infisical}}  &\PBS\centering  ~\newline
 \href{https://whop.com/}{\texttt{ Whop}}  \\\cline{1-4}
\PBS\centering  ~\newline
 \href{https://cryptojobslist.com/}{\texttt{ Crypto\+Jobs\+List}}  &\PBS\centering  ~\newline
 \href{https://plain.com/}{\texttt{ Plain.}}  &\PBS\centering  ~\newline
 \href{https://inngest.com/}{\texttt{ Inngest}}  &\PBS\centering  ~\newline
 \href{https://storyblok.com/}{\texttt{ Storyblok}}  \\\cline{1-4}
\PBS\centering  ~\newline
 \href{https://mux.link/zod}{\texttt{ Mux}}   \\\cline{1-4}
\end{longtabu}


~\newline


\doxysubsubsubsection*{Bronze}

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \href{https://www.val.town/}{\texttt{   }}  &\PBS\centering \href{https://www.route4me.com/}{\texttt{  }}  &\PBS\centering \href{https://encore.dev}{\texttt{  }}  &\PBS\centering \href{https://www.replay.io/}{\texttt{  }}   \\\cline{1-4}
\PBS\centering \href{https://www.numeric.io}{\texttt{  }}  &\PBS\centering \href{https://marcatopartners.com}{\texttt{  }}  &\PBS\centering \href{https://interval.com}{\texttt{  }}  &\PBS\centering \href{https://seasoned.cc}{\texttt{  }}   \\\cline{1-4}
\PBS\centering \href{https://www.bamboocreative.nz/}{\texttt{  }}  &\PBS\centering \href{https://github.com/jasonLaster}{\texttt{  }}   \\\cline{1-4}
\end{longtabu}
\hypertarget{README.md_autotoc_md36464}{}\doxysubsubsubsection{\texorpdfstring{Ecosystem}{Ecosystem}}\label{README.md_autotoc_md36464}
There are a growing number of tools that are built atop or support Zod natively! If you\textquotesingle{}ve built a tool or library on top of Zod, tell me about it \href{https://twitter.com/colinhacks}{\texttt{ on Twitter}} or \href{https://github.com/colinhacks/zod/discussions}{\texttt{ start a Discussion}}. I\textquotesingle{}ll add it below and tweet it out.\hypertarget{README.md_autotoc_md36465}{}\doxysubsubsubsubsection{\texorpdfstring{Resources}{Resources}}\label{README.md_autotoc_md36465}

\begin{DoxyItemize}
\item \href{https://www.totaltypescript.com/tutorials/zod}{\texttt{ Total Type\+Script Zod Tutorial}} by \href{https://twitter.com/mattpocockuk}{\texttt{ @mattpocockuk}}
\item \href{https://www.youtube.com/watch?v=rY_XqfSHock}{\texttt{ Fixing Type\+Script\textquotesingle{}s Blindspot\+: Runtime Typechecking}} by \href{https://twitter.com/jherr}{\texttt{ @jherr}}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36466}{}\doxysubsubsubsubsection{\texorpdfstring{API libraries}{API libraries}}\label{README.md_autotoc_md36466}

\begin{DoxyItemize}
\item \href{https://github.com/trpc/trpc}{\texttt{ {\ttfamily t\+RPC}}}\+: Build end-\/to-\/end typesafe APIs without Graph\+QL.
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs}{\texttt{ {\ttfamily @anatine/zod-\/nestjs}}}\+: Helper methods for using Zod in a Nest\+JS project.
\item \href{https://github.com/flock-community/zod-endpoints}{\texttt{ {\ttfamily zod-\/endpoints}}}\+: Contract-\/first strictly typed endpoints with Zod. Open\+API compatible.
\item \href{https://github.com/evertdespiegeleer/zhttp}{\texttt{ {\ttfamily zhttp}}}\+: An Open\+API compatible, strictly typed http library with Zod input and response validation.
\item \href{https://github.com/SeasonedSoftware/domain-functions/}{\texttt{ {\ttfamily domain-\/functions}}}\+: Decouple your business logic from your framework using composable functions. With first-\/class type inference from end to end powered by Zod schemas.
\item \href{https://github.com/ecyrbe/zodios}{\texttt{ {\ttfamily @zodios/core}}}\+: A typescript API client with runtime and compile time validation backed by axios and zod.
\item \href{https://github.com/RobinTail/express-zod-api}{\texttt{ {\ttfamily express-\/zod-\/api}}}\+: Build Express-\/based APIs with I/O schema validation and custom middlewares.
\item \href{https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md}{\texttt{ {\ttfamily tapiduck}}}\+: End-\/to-\/end typesafe JSON APIs with Zod and Express; a bit like t\+RPC, but simpler.
\item \href{https://github.com/JakeFenley/koa-zod-router}{\texttt{ {\ttfamily koa-\/zod-\/router}}}\+: Create typesafe routes in Koa with I/O validation using Zod.
\item \href{https://github.com/RobinTail/zod-sockets}{\texttt{ {\ttfamily zod-\/sockets}}}\+: Zod-\/powered Socket.\+IO microframework with I/O validation and built-\/in Async\+API specs
\item \href{https://github.com/inkognitro/oas-tszod-gen}{\texttt{ {\ttfamily oas-\/tszod-\/gen}}}\+: Client SDK code generator to convert Open\+Api v3 specifications into TS endpoint caller functions with Zod types.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36467}{}\doxysubsubsubsubsection{\texorpdfstring{Form integrations}{Form integrations}}\label{README.md_autotoc_md36467}

\begin{DoxyItemize}
\item \href{https://github.com/react-hook-form/resolvers\#zod}{\texttt{ {\ttfamily react-\/hook-\/form}}}\+: A first-\/party Zod resolver for React Hook Form.
\item \href{https://github.com/causaly/zod-validation-error}{\texttt{ {\ttfamily zod-\/validation-\/error}}}\+: Generate user-\/friendly error messages from {\ttfamily Zod\+Error}s.
\item \href{https://github.com/robertLichtnow/zod-formik-adapter}{\texttt{ {\ttfamily zod-\/formik-\/adapter}}}\+: A community-\/maintained Formik adapter for Zod.
\item \href{https://github.com/esamattis/react-zorm}{\texttt{ {\ttfamily react-\/zorm}}}\+: Standalone {\ttfamily \texorpdfstring{$<$}{<}form\texorpdfstring{$>$}{>}} generation and validation for React using Zod.
\item \href{https://github.com/rileytomasek/zodix}{\texttt{ {\ttfamily zodix}}}\+: Zod utilities for Form\+Data and URLSearch\+Params in Remix loaders and actions.
\item \href{https://conform.guide/api/zod/parseWithZod}{\texttt{ {\ttfamily conform}}}\+: A typesafe form validation library for progressive enhancement of HTML forms. Works with Remix and Next.\+js.
\item \href{https://github.com/kiliman/remix-params-helper}{\texttt{ {\ttfamily remix-\/params-\/helper}}}\+: Simplify integration of Zod with standard URLSearch\+Params and Form\+Data for Remix apps.
\item \href{https://github.com/glazy/formik-validator-zod}{\texttt{ {\ttfamily formik-\/validator-\/zod}}}\+: Formik-\/compliant validator library that simplifies using Zod with Formik.
\item \href{https://github.com/aiji42/zod-i18n}{\texttt{ {\ttfamily zod-\/i18n-\/map}}}\+: Useful for translating Zod error messages.
\item \href{https://github.com/fabian-hiller/modular-forms}{\texttt{ {\ttfamily @modular-\/forms/solid}}}\+: Modular form library for Solid\+JS that supports Zod for validation.
\item \href{https://github.com/crutchcorn/houseform/}{\texttt{ {\ttfamily houseform}}}\+: A React form library that uses Zod for validation.
\item \href{https://github.com/ciscoheat/sveltekit-superforms}{\texttt{ {\ttfamily sveltekit-\/superforms}}}\+: Supercharged form library for Svelte\+Kit with Zod validation.
\item \href{https://github.com/MonoidDev/mobx-zod-form}{\texttt{ {\ttfamily mobx-\/zod-\/form}}}\+: Data-\/first form builder based on MobX \& Zod.
\item \href{https://github.com/logaretm/vee-validate/tree/main/packages/zod}{\texttt{ {\ttfamily @vee-\/validate/zod}}}\+: Form library for Vue.\+js with Zod schema validation.
\item \href{https://github.com/thepeaklab/zod-form-renderer}{\texttt{ {\ttfamily zod-\/form-\/renderer}}}\+: Auto-\/infer form fields from zod schema and render them with react-\/hook-\/form with E2E type safety.
\item \href{https://github.com/MrBr/antd-zod}{\texttt{ {\ttfamily antd-\/zod}}}\+: Zod adapter for Ant Design form fields validation.
\item \href{https://github.com/schalkventer/frrm}{\texttt{ {\ttfamily frrm}}}\+: Tiny 0.\+5kb Zod-\/based, HTML form abstraction that goes brr.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36468}{}\doxysubsubsubsubsection{\texorpdfstring{Zod to X}{Zod to X}}\label{README.md_autotoc_md36468}

\begin{DoxyItemize}
\item \href{https://github.com/sachinraja/zod-to-ts}{\texttt{ {\ttfamily zod-\/to-\/ts}}}\+: Generate Type\+Script definitions from Zod schemas.
\item \href{https://github.com/StefanTerdell/zod-to-json-schema}{\texttt{ {\ttfamily zod-\/to-\/json-\/schema}}}\+: Convert your Zod schemas into \href{https://json-schema.org/}{\texttt{ JSON Schemas}}.
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi}{\texttt{ {\ttfamily @anatine/zod-\/openapi}}}\+: Converts a Zod schema to an Open\+API v3.\+x {\ttfamily Schema\+Object}.
\item \href{https://github.com/DavidTimms/zod-fast-check}{\texttt{ {\ttfamily zod-\/fast-\/check}}}\+: Generate {\ttfamily fast-\/check} arbitraries from Zod schemas.
\item \href{https://github.com/kbkk/abitia/tree/master/packages/zod-dto}{\texttt{ {\ttfamily zod-\/dto}}}\+: Generate Nest.\+js DTOs from a Zod schema.
\item \href{https://github.com/turkerdev/fastify-type-provider-zod}{\texttt{ {\ttfamily fastify-\/type-\/provider-\/zod}}}\+: Create Fastify type providers from Zod schemas.
\item \href{https://github.com/asteasolutions/zod-to-openapi}{\texttt{ {\ttfamily zod-\/to-\/openapi}}}\+: Generate full Open\+API (Swagger) docs from Zod, including schemas, endpoints \& parameters.
\item \href{https://github.com/incetarik/nestjs-graphql-zod}{\texttt{ {\ttfamily nestjs-\/graphql-\/zod}}}\+: Generates Nest\+JS Graph\+QL model classes from Zod schemas. Provides Graph\+QL method decorators working with Zod schemas.
\item \href{https://github.com/samchungy/zod-openapi}{\texttt{ {\ttfamily zod-\/openapi}}}\+: Create full Open\+API v3.\+x documentation from Zod schemas.
\item \href{https://github.com/samchungy/fastify-zod-openapi}{\texttt{ {\ttfamily fastify-\/zod-\/openapi}}}\+: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.
\item \href{https://typeschema.com/}{\texttt{ {\ttfamily typeschema}}}\+: Universal adapter for schema validation.
\item \href{https://github.com/commonbaseapp/zodex}{\texttt{ {\ttfamily zodex}}}\+: (De)serialization for zod schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36469}{}\doxysubsubsubsubsection{\texorpdfstring{X to Zod}{X to Zod}}\label{README.md_autotoc_md36469}

\begin{DoxyItemize}
\item \href{https://github.com/fabien0102/ts-to-zod}{\texttt{ {\ttfamily ts-\/to-\/zod}}}\+: Convert Type\+Script definitions into Zod schemas.
\item \href{https://github.com/johngeorgewright/runtyping}{\texttt{ {\ttfamily @runtyping/zod}}}\+: Generate Zod from static types \& JSON schema.
\item \href{https://github.com/StefanTerdell/json-schema-to-zod}{\texttt{ {\ttfamily json-\/schema-\/to-\/zod}}}\+: Convert your \href{https://json-schema.org/}{\texttt{ JSON Schemas}} into Zod schemas. \href{https://StefanTerdell.github.io/json-schema-to-zod-react/}{\texttt{ Live demo}}.
\item \href{https://github.com/rsinohara/json-to-zod}{\texttt{ {\ttfamily json-\/to-\/zod}}}\+: Convert JSON objects into Zod schemas. \href{https://rsinohara.github.io/json-to-zod-react/}{\texttt{ Live demo}}.
\item \href{https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema}{\texttt{ {\ttfamily graphql-\/codegen-\/typescript-\/validation-\/schema}}}\+: Graph\+QL Code Generator plugin to generate form validation schema from your Graph\+QL schema.
\item \href{https://github.com/CarterGrimmeisen/zod-prisma}{\texttt{ {\ttfamily zod-\/prisma}}}\+: Generate Zod schemas from your Prisma schema.
\item \href{https://github.com/Southclaws/supervillain}{\texttt{ {\ttfamily Supervillain}}}\+: Generate Zod schemas from your Go structs.
\item \href{https://github.com/omar-dulaimi/prisma-zod-generator}{\texttt{ {\ttfamily prisma-\/zod-\/generator}}}\+: Emit Zod schemas from your Prisma schema.
\item \href{https://orm.drizzle.team/docs/zod}{\texttt{ {\ttfamily drizzle-\/zod}}}\+: Emit Zod schemas from your Drizzle schema.
\item \href{https://github.com/omar-dulaimi/prisma-trpc-generator}{\texttt{ {\ttfamily prisma-\/trpc-\/generator}}}\+: Emit fully implemented t\+RPC routers and their validation schemas using Zod.
\item \href{https://github.com/chrishoermann/zod-prisma-types}{\texttt{ {\ttfamily zod-\/prisma-\/types}}} Create Zod types from your Prisma models.
\item \href{https://app.quicktype.io/}{\texttt{ {\ttfamily quicktype}}}\+: Convert JSON objects and JSON schemas into Zod schemas.
\item \href{https://github.com/saiichihashimoto/sanity-typed/tree/main/packages/zod}{\texttt{ {\ttfamily @sanity-\/typed/zod}}}\+: Generate Zod Schemas from \href{https://www.sanity.io/docs/schema-types}{\texttt{ Sanity Schemas}}.
\item \href{https://github.com/ivangreene/java-to-zod}{\texttt{ {\ttfamily java-\/to-\/zod}}}\+: Convert POJOs to Zod schemas
\item \href{https://github.com/anymaniax/orval}{\texttt{ {\ttfamily Orval}}}\+: Generate Zod schemas from Open\+API schemas
\item \href{https://github.com/kubb-labs/kubb}{\texttt{ {\ttfamily Kubb}}}\+: Generate SDKs and Zod schemas from your Open\+API schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36470}{}\doxysubsubsubsubsection{\texorpdfstring{Mocking}{Mocking}}\label{README.md_autotoc_md36470}

\begin{DoxyItemize}
\item \href{https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock}{\texttt{ {\ttfamily @anatine/zod-\/mock}}}\+: Generate mock data from a Zod schema. Powered by \href{https://github.com/faker-js/faker}{\texttt{ faker.\+js}}.
\item \href{https://github.com/dipasqualew/zod-mocking}{\texttt{ {\ttfamily zod-\/mocking}}}\+: Generate mock data from your Zod schemas.
\item \href{https://github.com/timdeschryver/zod-fixture}{\texttt{ {\ttfamily zod-\/fixture}}}\+: Use your zod schemas to automate the generation of non-\/relevant test fixtures in a deterministic way.
\item \href{https://zocker.sigrist.dev}{\texttt{ {\ttfamily zocker}}}\+: Generate plausible mock-\/data from your schemas.
\item \href{https://github.com/ItMaga/zodock}{\texttt{ {\ttfamily zodock}}} Generate mock data based on Zod schemas.
\item \href{https://github.com/soc221b/zod-schema-faker}{\texttt{ {\ttfamily zod-\/schema-\/faker}}} Generates mock data from Zod schemas. Powered by \href{https://github.com/faker-js/faker}{\texttt{ @faker-\/js/faker}} and \href{https://github.com/fent/randexp.js}{\texttt{ randexp.\+js}}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36471}{}\doxysubsubsubsubsection{\texorpdfstring{Powered by Zod}{Powered by Zod}}\label{README.md_autotoc_md36471}

\begin{DoxyItemize}
\item \href{https://github.com/JacobWeisenburger/freerstore}{\texttt{ {\ttfamily freerstore}}}\+: Firestore cost optimizer.
\item \href{https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible\#runtime-validation-and-static-type-inference}{\texttt{ {\ttfamily slonik}}}\+: Node.\+js Postgres client with strong Zod integration.
\item \href{https://github.com/a2lix/schemql}{\texttt{ {\ttfamily schemql}}}\+: Enhances your SQL workflow by combining raw SQL with targeted type safety and schema validation.
\item \href{https://github.com/mdbetancourt/soly}{\texttt{ {\ttfamily soly}}}\+: Create CLI applications with zod.
\item \href{https://github.com/vadimdemedes/pastel}{\texttt{ {\ttfamily pastel}}}\+: Create CLI applications with react, zod, and ink.
\item \href{https://github.com/sidwebworks/zod-xlsx}{\texttt{ {\ttfamily zod-\/xlsx}}}\+: A xlsx based resource validator using Zod schemas.
\item \href{https://github.com/lostfictions/znv}{\texttt{ {\ttfamily znv}}}\+: Type-\/safe environment parsing and validation for Node.\+js with Zod schemas.
\item \href{https://github.com/alexmarqs/zod-config}{\texttt{ {\ttfamily zod-\/config}}}\+: Load configurations across multiple sources with flexible adapters, ensuring type safety with Zod.
\item \href{https://github.com/r17x/js/tree/main/packages/unplugin-environment\#readme}{\texttt{ {\ttfamily unplugin-\/environment}}}\+: A plugin for loading enviroment variables safely with schema validation, simple with virtual module, type-\/safe with intellisense, and better DX ðŸ”¥ ðŸš€ ðŸ‘·. Powered by Zod.
\item \href{https://codeberg.org/reesericci/zod-struct}{\texttt{ {\ttfamily zod-\/struct}}}\+: Create runtime-\/checked structs with Zod.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36472}{}\doxysubsubsubsubsection{\texorpdfstring{Utilities for Zod}{Utilities for Zod}}\label{README.md_autotoc_md36472}

\begin{DoxyItemize}
\item \href{https://github.com/JacobWeisenburger/zod_utilz}{\texttt{ {\ttfamily zod\+\_\+utilz}}}\+: Framework agnostic utilities for Zod.
\item \href{https://github.com/marilari88/zod-playground}{\texttt{ {\ttfamily zod-\/playground}}}\+: A tool for learning and testing Zod schema validation functionalities. \href{https://zod-playground.vercel.app/}{\texttt{ Link}}.
\item \href{https://github.com/nereumelo/zod-sandbox}{\texttt{ {\ttfamily zod-\/sandbox}}}\+: Controlled environment for testing zod schemas. \href{https://zod-sandbox.vercel.app/}{\texttt{ Live demo}}.
\item \href{https://github.com/schalkventer/zod-dev}{\texttt{ {\ttfamily zod-\/dev}}}\+: Conditionally disables Zod runtime parsing in production.
\item \href{https://github.com/duplojs/duplojs-zod-accelerator}{\texttt{ {\ttfamily zod-\/accelerator}}}\+: Accelerates Zod\textquotesingle{}s throughput up to \texorpdfstring{$\sim$}{\string~}100x.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36473}{}\doxysubsubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md36473}
\hypertarget{README.md_autotoc_md36474}{}\doxysubsubsubsection{\texorpdfstring{Requirements}{Requirements}}\label{README.md_autotoc_md36474}

\begin{DoxyItemize}
\item Type\+Script 4.\+5+!
\item You must enable {\ttfamily strict} mode in your {\ttfamily tsconfig.\+json}. This is a best practice for all Type\+Script projects.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ tsconfig.json}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ //\ ...}
\DoxyCodeLine{\ \ "{}compilerOptions"{}:\ \{}
\DoxyCodeLine{\ \ \ \ //\ ...}
\DoxyCodeLine{\ \ \ \ "{}strict"{}:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{README.md_autotoc_md36475}{}\doxysubsubsubsection{\texorpdfstring{From {\ttfamily npm}}{From {\ttfamily npm}}}\label{README.md_autotoc_md36475}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ zod\ \ \ \ \ \ \ \#\ npm}
\DoxyCodeLine{deno\ add\ npm:zod\ \ \ \ \ \ \#\ deno}
\DoxyCodeLine{yarn\ add\ zod\ \ \ \ \ \ \ \ \ \ \#\ yarn}
\DoxyCodeLine{bun\ add\ zod\ \ \ \ \ \ \ \ \ \ \ \#\ bun}
\DoxyCodeLine{pnpm\ add\ zod\ \ \ \ \ \ \ \ \ \ \#\ pnpm}

\end{DoxyCode}


Zod also publishes a canary version on every commit. To install the canary\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ zod@canary\ \ \ \ \ \ \ \#\ npm}
\DoxyCodeLine{deno\ add\ npm:zod@canary\ \ \ \ \ \ \#\ deno}
\DoxyCodeLine{yarn\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \#\ yarn}
\DoxyCodeLine{bun\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \ \#\ bun}
\DoxyCodeLine{pnpm\ add\ zod@canary\ \ \ \ \ \ \ \ \ \ \#\ pnpm}

\end{DoxyCode}


\begin{quote}
The rest of this README assumes you are using npm and importing directly from the {\ttfamily "{}zod"{}} package. \end{quote}
\hypertarget{README.md_autotoc_md36476}{}\doxysubsubsection{\texorpdfstring{Basic usage}{Basic usage}}\label{README.md_autotoc_md36476}
Creating a simple string schema


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ creating\ a\ schema\ for\ strings}
\DoxyCodeLine{const\ mySchema\ =\ z.string();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ parsing}
\DoxyCodeLine{mySchema.parse("{}tuna"{});\ //\ =>\ "{}tuna"{}}
\DoxyCodeLine{mySchema.parse(12);\ //\ =>\ throws\ ZodError}
\DoxyCodeLine{}
\DoxyCodeLine{//\ "{}safe"{}\ parsing\ (doesn't\ throw\ error\ if\ validation\ fails)}
\DoxyCodeLine{mySchema.safeParse("{}tuna"{});\ //\ =>\ \{\ success:\ true;\ data:\ "{}tuna"{}\ \}}
\DoxyCodeLine{mySchema.safeParse(12);\ //\ =>\ \{\ success:\ false;\ error:\ ZodError\ \}}

\end{DoxyCode}


Creating an object schema


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ User\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{User.parse(\{\ username:\ "{}Ludwig"{}\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ extract\ the\ inferred\ type}
\DoxyCodeLine{type\ User\ =\ z.infer<typeof\ User>;}
\DoxyCodeLine{//\ \{\ username:\ string\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36477}{}\doxysubsubsection{\texorpdfstring{Primitives}{Primitives}}\label{README.md_autotoc_md36477}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ z\ \}\ from\ "{}zod"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ primitive\ values}
\DoxyCodeLine{z.string();}
\DoxyCodeLine{z.number();}
\DoxyCodeLine{z.bigint();}
\DoxyCodeLine{z.boolean();}
\DoxyCodeLine{z.date();}
\DoxyCodeLine{z.symbol();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ empty\ types}
\DoxyCodeLine{z.undefined();}
\DoxyCodeLine{z.null();}
\DoxyCodeLine{z.void();\ //\ accepts\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ catch-\/all\ types}
\DoxyCodeLine{//\ allows\ any\ value}
\DoxyCodeLine{z.any();}
\DoxyCodeLine{z.unknown();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ never\ type}
\DoxyCodeLine{//\ allows\ no\ values}
\DoxyCodeLine{z.never();}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36478}{}\doxysubsubsection{\texorpdfstring{Coercion for primitives}{Coercion for primitives}}\label{README.md_autotoc_md36478}
Zod now provides a more convenient way to coerce primitive values.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.coerce.string();}
\DoxyCodeLine{schema.parse("{}tuna"{});\ //\ =>\ "{}tuna"{}}
\DoxyCodeLine{schema.parse(12);\ //\ =>\ "{}12"{}}

\end{DoxyCode}


During the parsing step, the input is passed through the {\ttfamily String()} function, which is a Java\+Script built-\/in for coercing data into strings.


\begin{DoxyCode}{0}
\DoxyCodeLine{schema.parse(12);\ //\ =>\ "{}12"{}}
\DoxyCodeLine{schema.parse(true);\ //\ =>\ "{}true"{}}
\DoxyCodeLine{schema.parse(undefined);\ //\ =>\ "{}undefined"{}}
\DoxyCodeLine{schema.parse(null);\ //\ =>\ "{}null"{}}

\end{DoxyCode}


The returned schema is a normal {\ttfamily Zod\+String} instance so you can use all string methods.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.coerce.string().email().min(5);}

\end{DoxyCode}


{\bfseries{How coercion works}}

All primitive types support coercion. Zod coerces all inputs using the built-\/in constructors\+: {\ttfamily String(input)}, {\ttfamily Number(input)}, {\ttfamily new Date(input)}, etc.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.coerce.string();\ //\ String(input)}
\DoxyCodeLine{z.coerce.number();\ //\ Number(input)}
\DoxyCodeLine{z.coerce.boolean();\ //\ Boolean(input)}
\DoxyCodeLine{z.coerce.bigint();\ //\ BigInt(input)}
\DoxyCodeLine{z.coerce.date();\ //\ new\ Date(input)}

\end{DoxyCode}


{\bfseries{Note}} â€”Â \+Boolean coercion with {\ttfamily z.\+coerce.\+boolean()} may not work how you expect. Any \href{https://developer.mozilla.org/en-US/docs/Glossary/Truthy}{\texttt{ truthy}} value is coerced to {\ttfamily true}, and any \href{https://developer.mozilla.org/en-US/docs/Glossary/Falsy}{\texttt{ falsy}} value is coerced to {\ttfamily false}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.coerce.boolean();\ //\ Boolean(input)}
\DoxyCodeLine{}
\DoxyCodeLine{schema.parse("{}tuna"{});\ //\ =>\ true}
\DoxyCodeLine{schema.parse("{}true"{});\ //\ =>\ true}
\DoxyCodeLine{schema.parse("{}false"{});\ //\ =>\ true}
\DoxyCodeLine{schema.parse(1);\ //\ =>\ true}
\DoxyCodeLine{schema.parse([]);\ //\ =>\ true}
\DoxyCodeLine{}
\DoxyCodeLine{schema.parse(0);\ //\ =>\ false}
\DoxyCodeLine{schema.parse("{}"{});\ //\ =>\ false}
\DoxyCodeLine{schema.parse(undefined);\ //\ =>\ false}
\DoxyCodeLine{schema.parse(null);\ //\ =>\ false}

\end{DoxyCode}


For more control over coercion logic, consider using \`{}z.preprocess\`{} or \`{}z.pipe()\`{}.\hypertarget{README.md_autotoc_md36479}{}\doxysubsubsection{\texorpdfstring{Literals}{Literals}}\label{README.md_autotoc_md36479}
Literal schemas represent a \href{https://www.typescriptlang.org/docs/handbook/2/everyday-types.html\#literal-types}{\texttt{ literal type}}, like {\ttfamily "{}hello world"{}} or {\ttfamily 5}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ tuna\ =\ z.literal("{}tuna"{});}
\DoxyCodeLine{const\ twelve\ =\ z.literal(12);}
\DoxyCodeLine{const\ twobig\ =\ z.literal(2n);\ //\ bigint\ literal}
\DoxyCodeLine{const\ tru\ =\ z.literal(true);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ terrificSymbol\ =\ Symbol("{}terrific"{});}
\DoxyCodeLine{const\ terrific\ =\ z.literal(terrificSymbol);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ retrieve\ literal\ value}
\DoxyCodeLine{tuna.value;\ //\ "{}tuna"{}}

\end{DoxyCode}


\begin{quote}
Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue. \end{quote}
\hypertarget{README.md_autotoc_md36480}{}\doxysubsubsection{\texorpdfstring{Strings}{Strings}}\label{README.md_autotoc_md36480}
Zod includes a handful of string-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ validations}
\DoxyCodeLine{z.string().max(5);}
\DoxyCodeLine{z.string().min(5);}
\DoxyCodeLine{z.string().length(5);}
\DoxyCodeLine{z.string().email();}
\DoxyCodeLine{z.string().url();}
\DoxyCodeLine{z.string().emoji();}
\DoxyCodeLine{z.string().uuid();}
\DoxyCodeLine{z.string().nanoid();}
\DoxyCodeLine{z.string().cuid();}
\DoxyCodeLine{z.string().cuid2();}
\DoxyCodeLine{z.string().ulid();}
\DoxyCodeLine{z.string().regex(regex);}
\DoxyCodeLine{z.string().includes(string);}
\DoxyCodeLine{z.string().startsWith(string);}
\DoxyCodeLine{z.string().endsWith(string);}
\DoxyCodeLine{z.string().datetime();\ //\ ISO\ 8601;\ by\ default\ only\ \`{}Z`\ timezone\ allowed}
\DoxyCodeLine{z.string().ip();\ //\ defaults\ to\ allow\ both\ IPv4\ and\ IPv6}
\DoxyCodeLine{z.string().cidr();\ //\ defaults\ to\ allow\ both\ IPv4\ and\ IPv6}
\DoxyCodeLine{}
\DoxyCodeLine{//\ transforms}
\DoxyCodeLine{z.string().trim();\ //\ trim\ whitespace}
\DoxyCodeLine{z.string().toLowerCase();\ //\ toLowerCase}
\DoxyCodeLine{z.string().toUpperCase();\ //\ toUpperCase}
\DoxyCodeLine{}
\DoxyCodeLine{//\ added\ in\ Zod\ 3.23}
\DoxyCodeLine{z.string().date();\ //\ ISO\ date\ format\ (YYYY-\/MM-\/DD)}
\DoxyCodeLine{z.string().time();\ //\ ISO\ time\ format\ (HH:mm:ss[.SSSSSS])}
\DoxyCodeLine{z.string().duration();\ //\ ISO\ 8601\ duration}
\DoxyCodeLine{z.string().base64();}

\end{DoxyCode}


\begin{quote}
Check out \href{https://github.com/validatorjs/validator.js}{\texttt{ validator.\+js}} for a bunch of other useful string validation functions that can be used in conjunction with Refinements. \end{quote}


You can customize some common error messages when creating a string schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ name\ =\ z.string(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Name\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}Name\ must\ be\ a\ string"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


When using validation methods, you can pass in an additional argument to provide a custom error message.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().min(5,\ \{\ message:\ "{}Must\ be\ 5\ or\ more\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().max(5,\ \{\ message:\ "{}Must\ be\ 5\ or\ fewer\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().length(5,\ \{\ message:\ "{}Must\ be\ exactly\ 5\ characters\ long"{}\ \});}
\DoxyCodeLine{z.string().email(\{\ message:\ "{}Invalid\ email\ address"{}\ \});}
\DoxyCodeLine{z.string().url(\{\ message:\ "{}Invalid\ url"{}\ \});}
\DoxyCodeLine{z.string().emoji(\{\ message:\ "{}Contains\ non-\/emoji\ characters"{}\ \});}
\DoxyCodeLine{z.string().uuid(\{\ message:\ "{}Invalid\ UUID"{}\ \});}
\DoxyCodeLine{z.string().includes("{}tuna"{},\ \{\ message:\ "{}Must\ include\ tuna"{}\ \});}
\DoxyCodeLine{z.string().startsWith("{}https://"{},\ \{\ message:\ "{}Must\ provide\ secure\ URL"{}\ \});}
\DoxyCodeLine{z.string().endsWith("{}.com"{},\ \{\ message:\ "{}Only\ .com\ domains\ allowed"{}\ \});}
\DoxyCodeLine{z.string().datetime(\{\ message:\ "{}Invalid\ datetime\ string!\ Must\ be\ UTC."{}\ \});}
\DoxyCodeLine{z.string().date(\{\ message:\ "{}Invalid\ date\ string!"{}\ \});}
\DoxyCodeLine{z.string().time(\{\ message:\ "{}Invalid\ time\ string!"{}\ \});}
\DoxyCodeLine{z.string().ip(\{\ message:\ "{}Invalid\ IP\ address"{}\ \});}
\DoxyCodeLine{z.string().cidr(\{\ message:\ "{}Invalid\ CIDR"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36481}{}\doxysubsubsubsection{\texorpdfstring{Datetimes}{Datetimes}}\label{README.md_autotoc_md36481}
As you may have noticed, Zod string includes a few date/time related validations. These validations are regular expression based, so they are not as strict as a full date/time library. However, they are very convenient for validating user input.

The {\ttfamily z.\+string().datetime()} method enforces ISO 8601; default is no timezone offsets and arbitrary sub-\/second decimal precision.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime();}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123456Z"{});\ //\ pass\ (arbitrary\ precision)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00+02:00"{});\ //\ fail\ (no\ offsets\ allowed)}

\end{DoxyCode}


Timezone offsets can be allowed by setting the {\ttfamily offset} option to {\ttfamily true}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime(\{\ offset:\ true\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00+02:00"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+02:00"{});\ //\ pass\ (millis\ optional)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+0200"{});\ //\ pass\ (millis\ optional)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123+02"{});\ //\ pass\ (only\ offset\ hours)}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ pass\ (Z\ still\ supported)}

\end{DoxyCode}


Allow unqualified (timezone-\/less) datetimes with the {\ttfamily local} flag.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.string().datetime(\{\ local:\ true\ \});}
\DoxyCodeLine{schema.parse("{}2020-\/01-\/01T00:00:00"{});\ //\ pass}

\end{DoxyCode}


You can additionally constrain the allowable {\ttfamily precision}. By default, arbitrary sub-\/second precision is supported (but optional).


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datetime\ =\ z.string().datetime(\{\ precision:\ 3\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123Z"{});\ //\ pass}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00Z"{});\ //\ fail}
\DoxyCodeLine{datetime.parse("{}2020-\/01-\/01T00:00:00.123456Z"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36482}{}\doxysubsubsubsection{\texorpdfstring{Dates}{Dates}}\label{README.md_autotoc_md36482}
\begin{quote}
Added in Zod 3.\+23 \end{quote}


The {\ttfamily z.\+string().date()} method validates strings in the format {\ttfamily YYYY-\/\+MM-\/\+DD}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ date\ =\ z.string().date();}
\DoxyCodeLine{}
\DoxyCodeLine{date.parse("{}2020-\/01-\/01"{});\ //\ pass}
\DoxyCodeLine{date.parse("{}2020-\/1-\/1"{});\ //\ fail}
\DoxyCodeLine{date.parse("{}2020-\/01-\/32"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36483}{}\doxysubsubsubsection{\texorpdfstring{Times}{Times}}\label{README.md_autotoc_md36483}
\begin{quote}
Added in Zod 3.\+23 \end{quote}


The {\ttfamily z.\+string().time()} method validates strings in the format {\ttfamily HH\+:\+MM\+:SS\mbox{[}.s+\mbox{]}}. The second can include arbitrary decimal precision. It does not allow timezone offsets of any kind.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ time\ =\ z.string().time();}
\DoxyCodeLine{}
\DoxyCodeLine{time.parse("{}00:00:00"{});\ //\ pass}
\DoxyCodeLine{time.parse("{}09:52:31"{});\ //\ pass}
\DoxyCodeLine{time.parse("{}23:59:59.9999999"{});\ //\ pass\ (arbitrary\ precision)}
\DoxyCodeLine{}
\DoxyCodeLine{time.parse("{}00:00:00.123Z"{});\ //\ fail\ (no\ \`{}Z`\ allowed)}
\DoxyCodeLine{time.parse("{}00:00:00.123+02:00"{});\ //\ fail\ (no\ offsets\ allowed)}

\end{DoxyCode}


You can set the {\ttfamily precision} option to constrain the allowable decimal precision.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ time\ =\ z.string().time(\{\ precision:\ 3\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{time.parse("{}00:00:00.123"{});\ //\ pass}
\DoxyCodeLine{time.parse("{}00:00:00.123456"{});\ //\ fail}
\DoxyCodeLine{time.parse("{}00:00:00"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36484}{}\doxysubsubsubsection{\texorpdfstring{IP addresses}{IP addresses}}\label{README.md_autotoc_md36484}
By default {\ttfamily .ip()} allows both IPv4 and IPv6.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ip\ =\ z.string().ip();}
\DoxyCodeLine{}
\DoxyCodeLine{ip.parse("{}192.168.1.1"{});\ //\ pass}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"{});\ //\ pass}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1"{});\ //\ pass}
\DoxyCodeLine{}
\DoxyCodeLine{ip.parse("{}256.1.1.1"{});\ //\ fail}
\DoxyCodeLine{ip.parse("{}84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003"{});\ //\ fail}

\end{DoxyCode}


You can additionally set the IP {\ttfamily version}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ipv4\ =\ z.string().ip(\{\ version:\ "{}v4"{}\ \});}
\DoxyCodeLine{ipv4.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"{});\ //\ fail}
\DoxyCodeLine{}
\DoxyCodeLine{const\ ipv6\ =\ z.string().ip(\{\ version:\ "{}v6"{}\ \});}
\DoxyCodeLine{ipv6.parse("{}192.168.1.1"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36485}{}\doxysubsubsubsection{\texorpdfstring{IP ranges (CIDR)}{IP ranges (CIDR)}}\label{README.md_autotoc_md36485}
Validate IP address ranges specified with \href{https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing}{\texttt{ CIDR notation}}. By default, {\ttfamily .cidr()} allows both IPv4 and IPv6.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ cidr\ =\ z.string().cidr();}
\DoxyCodeLine{cidr.parse("{}192.168.0.0/24"{});\ //\ pass}
\DoxyCodeLine{cidr.parse("{}2001:db8::/32"{});\ //\ pass}

\end{DoxyCode}


You can specify a version with the {\ttfamily version} parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ ipv4Cidr\ =\ z.string().cidr(\{\ version:\ "{}v4"{}\ \});}
\DoxyCodeLine{ipv4Cidr.parse("{}84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"{});\ //\ fail}
\DoxyCodeLine{}
\DoxyCodeLine{const\ ipv6Cidr\ =\ z.string().cidr(\{\ version:\ "{}v6"{}\ \});}
\DoxyCodeLine{ipv6Cidr.parse("{}192.168.1.1"{});\ //\ fail}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36486}{}\doxysubsubsection{\texorpdfstring{Numbers}{Numbers}}\label{README.md_autotoc_md36486}
You can customize certain error messages when creating a number schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ age\ =\ z.number(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Age\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}Age\ must\ be\ a\ number"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


Zod includes a handful of number-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.number().gt(5);}
\DoxyCodeLine{z.number().gte(5);\ //\ alias\ .min(5)}
\DoxyCodeLine{z.number().lt(5);}
\DoxyCodeLine{z.number().lte(5);\ //\ alias\ .max(5)}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().int();\ //\ value\ must\ be\ an\ integer}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().positive();\ //\ \ \ \ \ >\ 0}
\DoxyCodeLine{z.number().nonnegative();\ //\ \ >=\ 0}
\DoxyCodeLine{z.number().negative();\ //\ \ \ \ \ <\ 0}
\DoxyCodeLine{z.number().nonpositive();\ //\ \ <=\ 0}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().multipleOf(5);\ //\ Evenly\ divisible\ by\ 5.\ Alias\ .step(5)}
\DoxyCodeLine{}
\DoxyCodeLine{z.number().finite();\ //\ value\ must\ be\ finite,\ not\ Infinity\ or\ -\/Infinity}
\DoxyCodeLine{z.number().safe();\ //\ value\ must\ be\ between\ Number.MIN\_SAFE\_INTEGER\ and\ Number.MAX\_SAFE\_INTEGER}

\end{DoxyCode}


Optionally, you can pass in a second argument to provide a custom error message.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.number().lte(5,\ \{\ message:\ "{}thisðŸ‘isðŸ‘tooðŸ‘big"{}\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36487}{}\doxysubsubsection{\texorpdfstring{Big\+Ints}{Big\+Ints}}\label{README.md_autotoc_md36487}
Zod includes a handful of bigint-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.bigint().gt(5n);}
\DoxyCodeLine{z.bigint().gte(5n);\ //\ alias\ \`{}.min(5n)`}
\DoxyCodeLine{z.bigint().lt(5n);}
\DoxyCodeLine{z.bigint().lte(5n);\ //\ alias\ \`{}.max(5n)`}
\DoxyCodeLine{}
\DoxyCodeLine{z.bigint().positive();\ //\ >\ 0n}
\DoxyCodeLine{z.bigint().nonnegative();\ //\ >=\ 0n}
\DoxyCodeLine{z.bigint().negative();\ //\ <\ 0n}
\DoxyCodeLine{z.bigint().nonpositive();\ //\ <=\ 0n}
\DoxyCodeLine{}
\DoxyCodeLine{z.bigint().multipleOf(5n);\ //\ Evenly\ divisible\ by\ 5n.}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36488}{}\doxysubsubsection{\texorpdfstring{Na\+Ns}{Na\+Ns}}\label{README.md_autotoc_md36488}
You can customize certain error messages when creating a nan schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isNaN\ =\ z.nan(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}isNaN\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}isNaN\ must\ be\ 'not\ a\ number'"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36489}{}\doxysubsubsection{\texorpdfstring{Booleans}{Booleans}}\label{README.md_autotoc_md36489}
You can customize certain error messages when creating a boolean schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isActive\ =\ z.boolean(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}isActive\ is\ required"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}isActive\ must\ be\ a\ boolean"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36490}{}\doxysubsubsection{\texorpdfstring{Dates}{Dates}}\label{README.md_autotoc_md36490}
Use z.\+date() to validate {\ttfamily Date} instances.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.date().safeParse(new\ Date());\ //\ success:\ true}
\DoxyCodeLine{z.date().safeParse("{}2022-\/01-\/12T00:00:00.000Z"{});\ //\ success:\ false}

\end{DoxyCode}


You can customize certain error messages when creating a date schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myDateSchema\ =\ z.date(\{}
\DoxyCodeLine{\ \ required\_error:\ "{}Please\ select\ a\ date\ and\ time"{},}
\DoxyCodeLine{\ \ invalid\_type\_error:\ "{}That's\ not\ a\ date!"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


Zod provides a handful of date-\/specific validations.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.date().min(new\ Date("{}1900-\/01-\/01"{}),\ \{\ message:\ "{}Too\ old"{}\ \});}
\DoxyCodeLine{z.date().max(new\ Date(),\ \{\ message:\ "{}Too\ young!"{}\ \});}

\end{DoxyCode}


{\bfseries{Coercion to Date}}

Since \href{https://github.com/colinhacks/zod/releases/tag/v3.20}{\texttt{ zod 3.\+20}}, use \`{}z.coerce.date()\`{} to pass the input through {\ttfamily new Date(input)}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ dateSchema\ =\ z.coerce.date();}
\DoxyCodeLine{type\ DateSchema\ =\ z.infer<typeof\ dateSchema>;}
\DoxyCodeLine{//\ type\ DateSchema\ =\ Date}
\DoxyCodeLine{}
\DoxyCodeLine{/*\ valid\ dates\ */}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/01-\/10T00:00:00.000Z"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/01-\/10"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}1/10/23"{}).success);\ //\ true}
\DoxyCodeLine{console.log(dateSchema.safeParse(new\ Date("{}1/10/23"{})).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{/*\ invalid\ dates\ */}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}2023-\/13-\/10"{}).success);\ //\ false}
\DoxyCodeLine{console.log(dateSchema.safeParse("{}0000-\/00-\/00"{}).success);\ //\ false}

\end{DoxyCode}


For older zod versions, use \`{}z.preprocess\`{} like \href{https://github.com/colinhacks/zod/discussions/879\#discussioncomment-2036276}{\texttt{ described in this thread}}.\hypertarget{README.md_autotoc_md36491}{}\doxysubsubsection{\texorpdfstring{Zod enums}{Zod enums}}\label{README.md_autotoc_md36491}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}]);}
\DoxyCodeLine{type\ FishEnum\ =\ z.infer<typeof\ FishEnum>;}
\DoxyCodeLine{//\ 'Salmon'\ |\ 'Tuna'\ |\ 'Trout'}

\end{DoxyCode}


{\ttfamily z.\+enum} is a Zod-\/native way to declare a schema with a fixed set of allowable {\itshape string} values. Pass the array of values directly into {\ttfamily z.\+enum()}. Alternatively, use {\ttfamily as const} to define your enum values as a tuple of strings. See the \href{https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html\#const-assertions}{\texttt{ const assertion docs}} for details.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ VALUES\ =\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}]\ as\ const;}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(VALUES);}

\end{DoxyCode}


This is not allowed, since Zod isn\textquotesingle{}t able to infer the exact values of each element.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ fish\ =\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}];}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(fish);}

\end{DoxyCode}


{\bfseries{{\ttfamily .enum}}}

To get autocompletion with a Zod enum, use the {\ttfamily .enum} property of your schema\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FishEnum.enum.Salmon;\ //\ =>\ autocompletes}
\DoxyCodeLine{}
\DoxyCodeLine{FishEnum.enum;}
\DoxyCodeLine{/*}
\DoxyCodeLine{=>\ \{}
\DoxyCodeLine{\ \ Salmon:\ "{}Salmon"{},}
\DoxyCodeLine{\ \ Tuna:\ "{}Tuna"{},}
\DoxyCodeLine{\ \ Trout:\ "{}Trout"{},}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}


You can also retrieve the list of options as a tuple with the {\ttfamily .options} property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FishEnum.options;\ //\ ["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}];}

\end{DoxyCode}


{\bfseries{{\ttfamily .exclude/.extract()}}}

You can create subsets of a Zod enum with the {\ttfamily .exclude} and {\ttfamily .extract} methods.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ FishEnum\ =\ z.enum(["{}Salmon"{},\ "{}Tuna"{},\ "{}Trout"{}]);}
\DoxyCodeLine{const\ SalmonAndTrout\ =\ FishEnum.extract(["{}Salmon"{},\ "{}Trout"{}]);}
\DoxyCodeLine{const\ TunaOnly\ =\ FishEnum.exclude(["{}Salmon"{},\ "{}Trout"{}]);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36492}{}\doxysubsubsection{\texorpdfstring{Native enums}{Native enums}}\label{README.md_autotoc_md36492}
Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-\/party library (or you don\textquotesingle{}t want to rewrite your existing enums) you can use {\ttfamily z.\+native\+Enum()}.

{\bfseries{Numeric enums}}


\begin{DoxyCode}{0}
\DoxyCodeLine{enum\ Fruits\ \{}
\DoxyCodeLine{\ \ Apple,}
\DoxyCodeLine{\ \ Banana,}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ Fruits}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse(Fruits.Apple);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(Fruits.Banana);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(0);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(1);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(3);\ //\ fails}

\end{DoxyCode}


{\bfseries{String enums}}


\begin{DoxyCode}{0}
\DoxyCodeLine{enum\ Fruits\ \{}
\DoxyCodeLine{\ \ Apple\ =\ "{}apple"{},}
\DoxyCodeLine{\ \ Banana\ =\ "{}banana"{},}
\DoxyCodeLine{\ \ Cantaloupe,\ //\ you\ can\ mix\ numerical\ and\ string\ enums}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ Fruits}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse(Fruits.Apple);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(Fruits.Cantaloupe);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}apple"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}banana"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(0);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}Cantaloupe"{});\ //\ fails}

\end{DoxyCode}


{\bfseries{Const enums}}

The {\ttfamily .native\+Enum()} function works for {\ttfamily as const} objects as well. âš ï¸ {\ttfamily as const} requires Type\+Script 3.\+4+!


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Fruits\ =\ \{}
\DoxyCodeLine{\ \ Apple:\ "{}apple"{},}
\DoxyCodeLine{\ \ Banana:\ "{}banana"{},}
\DoxyCodeLine{\ \ Cantaloupe:\ 3,}
\DoxyCodeLine{\}\ as\ const;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ FruitEnum\ =\ z.nativeEnum(Fruits);}
\DoxyCodeLine{type\ FruitEnum\ =\ z.infer<typeof\ FruitEnum>;\ //\ "{}apple"{}\ |\ "{}banana"{}\ |\ 3}
\DoxyCodeLine{}
\DoxyCodeLine{FruitEnum.parse("{}apple"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}banana"{});\ //\ passes}
\DoxyCodeLine{FruitEnum.parse(3);\ //\ passes}
\DoxyCodeLine{FruitEnum.parse("{}Cantaloupe"{});\ //\ fails}

\end{DoxyCode}


You can access the underlying object with the {\ttfamily .enum} property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{FruitEnum.enum.Apple;\ //\ "{}apple"{}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36493}{}\doxysubsubsection{\texorpdfstring{Optionals}{Optionals}}\label{README.md_autotoc_md36493}
You can make any schema optional with {\ttfamily z.\+optional()}. This wraps the schema in a {\ttfamily Zod\+Optional} instance and returns the result.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.optional(z.string());}
\DoxyCodeLine{}
\DoxyCodeLine{schema.parse(undefined);\ //\ =>\ returns\ undefined}
\DoxyCodeLine{type\ A\ =\ z.infer<typeof\ schema>;\ //\ string\ |\ undefined}

\end{DoxyCode}


For convenience, you can also call the {\ttfamily .optional()} method on an existing schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string().optional(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{type\ C\ =\ z.infer<typeof\ user>;\ //\ \{\ username?:\ string\ |\ undefined\ \};}

\end{DoxyCode}


You can extract the wrapped schema from a {\ttfamily Zod\+Optional} instance with {\ttfamily .unwrap()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{const\ optionalString\ =\ stringSchema.optional();}
\DoxyCodeLine{optionalString.unwrap()\ ===\ stringSchema;\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36494}{}\doxysubsubsection{\texorpdfstring{Nullables}{Nullables}}\label{README.md_autotoc_md36494}
Similarly, you can create nullable types with {\ttfamily z.\+nullable()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullableString\ =\ z.nullable(z.string());}
\DoxyCodeLine{nullableString.parse("{}asdf"{});\ //\ =>\ "{}asdf"{}}
\DoxyCodeLine{nullableString.parse(null);\ //\ =>\ null}

\end{DoxyCode}


Or use the {\ttfamily .nullable()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ E\ =\ z.string().nullable();\ //\ equivalent\ to\ nullableString}
\DoxyCodeLine{type\ E\ =\ z.infer<typeof\ E>;\ //\ string\ |\ null}

\end{DoxyCode}


Extract the inner schema with {\ttfamily .unwrap()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{const\ nullableString\ =\ stringSchema.nullable();}
\DoxyCodeLine{nullableString.unwrap()\ ===\ stringSchema;\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36495}{}\doxysubsubsection{\texorpdfstring{Objects}{Objects}}\label{README.md_autotoc_md36495}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ all\ properties\ are\ required\ by\ default}
\DoxyCodeLine{const\ Dog\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\ \ age:\ z.number(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ extract\ the\ inferred\ type\ like\ this}
\DoxyCodeLine{type\ Dog\ =\ z.infer<typeof\ Dog>;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to:}
\DoxyCodeLine{type\ Dog\ =\ \{}
\DoxyCodeLine{\ \ name:\ string;}
\DoxyCodeLine{\ \ age:\ number;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36496}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .shape}}{{\ttfamily .shape}}}\label{README.md_autotoc_md36496}
Use {\ttfamily .shape} to access the schemas for a particular key.


\begin{DoxyCode}{0}
\DoxyCodeLine{Dog.shape.name;\ //\ =>\ string\ schema}
\DoxyCodeLine{Dog.shape.age;\ //\ =>\ number\ schema}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36497}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .keyof}}{{\ttfamily .keyof}}}\label{README.md_autotoc_md36497}
Use {\ttfamily .keyof} to create a {\ttfamily Zod\+Enum} schema from the keys of an object schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ keySchema\ =\ Dog.keyof();}
\DoxyCodeLine{keySchema;\ //\ ZodEnum<["{}name"{},\ "{}age"{}]>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36498}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .extend}}{{\ttfamily .extend}}}\label{README.md_autotoc_md36498}
You can add additional fields to an object schema with the {\ttfamily .extend} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ DogWithBreed\ =\ Dog.extend(\{}
\DoxyCodeLine{\ \ breed:\ z.string(),}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can use {\ttfamily .extend} to overwrite fields! Be careful with this power!\hypertarget{README.md_autotoc_md36499}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .merge}}{{\ttfamily .merge}}}\label{README.md_autotoc_md36499}
Equivalent to {\ttfamily A.\+extend(B.\+shape)}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ BaseTeacher\ =\ z.object(\{\ students:\ z.array(z.string())\ \});}
\DoxyCodeLine{const\ HasID\ =\ z.object(\{\ id:\ z.string()\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ Teacher\ =\ BaseTeacher.merge(HasID);}
\DoxyCodeLine{type\ Teacher\ =\ z.infer<typeof\ Teacher>;\ //\ =>\ \{\ students:\ string[],\ id:\ string\ \}}

\end{DoxyCode}


\begin{quote}
If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "{}unknown\+Keys"{} policy (strip/strict/passthrough) and the catchall schema of B. \end{quote}
\hypertarget{README.md_autotoc_md36500}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .pick/.omit}}{{\ttfamily .pick/.omit}}}\label{README.md_autotoc_md36500}
Inspired by Type\+Script\textquotesingle{}s built-\/in {\ttfamily Pick} and {\ttfamily Omit} utility types, all Zod object schemas have {\ttfamily .pick} and {\ttfamily .omit} methods that return a modified version. Consider this Recipe schema\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Recipe\ =\ z.object(\{}
\DoxyCodeLine{\ \ id:\ z.string(),}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\ \ ingredients:\ z.array(z.string()),}
\DoxyCodeLine{\});}

\end{DoxyCode}


To only keep certain keys, use {\ttfamily .pick} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ JustTheName\ =\ Recipe.pick(\{\ name:\ true\ \});}
\DoxyCodeLine{type\ JustTheName\ =\ z.infer<typeof\ JustTheName>;}
\DoxyCodeLine{//\ =>\ \{\ name:\ string\ \}}

\end{DoxyCode}


To remove certain keys, use {\ttfamily .omit} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ NoIDRecipe\ =\ Recipe.omit(\{\ id:\ true\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ NoIDRecipe\ =\ z.infer<typeof\ NoIDRecipe>;}
\DoxyCodeLine{//\ =>\ \{\ name:\ string,\ ingredients:\ string[]\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36501}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .partial}}{{\ttfamily .partial}}}\label{README.md_autotoc_md36501}
Inspired by the built-\/in Type\+Script utility type \href{https://www.typescriptlang.org/docs/handbook/utility-types.html\#partialtype}{\texttt{ Partial}}, the {\ttfamily .partial} method makes all properties optional.

Starting from this object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ email:\ z.string(),}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ \{\ email:\ string;\ username:\ string\ \}}

\end{DoxyCode}


We can create a partial version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ partialUser\ =\ user.partial();}
\DoxyCodeLine{//\ \{\ email?:\ string\ |\ undefined;\ username?:\ string\ |\ undefined\ \}}

\end{DoxyCode}


You can also specify which properties to make optional\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalEmail\ =\ user.partial(\{}
\DoxyCodeLine{\ \ email:\ true,}
\DoxyCodeLine{\});}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ email?:\ string\ |\ undefined;}
\DoxyCodeLine{\ \ username:\ string}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36502}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .deep\+Partial}}{{\ttfamily .deep\+Partial}}}\label{README.md_autotoc_md36502}
The {\ttfamily .partial} method is shallow â€” it only applies one level deep. There is also a "{}deep"{} version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z.object(\{}
\DoxyCodeLine{\ \ username:\ z.string(),}
\DoxyCodeLine{\ \ location:\ z.object(\{}
\DoxyCodeLine{\ \ \ \ latitude:\ z.number(),}
\DoxyCodeLine{\ \ \ \ longitude:\ z.number(),}
\DoxyCodeLine{\ \ \}),}
\DoxyCodeLine{\ \ strings:\ z.array(z.object(\{\ value:\ z.string()\ \})),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ deepPartialUser\ =\ user.deepPartial();}
\DoxyCodeLine{}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ username?:\ string\ |\ undefined,}
\DoxyCodeLine{\ \ location?:\ \{}
\DoxyCodeLine{\ \ \ \ latitude?:\ number\ |\ undefined;}
\DoxyCodeLine{\ \ \ \ longitude?:\ number\ |\ undefined;}
\DoxyCodeLine{\ \ \}\ |\ undefined,}
\DoxyCodeLine{\ \ strings?:\ \{\ value?:\ string\}[]}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}


\begin{quote}
Important limitation\+: deep partials only work as expected in hierarchies of objects, arrays, and tuples. \end{quote}
\hypertarget{README.md_autotoc_md36503}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .required}}{{\ttfamily .required}}}\label{README.md_autotoc_md36503}
Contrary to the {\ttfamily .partial} method, the {\ttfamily .required} method makes all properties required.

Starting from this object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ user\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ email:\ z.string(),}
\DoxyCodeLine{\ \ \ \ username:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .partial();}
\DoxyCodeLine{//\ \{\ email?:\ string\ |\ undefined;\ username?:\ string\ |\ undefined\ \}}

\end{DoxyCode}


We can create a required version\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ requiredUser\ =\ user.required();}
\DoxyCodeLine{//\ \{\ email:\ string;\ username:\ string\ \}}

\end{DoxyCode}


You can also specify which properties to make required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ requiredEmail\ =\ user.required(\{}
\DoxyCodeLine{\ \ email:\ true,}
\DoxyCodeLine{\});}
\DoxyCodeLine{/*}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ email:\ string;}
\DoxyCodeLine{\ \ username?:\ string\ |\ undefined;}
\DoxyCodeLine{\}}
\DoxyCodeLine{*/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36504}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .passthrough}}{{\ttfamily .passthrough}}}\label{README.md_autotoc_md36504}
By default Zod object schemas strip out unrecognized keys during parsing.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ \{\ name:\ "{}bob\ dylan"{}\ \}}
\DoxyCodeLine{//\ extraKey\ has\ been\ stripped}

\end{DoxyCode}


Instead, if you want to pass through unknown keys, use {\ttfamily .passthrough()} .


\begin{DoxyCode}{0}
\DoxyCodeLine{person.passthrough().parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ \{\ name:\ "{}bob\ dylan"{},\ extraKey:\ 61\ \}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36505}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .strict}}{{\ttfamily .strict}}}\label{README.md_autotoc_md36505}
By default Zod object schemas strip out unrecognized keys during parsing. You can {\itshape disallow} unknown keys with {\ttfamily .strict()} . If there are any unknown keys in the input, Zod will throw an error.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .strict();}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ extraKey:\ 61,}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ throws\ ZodError}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36506}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .strip}}{{\ttfamily .strip}}}\label{README.md_autotoc_md36506}
You can use the {\ttfamily .strip} method to reset an object schema to the default behavior (stripping unrecognized keys).\hypertarget{README.md_autotoc_md36507}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .catchall}}{{\ttfamily .catchall}}}\label{README.md_autotoc_md36507}
You can pass a "{}catchall"{} schema into an object schema. All unknown keys will be validated against it.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ person\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .catchall(z.number());}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ validExtraKey:\ 61,\ //\ works\ fine}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{person.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}bob\ dylan"{},}
\DoxyCodeLine{\ \ validExtraKey:\ false,\ //\ fails}
\DoxyCodeLine{\});}
\DoxyCodeLine{//\ =>\ throws\ ZodError}

\end{DoxyCode}


Using {\ttfamily .catchall()} obviates {\ttfamily .passthrough()} , {\ttfamily .strip()} , or {\ttfamily .strict()}. All keys are now considered "{}known"{}.\hypertarget{README.md_autotoc_md36508}{}\doxysubsubsection{\texorpdfstring{Arrays}{Arrays}}\label{README.md_autotoc_md36508}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringArray\ =\ z.array(z.string());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent}
\DoxyCodeLine{const\ stringArray\ =\ z.string().array();}

\end{DoxyCode}


Be careful with the {\ttfamily .array()} method. It returns a new {\ttfamily Zod\+Array} instance. This means the {\itshape order} in which you call methods matters. For instance\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().optional().array();\ //\ (string\ |\ undefined)[]}
\DoxyCodeLine{z.string().array().optional();\ //\ string[]\ |\ undefined}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36509}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .element}}{{\ttfamily .element}}}\label{README.md_autotoc_md36509}
Use {\ttfamily .element} to access the schema for an element of the array.


\begin{DoxyCode}{0}
\DoxyCodeLine{stringArray.element;\ //\ =>\ string\ schema}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36510}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nonempty}}{{\ttfamily .nonempty}}}\label{README.md_autotoc_md36510}
If you want to ensure that an array contains at least one element, use {\ttfamily .nonempty()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nonEmptyStrings\ =\ z.string().array().nonempty();}
\DoxyCodeLine{//\ the\ inferred\ type\ is\ now}
\DoxyCodeLine{//\ [string,\ ...string[]]}
\DoxyCodeLine{}
\DoxyCodeLine{nonEmptyStrings.parse([]);\ //\ throws:\ "{}Array\ cannot\ be\ empty"{}}
\DoxyCodeLine{nonEmptyStrings.parse(["{}Ariana\ Grande"{}]);\ //\ passes}

\end{DoxyCode}


You can optionally specify a custom error message\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ optional\ custom\ error\ message}
\DoxyCodeLine{const\ nonEmptyStrings\ =\ z.string().array().nonempty(\{}
\DoxyCodeLine{\ \ message:\ "{}Can't\ be\ empty!"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36511}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .min/.max/.length}}{{\ttfamily .min/.max/.length}}}\label{README.md_autotoc_md36511}

\begin{DoxyCode}{0}
\DoxyCodeLine{z.string().array().min(5);\ //\ must\ contain\ 5\ or\ more\ items}
\DoxyCodeLine{z.string().array().max(5);\ //\ must\ contain\ 5\ or\ fewer\ items}
\DoxyCodeLine{z.string().array().length(5);\ //\ must\ contain\ 5\ items\ exactly}

\end{DoxyCode}


Unlike {\ttfamily .nonempty()} these methods do not change the inferred type.\hypertarget{README.md_autotoc_md36512}{}\doxysubsubsection{\texorpdfstring{Tuples}{Tuples}}\label{README.md_autotoc_md36512}
Unlike arrays, tuples have a fixed number of elements and each element can have a different type.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ athleteSchema\ =\ z.tuple([}
\DoxyCodeLine{\ \ z.string(),\ //\ name}
\DoxyCodeLine{\ \ z.number(),\ //\ jersey\ number}
\DoxyCodeLine{\ \ z.object(\{}
\DoxyCodeLine{\ \ \ \ pointsScored:\ z.number(),}
\DoxyCodeLine{\ \ \}),\ //\ statistics}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Athlete\ =\ z.infer<typeof\ athleteSchema>;}
\DoxyCodeLine{//\ type\ Athlete\ =\ [string,\ number,\ \{\ pointsScored:\ number\ \}]}

\end{DoxyCode}


A variadic ("{}rest"{}) argument can be added with the {\ttfamily .rest} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ variadicTuple\ =\ z.tuple([z.string()]).rest(z.number());}
\DoxyCodeLine{const\ result\ =\ variadicTuple.parse(["{}hello"{},\ 1,\ 2,\ 3]);}
\DoxyCodeLine{//\ =>\ [string,\ ...number[]];}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36513}{}\doxysubsubsection{\texorpdfstring{Unions}{Unions}}\label{README.md_autotoc_md36513}
Zod includes a built-\/in {\ttfamily z.\+union} method for composing "{}\+OR"{} types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.union([z.string(),\ z.number()]);}
\DoxyCodeLine{}
\DoxyCodeLine{stringOrNumber.parse("{}foo"{});\ //\ passes}
\DoxyCodeLine{stringOrNumber.parse(14);\ //\ passes}

\end{DoxyCode}


Zod will test the input against each of the "{}options"{} in order and return the first value that validates successfully.

For convenience, you can also use the \`{}.or\`{} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.string().or(z.number());}

\end{DoxyCode}


{\bfseries{Optional string validation\+:}}

To validate an optional form input, you can union the desired string validation with an empty string literal.

This example validates an input that is optional but needs to contain a valid URL\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalUrl\ =\ z.union([z.string().url().nullish(),\ z.literal("{}"{})]);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(optionalUrl.safeParse(undefined).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse(null).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}"{}).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}https://zod.dev"{}).success);\ //\ true}
\DoxyCodeLine{console.log(optionalUrl.safeParse("{}not\ a\ valid\ url"{}).success);\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36514}{}\doxysubsubsection{\texorpdfstring{Discriminated unions}{Discriminated unions}}\label{README.md_autotoc_md36514}
A discriminated union is a union of object schemas that all share a particular key.


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ MyUnion\ =}
\DoxyCodeLine{\ \ |\ \{\ status:\ "{}success"{};\ data:\ string\ \}}
\DoxyCodeLine{\ \ |\ \{\ status:\ "{}failed"{};\ error:\ Error\ \};}

\end{DoxyCode}


Such unions can be represented with the {\ttfamily z.\+discriminated\+Union} method. This enables faster evaluation, because Zod can check the {\itshape discriminator key} ({\ttfamily status} in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.

With the basic union method, the input is tested against each of the provided "{}options"{}, and in the case of invalidity, issues for all the "{}options"{} are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "{}options"{}, testing against it, and showing only the issues related to this "{}option"{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myUnion\ =\ z.discriminatedUnion("{}status"{},\ [}
\DoxyCodeLine{\ \ z.object(\{\ status:\ z.literal("{}success"{}),\ data:\ z.string()\ \}),}
\DoxyCodeLine{\ \ z.object(\{\ status:\ z.literal("{}failed"{}),\ error:\ z.instanceof(Error)\ \}),}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{myUnion.parse(\{\ status:\ "{}success"{},\ data:\ "{}yippie\ ki\ yay"{}\ \});}

\end{DoxyCode}


You can extract a reference to the array of schemas with the {\ttfamily .options} property.


\begin{DoxyCode}{0}
\DoxyCodeLine{myUnion.options;\ //\ [ZodObject<...>,\ ZodObject<...>]}

\end{DoxyCode}


To merge two or more discriminated unions, use {\ttfamily .options} with destructuring.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ A\ =\ z.discriminatedUnion("{}status"{},\ [}
\DoxyCodeLine{\ \ /*\ options\ */}
\DoxyCodeLine{]);}
\DoxyCodeLine{const\ B\ =\ z.discriminatedUnion("{}status"{},\ [}
\DoxyCodeLine{\ \ /*\ options\ */}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ AB\ =\ z.discriminatedUnion("{}status"{},\ [...A.options,\ ...B.options]);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36515}{}\doxysubsubsection{\texorpdfstring{Records}{Records}}\label{README.md_autotoc_md36515}
Record schemas are used to validate types such as {\ttfamily Record\texorpdfstring{$<$}{<}string, number\texorpdfstring{$>$}{>}}. This is particularly useful for storing or caching items by ID.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ User\ =\ z.object(\{\ name:\ z.string()\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ UserStore\ =\ z.record(z.string(),\ User);}
\DoxyCodeLine{type\ UserStore\ =\ z.infer<typeof\ UserStore>;}
\DoxyCodeLine{//\ =>\ Record<string,\ \{\ name:\ string\ \}>}

\end{DoxyCode}


The schema and inferred type can be used like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ userStore:\ UserStore\ =\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{userStore["{}77d2586b-\/9e8e-\/4ecf-\/8b21-\/ea7e0530eadd"{}]\ =\ \{}
\DoxyCodeLine{\ \ name:\ "{}Carlotta"{},}
\DoxyCodeLine{\};\ //\ passes}
\DoxyCodeLine{}
\DoxyCodeLine{userStore["{}77d2586b-\/9e8e-\/4ecf-\/8b21-\/ea7e0530eadd"{}]\ =\ \{}
\DoxyCodeLine{\ \ whatever:\ "{}Ice\ cream\ sundae"{},}
\DoxyCodeLine{\};\ //\ TypeError}

\end{DoxyCode}


{\bfseries{A note on numerical keys}}

While {\ttfamily z.\+record(key\+Type, value\+Type)} is able to accept numerical key types and Type\+Script\textquotesingle{}s built-\/in Record type is {\ttfamily Record\texorpdfstring{$<$}{<}Key\+Type, Value\+Type\texorpdfstring{$>$}{>}}, it\textquotesingle{}s hard to represent the Type\+Script type {\ttfamily Record\texorpdfstring{$<$}{<}number, any\texorpdfstring{$>$}{>}} in Zod.

As it turns out, Type\+Script\textquotesingle{}s behavior surrounding {\ttfamily \mbox{[}k\+: number\mbox{]}} is a little unintuitive\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ testMap:\ \{\ [k:\ number]:\ string\ \}\ =\ \{}
\DoxyCodeLine{\ \ 1:\ "{}one"{},}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{for\ (const\ key\ in\ testMap)\ \{}
\DoxyCodeLine{\ \ console.log(`\$\{key\}:\ \$\{typeof\ key\}`);}
\DoxyCodeLine{\}}
\DoxyCodeLine{//\ prints:\ \`{}1:\ string`}

\end{DoxyCode}


As you can see, Java\+Script automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn\textquotesingle{}t make sense to provide a way of creating a record schema with numerical keys, since there\textquotesingle{}s no such thing as a numerical key in runtime Java\+Script.\hypertarget{README.md_autotoc_md36516}{}\doxysubsubsection{\texorpdfstring{Maps}{Maps}}\label{README.md_autotoc_md36516}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringNumberMap\ =\ z.map(z.string(),\ z.number());}
\DoxyCodeLine{}
\DoxyCodeLine{type\ StringNumberMap\ =\ z.infer<typeof\ stringNumberMap>;}
\DoxyCodeLine{//\ type\ StringNumberMap\ =\ Map<string,\ number>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36517}{}\doxysubsubsection{\texorpdfstring{Sets}{Sets}}\label{README.md_autotoc_md36517}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberSet\ =\ z.set(z.number());}
\DoxyCodeLine{type\ NumberSet\ =\ z.infer<typeof\ numberSet>;}
\DoxyCodeLine{//\ type\ NumberSet\ =\ Set<number>}

\end{DoxyCode}


Set schemas can be further constrained with the following utility methods.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.set(z.string()).nonempty();\ //\ must\ contain\ at\ least\ one\ item}
\DoxyCodeLine{z.set(z.string()).min(5);\ //\ must\ contain\ 5\ or\ more\ items}
\DoxyCodeLine{z.set(z.string()).max(5);\ //\ must\ contain\ 5\ or\ fewer\ items}
\DoxyCodeLine{z.set(z.string()).size(5);\ //\ must\ contain\ 5\ items\ exactly}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36518}{}\doxysubsubsection{\texorpdfstring{Intersections}{Intersections}}\label{README.md_autotoc_md36518}
Intersections are useful for creating "{}logical AND"{} types. This is useful for intersecting two object types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Person\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ Employee\ =\ z.object(\{}
\DoxyCodeLine{\ \ role:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ EmployedPerson\ =\ z.intersection(Person,\ Employee);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to:}
\DoxyCodeLine{const\ EmployedPerson\ =\ Person.and(Employee);}

\end{DoxyCode}


Though in many cases, it is recommended to use {\ttfamily A.\+merge(\+B)} to merge two objects. The {\ttfamily .merge} method returns a new {\ttfamily Zod\+Object} instance, whereas {\ttfamily A.\+and(\+B)} returns a less useful {\ttfamily Zod\+Intersection} instance that lacks common object methods like {\ttfamily pick} and {\ttfamily omit}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ a\ =\ z.union([z.number(),\ z.string()]);}
\DoxyCodeLine{const\ b\ =\ z.union([z.number(),\ z.boolean()]);}
\DoxyCodeLine{const\ c\ =\ z.intersection(a,\ b);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ c\ =\ z.infer<typeof\ c>;\ //\ =>\ number}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36519}{}\doxysubsubsection{\texorpdfstring{Recursive types}{Recursive types}}\label{README.md_autotoc_md36519}
You can define a recursive schema in Zod, but because of a limitation of Type\+Script, their type can\textquotesingle{}t be statically inferred. Instead you\textquotesingle{}ll need to define the type definition manually, and provide it to Zod as a "{}type hint"{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ baseCategorySchema\ =\ z.object(\{}
\DoxyCodeLine{\ \ name:\ z.string(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Category\ =\ z.infer<typeof\ baseCategorySchema>\ \&\ \{}
\DoxyCodeLine{\ \ subcategories:\ Category[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ categorySchema:\ z.ZodType<Category>\ =\ baseCategorySchema.extend(\{}
\DoxyCodeLine{\ \ subcategories:\ z.lazy(()\ =>\ categorySchema.array()),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{categorySchema.parse(\{}
\DoxyCodeLine{\ \ name:\ "{}People"{},}
\DoxyCodeLine{\ \ subcategories:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ name:\ "{}Politicians"{},}
\DoxyCodeLine{\ \ \ \ \ \ subcategories:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ name:\ "{}Presidents"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ subcategories:\ [],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ ],}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ ],}
\DoxyCodeLine{\});\ //\ passes}

\end{DoxyCode}


Thanks to \href{https://github.com/crasite}{\texttt{ crasite}} for this example.\hypertarget{README.md_autotoc_md36520}{}\doxysubsubsubsection{\texorpdfstring{Zod\+Type with Zod\+Effects}{Zod\+Type with Zod\+Effects}}\label{README.md_autotoc_md36520}
When using {\ttfamily z.\+Zod\+Type} with {\ttfamily z.\+Zod\+Effects} ( \href{https://github.com/colinhacks/zod\#refine}{\texttt{ {\ttfamily .refine}}}, \href{https://github.com/colinhacks/zod\#transform}{\texttt{ {\ttfamily .transform}}}, \href{https://github.com/colinhacks/zod\#preprocess}{\texttt{ {\ttfamily preprocess}}}, etc... ), you will need to define the input and output types of the schema. {\ttfamily z.\+Zod\+Type\texorpdfstring{$<$}{<}Output, z.\+Zod\+Type\+Def, Input\texorpdfstring{$>$}{>}}


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ isValidId\ =\ (id:\ string):\ id\ is\ \`{}\$\{string\}/\$\{string\}`\ =>}
\DoxyCodeLine{\ \ id.split("{}/"{}).length\ ===\ 2;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ baseSchema\ =\ z.object(\{}
\DoxyCodeLine{\ \ id:\ z.string().refine(isValidId),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Input\ =\ z.input<typeof\ baseSchema>\ \&\ \{}
\DoxyCodeLine{\ \ children:\ Input[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type\ Output\ =\ z.output<typeof\ baseSchema>\ \&\ \{}
\DoxyCodeLine{\ \ children:\ Output[];}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ schema:\ z.ZodType<Output,\ z.ZodTypeDef,\ Input>\ =\ baseSchema.extend(\{}
\DoxyCodeLine{\ \ children:\ z.lazy(()\ =>\ schema.array()),}
\DoxyCodeLine{\});}

\end{DoxyCode}


Thanks to \href{https://github.com/marcus13371337}{\texttt{ marcus13371337}} and \href{https://github.com/JoelBeeldi}{\texttt{ Joel\+Beeldi}} for this example.\hypertarget{README.md_autotoc_md36521}{}\doxysubsubsubsection{\texorpdfstring{JSON type}{JSON type}}\label{README.md_autotoc_md36521}
If you want to validate any JSON value, you can use the snippet below.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ literalSchema\ =\ z.union([z.string(),\ z.number(),\ z.boolean(),\ z.null()]);}
\DoxyCodeLine{type\ Literal\ =\ z.infer<typeof\ literalSchema>;}
\DoxyCodeLine{type\ Json\ =\ Literal\ |\ \{\ [key:\ string]:\ Json\ \}\ |\ Json[];}
\DoxyCodeLine{const\ jsonSchema:\ z.ZodType<Json>\ =\ z.lazy(()\ =>}
\DoxyCodeLine{\ \ z.union([literalSchema,\ z.array(jsonSchema),\ z.record(jsonSchema)])}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{jsonSchema.parse(data);}

\end{DoxyCode}


Thanks to \href{https://github.com/ggoodman}{\texttt{ ggoodman}} for suggesting this.\hypertarget{README.md_autotoc_md36522}{}\doxysubsubsubsection{\texorpdfstring{Cyclical objects}{Cyclical objects}}\label{README.md_autotoc_md36522}
Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop in some cases.

\begin{quote}
To detect cyclical objects before they cause problems, consider \href{https://gist.github.com/colinhacks/d35825e505e635df27cc950776c5500b}{\texttt{ this approach}}. \end{quote}
\hypertarget{README.md_autotoc_md36523}{}\doxysubsubsection{\texorpdfstring{Promises}{Promises}}\label{README.md_autotoc_md36523}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberPromise\ =\ z.promise(z.number());}

\end{DoxyCode}


"{}\+Parsing"{} works a little differently with promise schemas. Validation happens in two parts\+:


\begin{DoxyEnumerate}
\item Zod synchronously checks that the input is an instance of Promise (i.\+e. an object with {\ttfamily .then} and {\ttfamily .catch} methods.).
\item Zod uses {\ttfamily .then} to attach an additional validation step onto the existing Promise. You\textquotesingle{}ll have to use {\ttfamily .catch} on the returned Promise to handle validation failures.
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{numberPromise.parse("{}tuna"{});}
\DoxyCodeLine{//\ ZodError:\ Non-\/Promise\ type:\ string}
\DoxyCodeLine{}
\DoxyCodeLine{numberPromise.parse(Promise.resolve("{}tuna"{}));}
\DoxyCodeLine{//\ =>\ Promise<number>}
\DoxyCodeLine{}
\DoxyCodeLine{const\ test\ =\ async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ await\ numberPromise.parse(Promise.resolve("{}tuna"{}));}
\DoxyCodeLine{\ \ //\ ZodError:\ Non-\/number\ type:\ string}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ await\ numberPromise.parse(Promise.resolve(3.14));}
\DoxyCodeLine{\ \ //\ =>\ 3.14}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36524}{}\doxysubsubsection{\texorpdfstring{Instanceof}{Instanceof}}\label{README.md_autotoc_md36524}
You can use {\ttfamily z.\+instanceof} to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-\/party libraries.


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ Test\ \{}
\DoxyCodeLine{\ \ name:\ string;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ TestSchema\ =\ z.instanceof(Test);}
\DoxyCodeLine{}
\DoxyCodeLine{const\ blob:\ any\ =\ "{}whatever"{};}
\DoxyCodeLine{TestSchema.parse(new\ Test());\ //\ passes}
\DoxyCodeLine{TestSchema.parse(blob);\ //\ throws}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36525}{}\doxysubsubsection{\texorpdfstring{Functions}{Functions}}\label{README.md_autotoc_md36525}
Zod also lets you define "{}function schemas"{}. This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "{}business logic"{}.

You can create a function schema with {\ttfamily z.\+function(args, return\+Type)} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z.function();}
\DoxyCodeLine{}
\DoxyCodeLine{type\ myFunction\ =\ z.infer<typeof\ myFunction>;}
\DoxyCodeLine{//\ =>\ ()=>unknown}

\end{DoxyCode}


Define inputs and outputs.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string(),\ z.number())\ //\ accepts\ an\ arbitrary\ number\ of\ arguments}
\DoxyCodeLine{\ \ .returns(z.boolean());}
\DoxyCodeLine{}
\DoxyCodeLine{type\ myFunction\ =\ z.infer<typeof\ myFunction>;}
\DoxyCodeLine{//\ =>\ (arg0:\ string,\ arg1:\ number)=>boolean}

\end{DoxyCode}


Function schemas have an {\ttfamily .implement()} method which accepts a function and returns a new function that automatically validates its inputs and outputs.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ trimmedLength\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string())\ //\ accepts\ an\ arbitrary\ number\ of\ arguments}
\DoxyCodeLine{\ \ .returns(z.number())}
\DoxyCodeLine{\ \ .implement((x)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ TypeScript\ knows\ x\ is\ a\ string!}
\DoxyCodeLine{\ \ \ \ return\ x.trim().length;}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{trimmedLength("{}sandwich"{});\ //\ =>\ 8}
\DoxyCodeLine{trimmedLength("{}\ asdf\ "{});\ //\ =>\ 4}

\end{DoxyCode}


If you only care about validating inputs, just don\textquotesingle{}t call the {\ttfamily .returns()} method. The output type will be inferred from the implementation.

\begin{quote}
You can use the special {\ttfamily z.\+void()} option if your function doesn\textquotesingle{}t return anything. This will let Zod properly infer the type of void-\/returning functions. (Void-\/returning functions actually return undefined.) \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myFunction\ =\ z}
\DoxyCodeLine{\ \ .function()}
\DoxyCodeLine{\ \ .args(z.string())}
\DoxyCodeLine{\ \ .implement((arg)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ return\ [arg.length];}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{myFunction;\ //\ (arg:\ string)=>number[]}

\end{DoxyCode}


Extract the input and output schemas from a function schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{myFunction.parameters();}
\DoxyCodeLine{//\ =>\ ZodTuple<[ZodString,\ ZodNumber]>}
\DoxyCodeLine{}
\DoxyCodeLine{myFunction.returnType();}
\DoxyCodeLine{//\ =>\ ZodBoolean}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36526}{}\doxysubsubsection{\texorpdfstring{Preprocess}{Preprocess}}\label{README.md_autotoc_md36526}
\begin{quote}
Zod now supports primitive coercion without the need for {\ttfamily .preprocess()}. See the coercion docs for more information. \end{quote}


Typically Zod operates under a "{}parse then transform"{} paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the .transform docs.)

But sometimes you want to apply some transform to the input {\itshape before} parsing happens. A common use case\+: type coercion. Zod enables this with the {\ttfamily z.\+preprocess()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ castToString\ =\ z.preprocess((val)\ =>\ String(val),\ z.string());}

\end{DoxyCode}


This returns a {\ttfamily Zod\+Effects} instance. {\ttfamily Zod\+Effects} is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.\hypertarget{README.md_autotoc_md36527}{}\doxysubsubsection{\texorpdfstring{Custom schemas}{Custom schemas}}\label{README.md_autotoc_md36527}
You can create a Zod schema for any Type\+Script type by using {\ttfamily z.\+custom()}. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ px\ =\ z.custom<`\$\{number\}px`>((val)\ =>\ \{}
\DoxyCodeLine{\ \ return\ typeof\ val\ ===\ "{}string"{}\ ?\ /\string^\(\backslash\)d+px\$/.test(val)\ :\ false;}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ px\ =\ z.infer<typeof\ px>;\ //\ \`{}\$\{number\}px`}
\DoxyCodeLine{}
\DoxyCodeLine{px.parse("{}42px"{});\ //\ "{}42px"{}}
\DoxyCodeLine{px.parse("{}42vw"{});\ //\ throws;}

\end{DoxyCode}


If you don\textquotesingle{}t provide a validation function, Zod will allow any value. This can be dangerous!


\begin{DoxyCode}{0}
\DoxyCodeLine{z.custom<\{\ arg:\ string\ \}>();\ //\ performs\ no\ validation}

\end{DoxyCode}


You can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of \`{}.refine\`{}.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.custom<...>((val)\ =>\ ...,\ "{}custom\ error\ message"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36528}{}\doxysubsubsection{\texorpdfstring{Schema methods}{Schema methods}}\label{README.md_autotoc_md36528}
All Zod schemas contain certain methods.\hypertarget{README.md_autotoc_md36529}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .parse}}{{\ttfamily .parse}}}\label{README.md_autotoc_md36529}
{\ttfamily .parse(data\+: unknown)\+: T}

Given any Zod schema, you can call its {\ttfamily .parse} method to check {\ttfamily data} is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.

\begin{quote}
IMPORTANT\+: The value returned by {\ttfamily .parse} is a {\itshape deep clone} of the variable you passed in. \end{quote}



\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string();}
\DoxyCodeLine{}
\DoxyCodeLine{stringSchema.parse("{}fish"{});\ //\ =>\ returns\ "{}fish"{}}
\DoxyCodeLine{stringSchema.parse(12);\ //\ throws\ error}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36530}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .parse\+Async}}{{\ttfamily .parse\+Async}}}\label{README.md_autotoc_md36530}
{\ttfamily .parse\+Async(data\+:unknown)\+: Promise\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}

If you use asynchronous refinements or transforms (more on those later), you\textquotesingle{}ll need to use {\ttfamily .parse\+Async}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringSchema\ =\ z.string().refine(async\ (val)\ =>\ val.length\ <=\ 8);}
\DoxyCodeLine{}
\DoxyCodeLine{await\ stringSchema.parseAsync("{}hello"{});\ //\ =>\ returns\ "{}hello"{}}
\DoxyCodeLine{await\ stringSchema.parseAsync("{}hello\ world"{});\ //\ =>\ throws\ error}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36531}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .safe\+Parse}}{{\ttfamily .safe\+Parse}}}\label{README.md_autotoc_md36531}
{\ttfamily .safe\+Parse(data\+:unknown)\+: \{ success\+: true; data\+: T; \} \texorpdfstring{$\vert$}{|} \{ success\+: false; error\+: Zod\+Error; \}}

If you don\textquotesingle{}t want Zod to throw errors when validation fails, use {\ttfamily .safe\+Parse}. This method returns an object containing either the successfully parsed data or a Zod\+Error instance containing detailed information about the validation problems.


\begin{DoxyCode}{0}
\DoxyCodeLine{stringSchema.safeParse(12);}
\DoxyCodeLine{//\ =>\ \{\ success:\ false;\ error:\ ZodError\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{stringSchema.safeParse("{}billie"{});}
\DoxyCodeLine{//\ =>\ \{\ success:\ true;\ data:\ 'billie'\ \}}

\end{DoxyCode}


The result is a {\itshape discriminated union}, so you can handle errors very conveniently\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ stringSchema.safeParse("{}billie"{});}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ //\ handle\ error\ then\ return}
\DoxyCodeLine{\ \ result.error;}
\DoxyCodeLine{\}\ else\ \{}
\DoxyCodeLine{\ \ //\ do\ something}
\DoxyCodeLine{\ \ result.data;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36532}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .safe\+Parse\+Async}}{{\ttfamily .safe\+Parse\+Async}}}\label{README.md_autotoc_md36532}
\begin{quote}
Alias\+: {\ttfamily .spa} \end{quote}


An asynchronous version of {\ttfamily safe\+Parse}.


\begin{DoxyCode}{0}
\DoxyCodeLine{await\ stringSchema.safeParseAsync("{}billie"{});}

\end{DoxyCode}


For convenience, this has been aliased to {\ttfamily .spa}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{await\ stringSchema.spa("{}billie"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36533}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .refine}}{{\ttfamily .refine}}}\label{README.md_autotoc_md36533}
{\ttfamily .refine(validator\+: (data\+:T)=\texorpdfstring{$>$}{>}any, params?\+: Refine\+Params)}

Zod lets you provide custom validation logic via {\itshape refinements}. (For advanced features like creating multiple issues and customizing error codes, see \`{}.super\+Refine\`{}.)

Zod was designed to mirror Type\+Script as closely as possible. But there are many so-\/called "{}refinement types"{} you may wish to check for that can\textquotesingle{}t be represented in Type\+Script\textquotesingle{}s type system. For instance\+: checking that a number is an integer or that a string is a valid email address.

For example, you can define a custom validation check on {\itshape any} Zod schema with {\ttfamily .refine} \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ myString\ =\ z.string().refine((val)\ =>\ val.length\ <=\ 255,\ \{}
\DoxyCodeLine{\ \ message:\ "{}String\ can't\ be\ more\ than\ 255\ characters"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
âš ï¸ Refinement functions should not throw. Instead they should return a falsy value to signal failure. \end{quote}
\hypertarget{README.md_autotoc_md36534}{}\doxysubsubsubsubsection{\texorpdfstring{Arguments}{Arguments}}\label{README.md_autotoc_md36534}
As you can see, {\ttfamily .refine} takes two arguments.


\begin{DoxyEnumerate}
\item The first is the validation function. This function takes one input (of type {\ttfamily T} â€” the inferred type of the schema) and returns {\ttfamily any}. Any truthy value will pass validation. (Prior to zod@1.\+6.\+2 the validation function had to return a boolean.)
\item The second argument accepts some options. You can use this to customize certain error-\/handling behavior\+:
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ RefineParams\ =\ \{}
\DoxyCodeLine{\ \ //\ override\ error\ message}
\DoxyCodeLine{\ \ message?:\ string;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ appended\ to\ error\ path}
\DoxyCodeLine{\ \ path?:\ (string\ |\ number)[];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ params\ object\ you\ can\ use\ to\ customize\ message}
\DoxyCodeLine{\ \ //\ in\ error\ map}
\DoxyCodeLine{\ \ params?:\ object;}
\DoxyCodeLine{\};}

\end{DoxyCode}


For advanced cases, the second argument can also be a function that returns {\ttfamily Refine\+Params}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ longString\ =\ z.string().refine(}
\DoxyCodeLine{\ \ (val)\ =>\ val.length\ >\ 10,}
\DoxyCodeLine{\ \ (val)\ =>\ (\{\ message:\ \`{}\$\{val\}\ is\ not\ more\ than\ 10\ characters`\ \})}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36535}{}\doxysubsubsubsubsection{\texorpdfstring{Customize error path}{Customize error path}}\label{README.md_autotoc_md36535}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ passwordForm\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ password:\ z.string(),}
\DoxyCodeLine{\ \ \ \ confirm:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .refine((data)\ =>\ data.password\ ===\ data.confirm,\ \{}
\DoxyCodeLine{\ \ \ \ message:\ "{}Passwords\ don't\ match"{},}
\DoxyCodeLine{\ \ \ \ path:\ ["{}confirm"{}],\ //\ path\ of\ error}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{passwordForm.parse(\{\ password:\ "{}asdf"{},\ confirm:\ "{}qwer"{}\ \});}

\end{DoxyCode}


Because you provided a {\ttfamily path} parameter, the resulting error will be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZodError\ \{}
\DoxyCodeLine{\ \ issues:\ [\{}
\DoxyCodeLine{\ \ \ \ "{}code"{}:\ "{}custom"{},}
\DoxyCodeLine{\ \ \ \ "{}path"{}:\ [\ "{}confirm"{}\ ],}
\DoxyCodeLine{\ \ \ \ "{}message"{}:\ "{}Passwords\ don't\ match"{}}
\DoxyCodeLine{\ \ \}]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36536}{}\doxysubsubsubsubsection{\texorpdfstring{Asynchronous refinements}{Asynchronous refinements}}\label{README.md_autotoc_md36536}
Refinements can also be async\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ userId\ =\ z.string().refine(async\ (id)\ =>\ \{}
\DoxyCodeLine{\ \ //\ verify\ that\ ID\ exists\ in\ database}
\DoxyCodeLine{\ \ return\ true;}
\DoxyCodeLine{\});}

\end{DoxyCode}


\begin{quote}
âš ï¸ If you use async refinements, you must use the {\ttfamily .parse\+Async} method to parse data! Otherwise Zod will throw an error. \end{quote}
\hypertarget{README.md_autotoc_md36537}{}\doxysubsubsubsubsection{\texorpdfstring{Relationship to transforms}{Relationship to transforms}}\label{README.md_autotoc_md36537}
Transforms and refinements can be interleaved\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.length)}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val\ >\ 25);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36538}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .super\+Refine}}{{\ttfamily .super\+Refine}}}\label{README.md_autotoc_md36538}
The {\ttfamily .refine} method is actually syntactic sugar atop a more versatile (and verbose) method called {\ttfamily super\+Refine}. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Strings\ =\ z.array(z.string()).superRefine((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (val.length\ >\ 3)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.too\_big,}
\DoxyCodeLine{\ \ \ \ \ \ maximum:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ type:\ "{}array"{},}
\DoxyCodeLine{\ \ \ \ \ \ inclusive:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}Too\ many\ items\ ðŸ˜¡"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (val.length\ !==\ new\ Set(val).size)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ \`{}No\ duplicates\ allowed.`,}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}


You can add as many issues as you like. If {\ttfamily ctx.\+add\+Issue} is {\itshape not} called during the execution of the function, validation passes.

Normally refinements always create issues with a {\ttfamily Zod\+Issue\+Code.\+custom} error code, but with {\ttfamily super\+Refine} it\textquotesingle{}s possible to throw issues of any {\ttfamily Zod\+Issue\+Code}. Each issue code is described in detail in the Error Handling guide\+: ERROR\+\_\+\+HANDLING.md.\hypertarget{README.md_autotoc_md36539}{}\doxysubsubsubsubsection{\texorpdfstring{Abort early}{Abort early}}\label{README.md_autotoc_md36539}
By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to {\itshape abort early} to prevent later refinements from being executed. To achieve this, pass the {\ttfamily fatal} flag to {\ttfamily ctx.\+add\+Issue} and return {\ttfamily z.\+NEVER}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.number().superRefine((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ if\ (val\ <\ 10)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}should\ be\ >=\ 10"{},}
\DoxyCodeLine{\ \ \ \ \ \ fatal:\ true,}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (val\ !==\ 12)\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}should\ be\ twelve"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36540}{}\doxysubsubsubsubsection{\texorpdfstring{Type refinements}{Type refinements}}\label{README.md_autotoc_md36540}
If you provide a \href{https://www.typescriptlang.org/docs/handbook/2/narrowing.html\#using-type-predicates}{\texttt{ type predicate}} to {\ttfamily .refine()} or {\ttfamily .super\+Refine()}, the resulting type will be narrowed down to your predicate\textquotesingle{}s type. This is useful if you are mixing multiple chained refinements and transformations\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ first:\ z.string(),}
\DoxyCodeLine{\ \ \ \ second:\ z.number(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .nullable()}
\DoxyCodeLine{\ \ .superRefine((arg,\ ctx):\ arg\ is\ \{\ first:\ string;\ second:\ number\ \}\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (!arg)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ code:\ z.ZodIssueCode.custom,\ //\ customize\ your\ issue}
\DoxyCodeLine{\ \ \ \ \ \ \ \ message:\ "{}object\ should\ exist"{},}
\DoxyCodeLine{\ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;\ //\ The\ return\ value\ is\ not\ used,\ but\ we\ need\ to\ return\ something\ to\ satisfy\ the\ typing}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ //\ here,\ TS\ knows\ that\ arg\ is\ not\ null}
\DoxyCodeLine{\ \ .refine((arg)\ =>\ arg.first\ ===\ "{}bob"{},\ "{}`first`\ is\ not\ \`{}bob`!"{});}

\end{DoxyCode}


\begin{quote}
âš ï¸ You {\bfseries{must}} use {\ttfamily ctx.\+add\+Issue()} instead of returning a boolean value to indicate whether the validation passes. If {\ttfamily ctx.\+add\+Issue} is {\itshape not} called during the execution of the function, validation passes. \end{quote}
\hypertarget{README.md_autotoc_md36541}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .transform}}{{\ttfamily .transform}}}\label{README.md_autotoc_md36541}
To transform data after parsing, use the {\ttfamily transform} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringToNumber\ =\ z.string().transform((val)\ =>\ val.length);}
\DoxyCodeLine{}
\DoxyCodeLine{stringToNumber.parse("{}string"{});\ //\ =>\ 6}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36542}{}\doxysubsubsubsubsection{\texorpdfstring{Chaining order}{Chaining order}}\label{README.md_autotoc_md36542}
Note that {\ttfamily string\+To\+Number} above is an instance of the {\ttfamily Zod\+Effects} subclass. It is NOT an instance of {\ttfamily Zod\+String}. If you want to use the built-\/in methods of {\ttfamily Zod\+String} (e.\+g. {\ttfamily .email()}) you must apply those methods {\itshape before} any transforms.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ emailToDomain\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .email()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.split("{}@"{})[1]);}
\DoxyCodeLine{}
\DoxyCodeLine{emailToDomain.parse("{}colinhacks@example.com"{});\ //\ =>\ example.com}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36543}{}\doxysubsubsubsubsection{\texorpdfstring{Validating during transform}{Validating during transform}}\label{README.md_autotoc_md36543}
The {\ttfamily .transform} method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining {\ttfamily transform} and {\ttfamily refine}.

As with {\ttfamily .super\+Refine}, the transform function receives a {\ttfamily ctx} object with an {\ttfamily add\+Issue} method that can be used to register validation issues.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberInString\ =\ z.string().transform((val,\ ctx)\ =>\ \{}
\DoxyCodeLine{\ \ const\ parsed\ =\ parseInt(val);}
\DoxyCodeLine{\ \ if\ (isNaN(parsed))\ \{}
\DoxyCodeLine{\ \ \ \ ctx.addIssue(\{}
\DoxyCodeLine{\ \ \ \ \ \ code:\ z.ZodIssueCode.custom,}
\DoxyCodeLine{\ \ \ \ \ \ message:\ "{}Not\ a\ number"{},}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ This\ is\ a\ special\ symbol\ you\ can\ use\ to}
\DoxyCodeLine{\ \ \ \ //\ return\ early\ from\ the\ transform\ function.}
\DoxyCodeLine{\ \ \ \ //\ It\ has\ type\ \`{}never`\ so\ it\ does\ not\ affect\ the}
\DoxyCodeLine{\ \ \ \ //\ inferred\ return\ type.}
\DoxyCodeLine{\ \ \ \ return\ z.NEVER;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ return\ parsed;}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36544}{}\doxysubsubsubsubsection{\texorpdfstring{Relationship to refinements}{Relationship to refinements}}\label{README.md_autotoc_md36544}
Transforms and refinements can be interleaved. These will be executed in the order they are declared.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nameToGreeting\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.toUpperCase())}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val.length\ >\ 15)}
\DoxyCodeLine{\ \ .transform((val)\ =>\ \`{}Hello\ \$\{val\}`)}
\DoxyCodeLine{\ \ .refine((val)\ =>\ val.indexOf("{}!"{})\ ===\ -\/1);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36545}{}\doxysubsubsubsubsection{\texorpdfstring{Async transforms}{Async transforms}}\label{README.md_autotoc_md36545}
Transforms can also be async.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ IdToUser\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .uuid()}
\DoxyCodeLine{\ \ .transform(async\ (id)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ return\ await\ getUserById(id);}
\DoxyCodeLine{\ \ \});}

\end{DoxyCode}


\begin{quote}
âš ï¸ If your schema contains asynchronous transforms, you must use .parse\+Async() or .safe\+Parse\+Async() to parse data. Otherwise Zod will throw an error. \end{quote}
\hypertarget{README.md_autotoc_md36546}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .default}}{{\ttfamily .default}}}\label{README.md_autotoc_md36546}
You can use transforms to implement the concept of "{}default values"{} in Zod.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringWithDefault\ =\ z.string().default("{}tuna"{});}
\DoxyCodeLine{}
\DoxyCodeLine{stringWithDefault.parse(undefined);\ //\ =>\ "{}tuna"{}}

\end{DoxyCode}


Optionally, you can pass a function into {\ttfamily .default} that will be re-\/executed whenever a default value needs to be generated\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithRandomDefault\ =\ z.number().default(Math.random);}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.4413456736055323}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.1871840107401901}
\DoxyCodeLine{numberWithRandomDefault.parse(undefined);\ //\ =>\ 0.7223408162401552}

\end{DoxyCode}


Conceptually, this is how Zod processes default values\+:


\begin{DoxyEnumerate}
\item If the input is {\ttfamily undefined}, the default value is returned
\item Otherwise, the data is parsed using the base schema
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36547}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .describe}}{{\ttfamily .describe}}}\label{README.md_autotoc_md36547}
Use {\ttfamily .describe()} to add a {\ttfamily description} property to the resulting schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ documentedString\ =\ z}
\DoxyCodeLine{\ \ .string()}
\DoxyCodeLine{\ \ .describe("{}A\ useful\ bit\ of\ text,\ if\ you\ know\ what\ to\ do\ with\ it."{});}
\DoxyCodeLine{documentedString.description;\ //\ A\ useful\ bit\ of\ textâ€¦}

\end{DoxyCode}


This can be useful for documenting a field, for example in a JSON Schema using a library like \href{https://github.com/StefanTerdell/zod-to-json-schema}{\texttt{ {\ttfamily zod-\/to-\/json-\/schema}}}).\hypertarget{README.md_autotoc_md36548}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .catch}}{{\ttfamily .catch}}}\label{README.md_autotoc_md36548}
Use {\ttfamily .catch()} to provide a "{}catch value"{} to be returned in the event of a parsing error.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithCatch\ =\ z.number().catch(42);}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithCatch.parse(5);\ //\ =>\ 5}
\DoxyCodeLine{numberWithCatch.parse("{}tuna"{});\ //\ =>\ 42}

\end{DoxyCode}


Optionally, you can pass a function into {\ttfamily .catch} that will be re-\/executed whenever a default value needs to be generated. A {\ttfamily ctx} object containing the caught error will be passed into this function.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ numberWithRandomCatch\ =\ z.number().catch((ctx)\ =>\ \{}
\DoxyCodeLine{\ \ ctx.error;\ //\ the\ caught\ ZodError}
\DoxyCodeLine{\ \ return\ Math.random();}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.4413456736055323}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.1871840107401901}
\DoxyCodeLine{numberWithRandomCatch.parse("{}sup"{});\ //\ =>\ 0.7223408162401552}

\end{DoxyCode}


Conceptually, this is how Zod processes "{}catch values"{}\+:


\begin{DoxyEnumerate}
\item The data is parsed using the base schema
\item If the parsing fails, the "{}catch value"{} is returned
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36549}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .optional}}{{\ttfamily .optional}}}\label{README.md_autotoc_md36549}
A convenience method that returns an optional version of a schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ optionalString\ =\ z.string().optional();\ //\ string\ |\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.optional(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36550}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nullable}}{{\ttfamily .nullable}}}\label{README.md_autotoc_md36550}
A convenience method that returns a nullable version of a schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullableString\ =\ z.string().nullable();\ //\ string\ |\ null}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.nullable(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36551}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .nullish}}{{\ttfamily .nullish}}}\label{README.md_autotoc_md36551}
A convenience method that returns a "{}nullish"{} version of a schema. Nullish schemas will accept both {\ttfamily undefined} and {\ttfamily null}. Read more about the concept of "{}nullish"{} \href{https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html\#nullish-coalescing}{\texttt{ in the Type\+Script 3.\+7 release notes}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nullishString\ =\ z.string().nullish();\ //\ string\ |\ null\ |\ undefined}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.string().nullable().optional();}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36552}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .array}}{{\ttfamily .array}}}\label{README.md_autotoc_md36552}
A convenience method that returns an array schema for the given type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringArray\ =\ z.string().array();\ //\ string[]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.array(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36553}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .promise}}{{\ttfamily .promise}}}\label{README.md_autotoc_md36553}
A convenience method for promise types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringPromise\ =\ z.string().promise();\ //\ Promise<string>}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.promise(z.string());}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36554}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .or}}{{\ttfamily .or}}}\label{README.md_autotoc_md36554}
A convenience method for union types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringOrNumber\ =\ z.string().or(z.number());\ //\ string\ |\ number}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.union([z.string(),\ z.number()]);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36555}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .and}}{{\ttfamily .and}}}\label{README.md_autotoc_md36555}
A convenience method for creating intersection types.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ nameAndAge\ =\ z}
\DoxyCodeLine{\ \ .object(\{\ name:\ z.string()\ \})}
\DoxyCodeLine{\ \ .and(z.object(\{\ age:\ z.number()\ \}));\ //\ \{\ name:\ string\ \}\ \&\ \{\ age:\ number\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to}
\DoxyCodeLine{z.intersection(z.object(\{\ name:\ z.string()\ \}),\ z.object(\{\ age:\ z.number()\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36556}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .brand}}{{\ttfamily .brand}}}\label{README.md_autotoc_md36556}
{\ttfamily .brand\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}() =\texorpdfstring{$>$}{>} Zod\+Branded\texorpdfstring{$<$}{<}this, B\texorpdfstring{$>$}{>}}

Type\+Script\textquotesingle{}s type system is structural, which means that any two types that are structurally equivalent are considered the same.


\begin{DoxyCode}{0}
\DoxyCodeLine{type\ Cat\ =\ \{\ name:\ string\ \};}
\DoxyCodeLine{type\ Dog\ =\ \{\ name:\ string\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ petCat\ =\ (cat:\ Cat)\ =>\ \{\};}
\DoxyCodeLine{const\ fido:\ Dog\ =\ \{\ name:\ "{}fido"{}\ \};}
\DoxyCodeLine{petCat(fido);\ //\ works\ fine}

\end{DoxyCode}


In some cases, its can be desirable to simulate {\itshape nominal typing} inside Type\+Script. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with {\itshape branded types} (AKA {\itshape opaque types}).


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Cat\ =\ z.object(\{\ name:\ z.string()\ \}).brand<"{}Cat"{}>();}
\DoxyCodeLine{type\ Cat\ =\ z.infer<typeof\ Cat>;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ petCat\ =\ (cat:\ Cat)\ =>\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ works}
\DoxyCodeLine{const\ simba\ =\ Cat.parse(\{\ name:\ "{}simba"{}\ \});}
\DoxyCodeLine{petCat(simba);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ this\ doesn't}
\DoxyCodeLine{petCat(\{\ name:\ "{}fido"{}\ \});}

\end{DoxyCode}


Under the hood, this works by attaching a "{}brand"{} to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ Cat\ =\ z.object(\{\ name:\ z.string()\ \}).brand<"{}Cat"{}>();}
\DoxyCodeLine{type\ Cat\ =\ z.infer<typeof\ Cat>;}
\DoxyCodeLine{//\ \{name:\ string\}\ \&\ \{[symbol]:\ "{}Cat"{}\}}

\end{DoxyCode}


Note that branded types do not affect the runtime result of {\ttfamily .parse}. It is a static-\/only construct.\hypertarget{README.md_autotoc_md36557}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .readonly}}{{\ttfamily .readonly}}}\label{README.md_autotoc_md36557}
{\ttfamily .readonly() =\texorpdfstring{$>$}{>} Zod\+Readonly\texorpdfstring{$<$}{<}this\texorpdfstring{$>$}{>}}

This method returns a {\ttfamily Zod\+Readonly} schema instance that parses the input using the base schema, then calls {\ttfamily Object.\+freeze()} on the result. The inferred type is also marked as {\ttfamily readonly}.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ schema\ =\ z.object(\{\ name:\ z.string()\ \}).readonly();}
\DoxyCodeLine{type\ schema\ =\ z.infer<typeof\ schema>;}
\DoxyCodeLine{//\ Readonly<\{name:\ string\}>}
\DoxyCodeLine{}
\DoxyCodeLine{const\ result\ =\ schema.parse(\{\ name:\ "{}fido"{}\ \});}
\DoxyCodeLine{result.name\ =\ "{}simba"{};\ //\ error}

\end{DoxyCode}


The inferred type uses Type\+Script\textquotesingle{}s built-\/in readonly types when relevant.


\begin{DoxyCode}{0}
\DoxyCodeLine{z.array(z.string()).readonly();}
\DoxyCodeLine{//\ readonly\ string[]}
\DoxyCodeLine{}
\DoxyCodeLine{z.tuple([z.string(),\ z.number()]).readonly();}
\DoxyCodeLine{//\ readonly\ [string,\ number]}
\DoxyCodeLine{}
\DoxyCodeLine{z.map(z.string(),\ z.date()).readonly();}
\DoxyCodeLine{//\ ReadonlyMap<string,\ Date>}
\DoxyCodeLine{}
\DoxyCodeLine{z.set(z.string()).readonly();}
\DoxyCodeLine{//\ ReadonlySet<string>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36558}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily .pipe}}{{\ttfamily .pipe}}}\label{README.md_autotoc_md36558}
Schemas can be chained into validation "{}pipelines"{}. It\textquotesingle{}s useful for easily validating the result after a {\ttfamily .transform()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z.string()}
\DoxyCodeLine{\ \ .transform((val)\ =>\ val.length)}
\DoxyCodeLine{\ \ .pipe(z.number().min(5));}

\end{DoxyCode}


The {\ttfamily .pipe()} method returns a {\ttfamily Zod\+Pipeline} instance.\hypertarget{README.md_autotoc_md36559}{}\doxysubsubsubsubsection{\texorpdfstring{You can use {\ttfamily .pipe()} to fix common issues with {\ttfamily z.\+coerce}.}{You can use {\ttfamily .pipe()} to fix common issues with {\ttfamily z.\+coerce}.}}\label{README.md_autotoc_md36559}
You can constrain the input to types that work well with your chosen coercion. Then use {\ttfamily .pipe()} to apply the coercion.

without constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toDate\ =\ z.coerce.date();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ works\ intuitively}
\DoxyCodeLine{console.log(toDate.safeParse("{}2023-\/01-\/01"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ might\ not\ be\ what\ you\ want}
\DoxyCodeLine{console.log(toDate.safeParse(null).success);\ //\ true}

\end{DoxyCode}


with constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ datelike\ =\ z.union([z.number(),\ z.string(),\ z.date()]);}
\DoxyCodeLine{const\ datelikeToDate\ =\ datelike.pipe(z.coerce.date());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ still\ works\ intuitively}
\DoxyCodeLine{console.log(datelikeToDate.safeParse("{}2023-\/01-\/01"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ more\ likely\ what\ you\ want}
\DoxyCodeLine{console.log(datelikeToDate.safeParse(null).success);\ //\ false}

\end{DoxyCode}


You can also use this technique to avoid coercions that throw uncaught errors.

without constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toBigInt\ =\ z.coerce.bigint();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ works\ intuitively}
\DoxyCodeLine{console.log(toBigInt.safeParse("{}42"{}));\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ probably\ not\ what\ you\ want}
\DoxyCodeLine{console.log(toBigInt.safeParse(null));\ //\ throws\ uncaught\ error}

\end{DoxyCode}


with constrained input\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ toNumber\ =\ z.number().or(z.string()).pipe(z.coerce.number());}
\DoxyCodeLine{const\ toBigInt\ =\ z.bigint().or(toNumber).pipe(z.coerce.bigint());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ still\ works\ intuitively}
\DoxyCodeLine{console.log(toBigInt.safeParse("{}42"{}).success);\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ error\ handled\ by\ zod,\ more\ likely\ what\ you\ want}
\DoxyCodeLine{console.log(toBigInt.safeParse(null).success);\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36560}{}\doxysubsubsection{\texorpdfstring{Guides and concepts}{Guides and concepts}}\label{README.md_autotoc_md36560}
\hypertarget{README.md_autotoc_md36561}{}\doxysubsubsubsection{\texorpdfstring{Type inference}{Type inference}}\label{README.md_autotoc_md36561}
You can extract the Type\+Script type of any schema with {\ttfamily z.\+infer\texorpdfstring{$<$}{<}typeof my\+Schema\texorpdfstring{$>$}{>}} .


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ A\ =\ z.string();}
\DoxyCodeLine{type\ A\ =\ z.infer<typeof\ A>;\ //\ string}
\DoxyCodeLine{}
\DoxyCodeLine{const\ u:\ A\ =\ 12;\ //\ TypeError}
\DoxyCodeLine{const\ u:\ A\ =\ "{}asdf"{};\ //\ compiles}

\end{DoxyCode}


{\bfseries{What about transforms?}}

In reality each Zod schema internally tracks {\bfseries{two}} types\+: an input and an output. For most schemas (e.\+g. {\ttfamily z.\+string()}) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance {\ttfamily z.\+string().transform(val =\texorpdfstring{$>$}{>} val.\+length)} has an input of {\ttfamily string} and an output of {\ttfamily number}.

You can separately extract the input and output types like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ stringToNumber\ =\ z.string().transform((val)\ =>\ val.length);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ âš ï¸\ Important:\ z.infer\ returns\ the\ OUTPUT\ type!}
\DoxyCodeLine{type\ input\ =\ z.input<typeof\ stringToNumber>;\ //\ string}
\DoxyCodeLine{type\ output\ =\ z.output<typeof\ stringToNumber>;\ //\ number}
\DoxyCodeLine{}
\DoxyCodeLine{//\ equivalent\ to\ z.output!}
\DoxyCodeLine{type\ inferred\ =\ z.infer<typeof\ stringToNumber>;\ //\ number}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36562}{}\doxysubsubsubsection{\texorpdfstring{Writing generic functions}{Writing generic functions}}\label{README.md_autotoc_md36562}
With Type\+Script generics, you can write reusable functions that accept Zod schemas as parameters. This enables you to create custom validation logic, schema transformations, and more, while maintaining type safety and inference.

When attempting to write a function that accepts a Zod schema as an input, it\textquotesingle{}s tempting to try something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ inferSchema<T>(schema:\ z.ZodType<T>)\ \{}
\DoxyCodeLine{\ \ return\ schema;}
\DoxyCodeLine{\}}

\end{DoxyCode}


This approach is incorrect, and limits Type\+Script\textquotesingle{}s ability to properly infer the argument. No matter what you pass in, the type of {\ttfamily schema} will be an instance of {\ttfamily Zod\+Type}.


\begin{DoxyCode}{0}
\DoxyCodeLine{inferSchema(z.string());}
\DoxyCodeLine{//\ =>\ ZodType<string>}

\end{DoxyCode}


This approach loses type information, namely {\itshape which subclass} the input actually is (in this case, {\ttfamily Zod\+String}). That means you can\textquotesingle{}t call any string-\/specific methods like {\ttfamily .min()} on the result of {\ttfamily infer\+Schema}.

A better approach is to infer {\itshape the schema as a whole} instead of merely its inferred type. You can do this with a utility type called {\ttfamily z.\+Zod\+Type\+Any}.


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ inferSchema<T\ extends\ z.ZodTypeAny>(schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{inferSchema(z.string());}
\DoxyCodeLine{//\ =>\ ZodString}

\end{DoxyCode}


\begin{quote}
{\ttfamily Zod\+Type\+Any} is just a shorthand for {\ttfamily Zod\+Type\texorpdfstring{$<$}{<}any, any, any\texorpdfstring{$>$}{>}}, a type that is broad enough to match any Zod schema. \end{quote}


The Result is now fully and properly typed, and the type system can infer the specific subclass of the schema.\hypertarget{README.md_autotoc_md36563}{}\doxysubsubsubsubsection{\texorpdfstring{Inferring the inferred type}{Inferring the inferred type}}\label{README.md_autotoc_md36563}
If you follow the best practice of using {\ttfamily z.\+Zod\+Type\+Any} as the generic parameter for your schema, you may encounter issues with the parsed data being typed as {\ttfamily any} instead of the inferred type of the schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ parseData<T\ extends\ z.ZodTypeAny>(data:\ unknown,\ schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema.parse(data);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{parseData("{}sup"{},\ z.string());}
\DoxyCodeLine{//\ =>\ any}

\end{DoxyCode}


Due to how Type\+Script inference works, it is treating {\ttfamily schema} like a {\ttfamily Zod\+Type\+Any} instead of the inferred type. You can fix this with a type cast using {\ttfamily z.\+infer}.


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ parseData<T\ extends\ z.ZodTypeAny>(data:\ unknown,\ schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema.parse(data)\ as\ z.infer<T>;}
\DoxyCodeLine{\ \ //\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \string^\string^\string^\string^\string^\string^\string^\string^\string^\string^\string^\string^\string^\string^\ <-\/\ add\ this}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{parseData("{}sup"{},\ z.string());}
\DoxyCodeLine{//\ =>\ string}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36564}{}\doxysubsubsubsubsection{\texorpdfstring{Constraining allowable inputs}{Constraining allowable inputs}}\label{README.md_autotoc_md36564}
The {\ttfamily Zod\+Type} class has three generic parameters.


\begin{DoxyCode}{0}
\DoxyCodeLine{class\ ZodType<}
\DoxyCodeLine{\ \ Output\ =\ any,}
\DoxyCodeLine{\ \ Def\ extends\ ZodTypeDef\ =\ ZodTypeDef,}
\DoxyCodeLine{\ \ Input\ =\ Output}
\DoxyCodeLine{>\ \{\ ...\ \}}

\end{DoxyCode}


By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function\ makeSchemaOptional<T\ extends\ z.ZodType<string>>(schema:\ T)\ \{}
\DoxyCodeLine{\ \ return\ schema.optional();}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{makeSchemaOptional(z.string());}
\DoxyCodeLine{//\ works\ fine}
\DoxyCodeLine{}
\DoxyCodeLine{makeSchemaOptional(z.number());}
\DoxyCodeLine{//\ Error:\ 'ZodNumber'\ is\ not\ assignable\ to\ parameter\ of\ type\ 'ZodType<string,\ ZodTypeDef,\ string>'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36565}{}\doxysubsubsubsection{\texorpdfstring{Error handling}{Error handling}}\label{README.md_autotoc_md36565}
Zod provides a subclass of Error called {\ttfamily Zod\+Error}. Zod\+Errors contain an {\ttfamily issues} array containing detailed information about the validation problems.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .safeParse(\{\ name:\ 12\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ result.error.issues;}
\DoxyCodeLine{\ \ /*\ [}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}code"{}:\ "{}invalid\_type"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}expected"{}:\ "{}string"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}received"{}:\ "{}number"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}path"{}:\ [\ "{}name"{}\ ],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ "{}message"{}:\ "{}Expected\ string,\ received\ number"{}}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ ]\ */}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide\+: ERROR\+\_\+\+HANDLING.md \end{quote}


Zod\textquotesingle{}s error reporting emphasizes {\itshape completeness} and {\itshape correctness}. If you are looking to present a useful error message to the end user, you should either override Zod\textquotesingle{}s error messages using an error map (described in detail in the Error Handling guide) or use a third-\/party library like \href{https://github.com/causaly/zod-validation-error}{\texttt{ {\ttfamily zod-\/validation-\/error}}}\hypertarget{README.md_autotoc_md36566}{}\doxysubsubsubsection{\texorpdfstring{Error formatting}{Error formatting}}\label{README.md_autotoc_md36566}
You can use the {\ttfamily .\doxylink{utilities_8cc_abe24116ee0a218908696f43fe118e24b}{format()}} method to convert this error into a nested object.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ result\ =\ z}
\DoxyCodeLine{\ \ .object(\{}
\DoxyCodeLine{\ \ \ \ name:\ z.string(),}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ .safeParse(\{\ name:\ 12\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{if\ (!result.success)\ \{}
\DoxyCodeLine{\ \ const\ formatted\ =\ result.error.format();}
\DoxyCodeLine{\ \ /*\ \{}
\DoxyCodeLine{\ \ \ \ name:\ \{\ \_errors:\ [\ 'Expected\ string,\ received\ number'\ ]\ \}}
\DoxyCodeLine{\ \ \}\ */}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ formatted.name?.\_errors;}
\DoxyCodeLine{\ \ //\ =>\ ["{}Expected\ string,\ received\ number"{}]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36567}{}\doxysubsubsection{\texorpdfstring{Comparison}{Comparison}}\label{README.md_autotoc_md36567}
There are a handful of other widely-\/used validation libraries, but all of them have certain design limitations that make for a non-\/ideal developer experience.\hypertarget{README.md_autotoc_md36568}{}\doxysubsubsubsection{\texorpdfstring{Joi}{Joi}}\label{README.md_autotoc_md36568}
\href{https://github.com/hapijs/joi}{\texttt{ https\+://github.\+com/hapijs/joi}}

Doesn\textquotesingle{}t support static type inference ðŸ˜•\hypertarget{README.md_autotoc_md36569}{}\doxysubsubsubsection{\texorpdfstring{Yup}{Yup}}\label{README.md_autotoc_md36569}
\href{https://github.com/jquense/yup}{\texttt{ https\+://github.\+com/jquense/yup}}

Yup is a full-\/featured library that was implemented first in vanilla JS, and later rewritten in Type\+Script.


\begin{DoxyItemize}
\item Supports casting and transforms
\item All object fields are optional by default
\item Missing promise schemas
\item Missing function schemas
\item Missing union \& intersection schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36570}{}\doxysubsubsubsection{\texorpdfstring{io-\/ts}{io-\/ts}}\label{README.md_autotoc_md36570}
\href{https://github.com/gcanti/io-ts}{\texttt{ https\+://github.\+com/gcanti/io-\/ts}}

io-\/ts is an excellent library by gcanti. The API of io-\/ts heavily inspired the design of Zod.

In our experience, io-\/ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-\/ts particularly hard to integrate into an existing codebase with a more procedural or object-\/oriented bias. For instance, consider how to define an object with optional properties in io-\/ts\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ t\ from\ "{}io-\/ts"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ A\ =\ t.type(\{}
\DoxyCodeLine{\ \ foo:\ t.string,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ B\ =\ t.partial(\{}
\DoxyCodeLine{\ \ bar:\ t.number,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ C\ =\ t.intersection([A,\ B]);}
\DoxyCodeLine{}
\DoxyCodeLine{type\ C\ =\ t.TypeOf<typeof\ C>;}
\DoxyCodeLine{//\ returns\ \{\ foo:\ string;\ bar?:\ number\ |\ undefined\ \}}

\end{DoxyCode}


You must define the required and optional props in separate object validators, pass the optionals through {\ttfamily t.\+partial} (which marks all properties as optional), then combine them with {\ttfamily t.\+intersection} .

Consider the equivalent in Zod\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ C\ =\ z.object(\{}
\DoxyCodeLine{\ \ foo:\ z.string(),}
\DoxyCodeLine{\ \ bar:\ z.number().optional(),}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{type\ C\ =\ z.infer<typeof\ C>;}
\DoxyCodeLine{//\ returns\ \{\ foo:\ string;\ bar?:\ number\ |\ undefined\ \}}

\end{DoxyCode}


This more declarative API makes schema definitions vastly more concise.

{\ttfamily io-\/ts} also requires the use of gcanti\textquotesingle{}s functional programming library {\ttfamily fp-\/ts} to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on {\ttfamily fp-\/ts} necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the {\ttfamily fp-\/ts} nomenclature to use the library.


\begin{DoxyItemize}
\item Supports codecs with serialization \& deserialization transforms
\item Supports branded types
\item Supports advanced functional programming, higher-\/kinded types, {\ttfamily fp-\/ts} compatibility
\item Missing object methods\+: (pick, omit, partial, deep\+Partial, merge, extend)
\item Missing nonempty arrays with proper typing ({\ttfamily \mbox{[}T, ...T\mbox{[}\mbox{]}\mbox{]}})
\item Missing promise schemas
\item Missing function schemas
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36571}{}\doxysubsubsubsection{\texorpdfstring{Runtypes}{Runtypes}}\label{README.md_autotoc_md36571}
\href{https://github.com/runtypes/runtypes}{\texttt{ https\+://github.\+com/runtypes/runtypes}}

Runtypes is focused on ergonomics, with good type inference support.


\begin{DoxyItemize}
\item Supports "{}pattern matching"{}\+: computed properties that distribute over unions
\item Supports branded types
\item Supports template literals
\item Supports conformance to predefined static types
\item Missing object methods\+: (deep\+Partial, merge)
\item Missing promise schemas
\item Missing error customization
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36572}{}\doxysubsubsubsection{\texorpdfstring{Ow}{Ow}}\label{README.md_autotoc_md36572}
\href{https://github.com/sindresorhus/ow}{\texttt{ https\+://github.\+com/sindresorhus/ow}}

Ow is focused on function input validation. It\textquotesingle{}s a library that makes it easy to express complicated assert statements, but it doesn\textquotesingle{}t let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-\/to-\/one mapping with Type\+Script\textquotesingle{}s type system, whereas ow lets you validate several highly-\/specific types out of the box (e.\+g. {\ttfamily int32\+Array} , see full list in their README).

If you want to validate function inputs, use function schemas in Zod! It\textquotesingle{}s a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-\/pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won\textquotesingle{}t be any unexpected data passed downstream.\hypertarget{README.md_autotoc_md36573}{}\doxysubsubsection{\texorpdfstring{Changelog}{Changelog}}\label{README.md_autotoc_md36573}
View the changelog at \doxylink{tests_2security_2node__modules_2_8pnpm_2axios_0d1_88_83_2node__modules_2axios_2_c_h_a_n_g_e_l_o_g_8md}{CHANGELOG.md} 