\doxysection{node\+\_\+modules/mlly Directory Reference}
\hypertarget{dir_55aa8b9f6ac988e4ba154d9fabd7dd88}{}\label{dir_55aa8b9f6ac988e4ba154d9fabd7dd88}\index{node\_modules/mlly Directory Reference@{node\_modules/mlly Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_abf09d3ea3c57abc03a5454579a09905}{node\+\_\+modules}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\href{https://npmjs.com/package/mlly}{\texttt{ }} \href{https://npmjs.com/package/mlly}{\texttt{ }} \href{https://codecov.io/gh/unjs/mlly}{\texttt{ }}

\begin{quote}
Missing \href{https://nodejs.org/api/esm.html}{\texttt{ ECMAScript module}} utils for Node.\+js \end{quote}


While ESM Modules are evolving in Node.\+js ecosystem, there are still many required features that are still experimental or missing or needed to support ESM. This package tries to fill in the gap.\hypertarget{README.md_autotoc_md24247}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{README.md_autotoc_md24247}
Install npm package\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ using\ yarn}
\DoxyCodeLine{yarn\ add\ mlly}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ using\ npm}
\DoxyCodeLine{npm\ install\ mlly}

\end{DoxyCode}


{\bfseries{Note\+:}} Node.\+js 14+ is recommended.

Import utils\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ ESM}
\DoxyCodeLine{import\ \{\}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ CommonJS}
\DoxyCodeLine{const\ \{\}\ =\ require("{}mlly"{});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24248}{}\doxysubsection{\texorpdfstring{Resolving ESM modules}{Resolving ESM modules}}\label{README.md_autotoc_md24248}
Several utilities to make ESM resolution easier\+:


\begin{DoxyItemize}
\item Respecting \href{https://nodejs.org/dist/latest-v14.x/docs/api/esm.html\#esm_resolver_algorithm}{\texttt{ ECMAScript Resolver algorithm}}
\item Exposed from Node.\+js implementation
\item Windows paths normalized
\item Supporting custom {\ttfamily extensions} and {\ttfamily /index} resolution
\item Supporting custom {\ttfamily conditions}
\item Support resolving from multiple paths or urls
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24249}{}\doxysubsubsection{\texorpdfstring{{\ttfamily resolve} / {\ttfamily resolve\+Sync}}{{\ttfamily resolve} / {\ttfamily resolve\+Sync}}}\label{README.md_autotoc_md24249}
Resolve a module by respecting \href{https://nodejs.org/dist/latest-v14.x/docs/api/esm.html\#esm_resolver_algorithm}{\texttt{ ECMAScript Resolver algorithm}} (using \href{https://github.com/wooorm/import-meta-resolve}{\texttt{ wooorm/import-\/meta-\/resolve}}).

Additionally supports resolving without extension and {\ttfamily /index} similar to Common\+JS.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ resolve,\ resolveSync\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ file:///home/user/project/module.mjs}
\DoxyCodeLine{console.log(await\ resolve("{}./module.mjs"{},\ \{\ url:\ import.meta.url\ \}));}

\end{DoxyCode}


{\bfseries{Resolve options\+:}}


\begin{DoxyItemize}
\item {\ttfamily url}\+: URL or string to resolve from (default is {\ttfamily pwd()})
\item {\ttfamily conditions}\+: Array of conditions used for resolution algorithm (default is `\mbox{[}\textquotesingle{}node', \textquotesingle{}import\textquotesingle{}\mbox{]}{\ttfamily ) -\/}extensions{\ttfamily \+: Array of additional extensions to check if import failed (default is}\mbox{[}\textquotesingle{}.mjs\textquotesingle{}, \textquotesingle{}.cjs\textquotesingle{}, \textquotesingle{}.js\textquotesingle{}, \textquotesingle{}.json\textquotesingle{}\mbox{]}\`{})
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24250}{}\doxysubsubsection{\texorpdfstring{{\ttfamily resolve\+Path} / {\ttfamily resolve\+Path\+Sync}}{{\ttfamily resolve\+Path} / {\ttfamily resolve\+Path\+Sync}}}\label{README.md_autotoc_md24250}
Similar to {\ttfamily resolve} but returns a path instead of URL using {\ttfamily file\+URLTo\+Path}.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ resolvePath,\ resolveSync\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ /home/user/project/module.mjs}
\DoxyCodeLine{console.log(await\ resolvePath("{}./module.mjs"{},\ \{\ url:\ import.meta.url\ \}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24251}{}\doxysubsubsection{\texorpdfstring{{\ttfamily create\+Resolve}}{{\ttfamily create\+Resolve}}}\label{README.md_autotoc_md24251}
Create a {\ttfamily resolve} function with defaults.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createResolve\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ \_resolve\ =\ createResolve(\{\ url:\ import.meta.url\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ file:///home/user/project/module.mjs}
\DoxyCodeLine{console.log(await\ \_resolve("{}./module.mjs"{}));}

\end{DoxyCode}


{\bfseries{Example\+:}} Ponyfill \href{https://nodejs.org/api/esm.html\#esm_import_meta_resolve_specifier_parent}{\texttt{ import.\+meta.\+resolve}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createResolve\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{import.meta.resolve\ =\ createResolve(\{\ url:\ import.meta.url\ \});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24252}{}\doxysubsubsection{\texorpdfstring{{\ttfamily resolve\+Imports}}{{\ttfamily resolve\+Imports}}}\label{README.md_autotoc_md24252}
Resolve all static and dynamic imports with relative paths to full resolved path.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ resolveImports\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ import\ foo\ from\ 'file:///home/user/project/bar.mjs'}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ await\ resolveImports(`import\ foo\ from\ './bar.mjs'`,\ \{\ url:\ import.meta.url\ \}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24253}{}\doxysubsection{\texorpdfstring{Syntax Analyzes}{Syntax Analyzes}}\label{README.md_autotoc_md24253}
\hypertarget{README.md_autotoc_md24254}{}\doxysubsubsection{\texorpdfstring{{\ttfamily is\+Valid\+Node\+Import}}{{\ttfamily is\+Valid\+Node\+Import}}}\label{README.md_autotoc_md24254}
Using various syntax detection and heuristics, this method can determine if import is a valid import or not to be imported using dynamic {\ttfamily import()} before hitting an error!

When result is {\ttfamily false}, we usually need a to create a Common\+JS require context or add specific rules to the bundler to transform dependency.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ isValidNodeImport\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ If\ returns\ true,\ we\ are\ safe\ to\ use\ \`{}import('some-\/lib')`}
\DoxyCodeLine{await\ isValidNodeImport("{}some-\/lib"{},\ \{\});}

\end{DoxyCode}


{\bfseries{Algorithm\+:}}


\begin{DoxyItemize}
\item Check import protocol -\/ If is {\ttfamily data\+:} return {\ttfamily true} (✅ valid) -\/ If is not {\ttfamily node\+:}, {\ttfamily file\+:} or {\ttfamily data\+:}, return {\ttfamily false} ( ❌ invalid)
\item Resolve full path of import using Node.\+js \href{https://nodejs.org/api/esm.html\#resolution-algorithm}{\texttt{ Resolution algorithm}}
\item Check full path extension
\begin{DoxyItemize}
\item If is {\ttfamily .mjs}, {\ttfamily .cjs}, {\ttfamily .node} or {\ttfamily .wasm}, return {\ttfamily true} (✅ valid)
\item If is not {\ttfamily .js}, return {\ttfamily false} (❌ invalid)
\item If is matching known mixed syntax ({\ttfamily .esm.\+js}, {\ttfamily .es.\+js}, etc) return {\ttfamily false} ( ❌ invalid)
\end{DoxyItemize}
\item Read closest {\ttfamily package.\+json} file to resolve path
\item If `type\+: \textquotesingle{}module'{\ttfamily field is set, return}true{\ttfamily (✅ valid)}
\item {\ttfamily Read source code of resolved path}
\item {\ttfamily Try to detect Common\+JS syntax usage
\begin{DoxyItemize}
\item If yes, return
\end{DoxyItemize}}true{\ttfamily (✅ valid)}
\item {\ttfamily Try to detect ESM syntax usage
\begin{DoxyItemize}
\item if yes, return
\end{DoxyItemize}}false\`{} ( ❌ invalid)
\end{DoxyItemize}

{\bfseries{Notes\+:}}


\begin{DoxyItemize}
\item There might be still edge cases algorithm cannot cover. It is designed with best-\/efforts.
\item This method also allows using dynamic import of Common\+JS libraries considering Node.\+js has \href{https://nodejs.org/api/esm.html\#interoperability-with-commonjs}{\texttt{ Interoperability with Common\+JS}}.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24255}{}\doxysubsubsection{\texorpdfstring{{\ttfamily has\+ESMSyntax}}{{\ttfamily has\+ESMSyntax}}}\label{README.md_autotoc_md24255}
Detect if code, has usage of ESM syntax (Static {\ttfamily import}, ESM {\ttfamily export} and {\ttfamily import.\+meta} usage)


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ hasESMSyntax\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{hasESMSyntax("{}export\ default\ foo\ =\ 123"{});\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24256}{}\doxysubsubsection{\texorpdfstring{{\ttfamily has\+CJSSyntax}}{{\ttfamily has\+CJSSyntax}}}\label{README.md_autotoc_md24256}
Detect if code, has usage of Common\+JS syntax ({\ttfamily exports}, {\ttfamily module.\+exports}, {\ttfamily require} and {\ttfamily global} usage)


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ hasCJSSyntax\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{hasCJSSyntax("{}export\ default\ foo\ =\ 123"{});\ //\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24257}{}\doxysubsubsection{\texorpdfstring{{\ttfamily detect\+Syntax}}{{\ttfamily detect\+Syntax}}}\label{README.md_autotoc_md24257}
Tests code against both CJS and ESM.

{\ttfamily is\+Mixed} indicates if both are detected! This is a common case with legacy packages exporting semi-\/compatible ESM syntax meant to be used by bundlers.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ detectSyntax\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ \{\ hasESM:\ true,\ hasCJS:\ true,\ isMixed:\ true\ \}}
\DoxyCodeLine{detectSyntax('export\ default\ require("{}lodash"{})');}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24258}{}\doxysubsection{\texorpdfstring{Common\+JS Context}{Common\+JS Context}}\label{README.md_autotoc_md24258}
\hypertarget{README.md_autotoc_md24259}{}\doxysubsubsection{\texorpdfstring{{\ttfamily create\+Common\+JS}}{{\ttfamily create\+Common\+JS}}}\label{README.md_autotoc_md24259}
This utility creates a compatible Common\+JS context that is missing in ECMAScript modules.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ createCommonJS\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ \{\ \_\_dirname,\ \_\_filename,\ require\ \}\ =\ createCommonJS(import.meta.url);}

\end{DoxyCode}


Note\+: {\ttfamily require} and {\ttfamily require.\+resolve} implementation are lazy functions. \href{https://nodejs.org/api/module.html\#module_module_createrequire_filename}{\texttt{ {\ttfamily create\+Require}}} will be called on first usage.\hypertarget{README.md_autotoc_md24260}{}\doxysubsection{\texorpdfstring{Import/\+Export Analyzes}{Import/\+Export Analyzes}}\label{README.md_autotoc_md24260}
Tools to quickly analyze ESM syntax and extract static {\ttfamily import}/{\ttfamily export}


\begin{DoxyItemize}
\item Super fast Regex based implementation
\item Handle most edge cases
\item Find all static ESM imports
\item Find all dynamic ESM imports
\item Parse static import statement
\item Find all named, declared and default exports
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24261}{}\doxysubsubsection{\texorpdfstring{{\ttfamily find\+Static\+Imports}}{{\ttfamily find\+Static\+Imports}}}\label{README.md_autotoc_md24261}
Find all static ESM imports.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ findStaticImports\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ findStaticImports(`}
\DoxyCodeLine{//\ Empty\ line}
\DoxyCodeLine{import\ foo,\ \{\ bar\ /*\ foo\ */\ \}\ from\ 'baz'}
\DoxyCodeLine{\`{}),}
\DoxyCodeLine{);}

\end{DoxyCode}


Outputs\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ type:\ "{}static"{},}
\DoxyCodeLine{\ \ \ \ imports:\ "{}foo,\ \{\ bar\ /*\ foo\ */\ \}\ "{},}
\DoxyCodeLine{\ \ \ \ specifier:\ "{}baz"{},}
\DoxyCodeLine{\ \ \ \ code:\ "{}import\ foo,\ \{\ bar\ /*\ foo\ */\ \}\ from\ 'baz'"{},}
\DoxyCodeLine{\ \ \ \ start:\ 15,}
\DoxyCodeLine{\ \ \ \ end:\ 55,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{];}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24262}{}\doxysubsubsection{\texorpdfstring{{\ttfamily parse\+Static\+Import}}{{\ttfamily parse\+Static\+Import}}}\label{README.md_autotoc_md24262}
Parse a dynamic ESM import statement previously matched by {\ttfamily find\+Static\+Imports}.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ findStaticImports,\ parseStaticImport\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ [match0]\ =\ findStaticImports(`import\ baz,\ \{\ x,\ y\ as\ z\ \}\ from\ 'baz'`);}
\DoxyCodeLine{console.log(parseStaticImport(match0));}

\end{DoxyCode}


Outputs\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'static',}
\DoxyCodeLine{\ \ imports:\ 'baz,\ \{\ x,\ y\ as\ z\ \}\ ',}
\DoxyCodeLine{\ \ specifier:\ 'baz',}
\DoxyCodeLine{\ \ code:\ "{}import\ baz,\ \{\ x,\ y\ as\ z\ \}\ from\ 'baz'"{},}
\DoxyCodeLine{\ \ start:\ 0,}
\DoxyCodeLine{\ \ end:\ 36,}
\DoxyCodeLine{\ \ defaultImport:\ 'baz',}
\DoxyCodeLine{\ \ namespacedImport:\ undefined,}
\DoxyCodeLine{\ \ namedImports:\ \{\ x:\ 'x',\ y:\ 'z'\ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24263}{}\doxysubsubsection{\texorpdfstring{{\ttfamily find\+Dynamic\+Imports}}{{\ttfamily find\+Dynamic\+Imports}}}\label{README.md_autotoc_md24263}
Find all dynamic ESM imports.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ findDynamicImports\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ findDynamicImports(`}
\DoxyCodeLine{const\ foo\ =\ await\ import('bar')}
\DoxyCodeLine{\`{}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24264}{}\doxysubsubsection{\texorpdfstring{{\ttfamily find\+Exports}}{{\ttfamily find\+Exports}}}\label{README.md_autotoc_md24264}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ findExports\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ findExports(`}
\DoxyCodeLine{export\ const\ foo\ =\ 'bar'}
\DoxyCodeLine{export\ \{\ bar,\ baz\ \}}
\DoxyCodeLine{export\ default\ something}
\DoxyCodeLine{\`{}),}
\DoxyCodeLine{);}

\end{DoxyCode}


Outputs\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ type:\ "{}declaration"{},}
\DoxyCodeLine{\ \ \ \ declaration:\ "{}const"{},}
\DoxyCodeLine{\ \ \ \ name:\ "{}foo"{},}
\DoxyCodeLine{\ \ \ \ code:\ "{}export\ const\ foo"{},}
\DoxyCodeLine{\ \ \ \ start:\ 1,}
\DoxyCodeLine{\ \ \ \ end:\ 17,}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ type:\ "{}named"{},}
\DoxyCodeLine{\ \ \ \ exports:\ "{}\ bar,\ baz\ "{},}
\DoxyCodeLine{\ \ \ \ code:\ "{}export\ \{\ bar,\ baz\ \}"{},}
\DoxyCodeLine{\ \ \ \ start:\ 26,}
\DoxyCodeLine{\ \ \ \ end:\ 45,}
\DoxyCodeLine{\ \ \ \ names:\ ["{}bar"{},\ "{}baz"{}],}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \{\ type:\ "{}default"{},\ code:\ "{}export\ default\ "{},\ start:\ 46,\ end:\ 61\ \},}
\DoxyCodeLine{];}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24265}{}\doxysubsubsection{\texorpdfstring{{\ttfamily find\+Export\+Names}}{{\ttfamily find\+Export\+Names}}}\label{README.md_autotoc_md24265}
Same as {\ttfamily find\+Exports} but returns array of export names.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ findExportNames\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ [\ "{}foo"{},\ "{}bar"{},\ "{}baz"{},\ "{}default"{}\ ]}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ findExportNames(`}
\DoxyCodeLine{export\ const\ foo\ =\ 'bar'}
\DoxyCodeLine{export\ \{\ bar,\ baz\ \}}
\DoxyCodeLine{export\ default\ something}
\DoxyCodeLine{\`{}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24266}{}\doxysubsection{\texorpdfstring{{\ttfamily resolve\+Module\+Export\+Names}}{{\ttfamily resolve\+Module\+Export\+Names}}}\label{README.md_autotoc_md24266}
Resolves module and reads its contents to extract possible export names using static analyzes.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ resolveModuleExportNames\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ["{}basename"{},\ "{}dirname"{},\ ...\ ]}
\DoxyCodeLine{console.log(await\ resolveModuleExportNames("{}mlly"{}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24267}{}\doxysubsection{\texorpdfstring{Evaluating Modules}{Evaluating Modules}}\label{README.md_autotoc_md24267}
Set of utilities to evaluate ESM modules using {\ttfamily data\+:} imports


\begin{DoxyItemize}
\item Automatic import rewrite to resolved path using static analyzes
\item Allow bypass ESM Cache
\item Stack-\/trace support
\item {\ttfamily .json} loader
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24268}{}\doxysubsubsection{\texorpdfstring{{\ttfamily eval\+Module}}{{\ttfamily eval\+Module}}}\label{README.md_autotoc_md24268}
Transform and evaluates module code using dynamic imports.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ evalModule\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{await\ evalModule(`console.log("{}Hello\ World!"{})`);}
\DoxyCodeLine{}
\DoxyCodeLine{await\ evalModule(}
\DoxyCodeLine{\ \ \`{}}
\DoxyCodeLine{\ \ import\ \{\ reverse\ \}\ from\ './utils.mjs'}
\DoxyCodeLine{\ \ console.log(reverse('!emosewa\ si\ sj'))}
\DoxyCodeLine{\`{},}
\DoxyCodeLine{\ \ \{\ url:\ import.meta.url\ \},}
\DoxyCodeLine{);}

\end{DoxyCode}


{\bfseries{Options\+:}}


\begin{DoxyItemize}
\item all {\ttfamily resolve} options
\item {\ttfamily url}\+: File URL
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24269}{}\doxysubsubsection{\texorpdfstring{{\ttfamily load\+Module}}{{\ttfamily load\+Module}}}\label{README.md_autotoc_md24269}
Dynamically loads a module by evaluating source code.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ loadModule\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{await\ loadModule("{}./hello.mjs"{},\ \{\ url:\ import.meta.url\ \});}

\end{DoxyCode}


Options are same as {\ttfamily eval\+Module}.\hypertarget{README.md_autotoc_md24270}{}\doxysubsubsection{\texorpdfstring{{\ttfamily transform\+Module}}{{\ttfamily transform\+Module}}}\label{README.md_autotoc_md24270}

\begin{DoxyItemize}
\item Resolves all relative imports will be resolved
\item All usages of {\ttfamily import.\+meta.\+url} will be replaced with {\ttfamily url} or {\ttfamily from} option
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ transformModule\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{console.log(transformModule(`console.log(import.meta.url)`),\ \{}
\DoxyCodeLine{\ \ url:\ "{}test.mjs"{},}
\DoxyCodeLine{\});}

\end{DoxyCode}


Options are same as {\ttfamily eval\+Module}.\hypertarget{README.md_autotoc_md24271}{}\doxysubsection{\texorpdfstring{Other Utils}{Other Utils}}\label{README.md_autotoc_md24271}
\hypertarget{README.md_autotoc_md24272}{}\doxysubsubsection{\texorpdfstring{{\ttfamily file\+URLTo\+Path}}{{\ttfamily file\+URLTo\+Path}}}\label{README.md_autotoc_md24272}
Similar to \href{https://nodejs.org/api/url.html\#url_url_fileurltopath_url}{\texttt{ url.\+file\+URLTo\+Path}} but also converts windows backslash {\ttfamily \textbackslash{}} to unix slash {\ttfamily /} and handles if input is already a path.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ fileURLToPath\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ /foo/bar.js}
\DoxyCodeLine{console.log(fileURLToPath("{}file:///foo/bar.js"{}));}
\DoxyCodeLine{}
\DoxyCodeLine{//\ C:/path}
\DoxyCodeLine{console.log(fileURLToPath("{}file:///C:/path/"{}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24273}{}\doxysubsubsection{\texorpdfstring{{\ttfamily path\+To\+File\+URL}}{{\ttfamily path\+To\+File\+URL}}}\label{README.md_autotoc_md24273}
Similar to \href{https://nodejs.org/api/url.html\#urlpathtofileurlpath}{\texttt{ url.\+path\+To\+File\+URL}} but also handles {\ttfamily URL} input and returns a {\bfseries{string}} with {\ttfamily \href{file://}{\texttt{ file\+://}}} protocol.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ pathToFileURL\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ /foo/bar.js}
\DoxyCodeLine{console.log(pathToFileURL("{}foo/bar.js"{}));}
\DoxyCodeLine{}
\DoxyCodeLine{//\ C:/path}
\DoxyCodeLine{console.log(pathToFileURL("{}C:\(\backslash\)\(\backslash\)path"{}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24274}{}\doxysubsubsection{\texorpdfstring{{\ttfamily normalizeid}}{{\ttfamily normalizeid}}}\label{README.md_autotoc_md24274}
Ensures id has either of {\ttfamily node\+:}, {\ttfamily data\+:}, {\ttfamily http\+:}, {\ttfamily https\+:} or {\ttfamily file\+:} protocols.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ ensureProtocol\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ file:///foo/bar.js}
\DoxyCodeLine{console.log(normalizeid("{}/foo/bar.js"{}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24275}{}\doxysubsubsection{\texorpdfstring{{\ttfamily load\+URL}}{{\ttfamily load\+URL}}}\label{README.md_autotoc_md24275}
Read source contents of a URL. (currently only file protocol supported)


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ resolve,\ loadURL\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ url\ =\ await\ resolve("{}./index.mjs"{},\ \{\ url:\ import.meta.url\ \});}
\DoxyCodeLine{console.log(await\ loadURL(url));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24276}{}\doxysubsubsection{\texorpdfstring{{\ttfamily to\+Data\+URL}}{{\ttfamily to\+Data\+URL}}}\label{README.md_autotoc_md24276}
Convert code to \href{https://nodejs.org/api/esm.html\#esm_data_imports}{\texttt{ {\ttfamily data\+:}}} URL using base64 encoding.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ toDataURL\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ toDataURL(`}
\DoxyCodeLine{\ \ //\ This\ is\ an\ example}
\DoxyCodeLine{\ \ console.log('Hello\ world')}
\DoxyCodeLine{\`{}),}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24277}{}\doxysubsubsection{\texorpdfstring{{\ttfamily interop\+Default}}{{\ttfamily interop\+Default}}}\label{README.md_autotoc_md24277}
Return the default export of a module at the top-\/level, alongside any other named exports.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Assuming\ the\ shape\ \{\ default:\ \{\ foo:\ 'bar'\ \},\ baz:\ 'qux'\ \}}
\DoxyCodeLine{import\ myModule\ from\ "{}my-\/module"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Returns\ \{\ foo:\ 'bar',\ baz:\ 'qux'\ \}}
\DoxyCodeLine{console.log(interopDefault(myModule));}

\end{DoxyCode}


{\bfseries{Options\+:}}


\begin{DoxyItemize}
\item {\ttfamily prefer\+Namespace}\+: In case that {\ttfamily default} value exists but is not extendable (when is string for example), return input as-\/is (default is {\ttfamily false}, meaning {\ttfamily default}\textquotesingle{}s value is prefered even if cannot be extended)
\end{DoxyItemize}\hypertarget{README.md_autotoc_md24278}{}\doxysubsubsection{\texorpdfstring{{\ttfamily sanitize\+URIComponent}}{{\ttfamily sanitize\+URIComponent}}}\label{README.md_autotoc_md24278}
Replace reserved characters from a segment of URI to make it compatible with \href{https://datatracker.ietf.org/doc/html/rfc2396}{\texttt{ rfc2396}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ sanitizeURIComponent\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ foo\_bar}
\DoxyCodeLine{console.log(sanitizeURIComponent(`foo:bar`));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24279}{}\doxysubsubsection{\texorpdfstring{{\ttfamily sanitize\+File\+Path}}{{\ttfamily sanitize\+File\+Path}}}\label{README.md_autotoc_md24279}
Sanitize each path of a file name or path with {\ttfamily sanitize\+URIComponent} for URI compatibility.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ sanitizeFilePath\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ C:/te\_st/\_...slug\_.jsx'}
\DoxyCodeLine{console.log(sanitizeFilePath("{}C:\(\backslash\)\(\backslash\)te\#st\(\backslash\)\(\backslash\)[...slug].jsx"{}));}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24280}{}\doxysubsubsection{\texorpdfstring{{\ttfamily parse\+Node\+Module\+Path}}{{\ttfamily parse\+Node\+Module\+Path}}}\label{README.md_autotoc_md24280}
Parses an absolute file path in {\ttfamily node\+\_\+modules} to three segments\+:


\begin{DoxyItemize}
\item {\ttfamily dir}\+: Path to main directory of package
\item {\ttfamily name}\+: Package name
\item {\ttfamily subpath}\+: The optional package subpath
\end{DoxyItemize}

It returns an empty object (with partial keys) if parsing fails.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ parseNodeModulePath\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ dir:\ "{}/src/a/node\_modules/"{}}
\DoxyCodeLine{//\ name:\ "{}lib"{}}
\DoxyCodeLine{//\ subpath:\ "{}./dist/index.mjs"{}}
\DoxyCodeLine{const\ \{\ dir,\ name,\ subpath\ \}\ =\ parseNodeModulePath(}
\DoxyCodeLine{\ \ "{}/src/a/node\_modules/lib/dist/index.mjs"{},}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24281}{}\doxysubsubsection{\texorpdfstring{{\ttfamily lookup\+Node\+Module\+Subpath}}{{\ttfamily lookup\+Node\+Module\+Subpath}}}\label{README.md_autotoc_md24281}
Parses an absolute file path in {\ttfamily node\+\_\+modules} and tries to reverse lookup (or guess) the original package exports subpath for it.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ lookupNodeModuleSubpath\ \}\ from\ "{}mlly"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ subpath:\ "{}./utils"{}}
\DoxyCodeLine{const\ subpath\ =\ lookupNodeModuleSubpath(}
\DoxyCodeLine{\ \ "{}/src/a/node\_modules/lib/dist/utils.mjs"{},}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md24282}{}\doxysubsection{\texorpdfstring{License}{License}}\label{README.md_autotoc_md24282}
\href{./LICENSE}{\texttt{ MIT}} -\/ Made with 💛 