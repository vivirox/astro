\doxysection{node\+\_\+modules/regexp-\/tree Directory Reference}
\hypertarget{dir_b3e7c26d34651291291696f82097f19f}{}\label{dir_b3e7c26d34651291291696f82097f19f}\index{node\_modules/regexp-\/tree Directory Reference@{node\_modules/regexp-\/tree Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://travis-ci.org/DmitrySoshnikov/regexp-tree}{\texttt{ }} \href{https://badge.fury.io/js/regexp-tree}{\texttt{ }} \href{https://www.npmjs.com/package/regexp-tree}{\texttt{ }}

Regular expressions processor in Java\+Script

TL;DR\+: {\bfseries{Reg\+Exp Tree}} is a {\itshape regular expressions processor}, which includes {\itshape parser}, {\itshape traversal}, {\itshape transformer}, {\itshape optimizer}, and {\itshape interpreter} APIs.

You can get an overview of the tool in \href{https://medium.com/@DmitrySoshnikov/regexp-tree-a-regular-expressions-parser-with-a-simple-ast-format-bcd4d5580df6}{\texttt{ this article}}.\hypertarget{README.md_autotoc_md28568}{}\doxysubsubsection{\texorpdfstring{Table of Contents}{Table of Contents}}\label{README.md_autotoc_md28568}

\begin{DoxyItemize}
\item \doxylink{README.md_installation}{Installation}
\item Development
\item Usage as a CLI
\item Usage from Node
\item Capturing locations
\item Parsing options
\item Using traversal API
\item Using transform API
\begin{DoxyItemize}
\item Transform plugins
\end{DoxyItemize}
\item Using generator API
\item Using optimizer API
\begin{DoxyItemize}
\item Optimizer ESLint plugin
\end{DoxyItemize}
\item Using compat-\/transpiler API
\begin{DoxyItemize}
\item Compat-\/transpiler Babel plugin
\end{DoxyItemize}
\item Reg\+Exp extensions
\begin{DoxyItemize}
\item Reg\+Exp extensions Babel plugin
\end{DoxyItemize}
\item Creating Reg\+Exp objects
\item Executing regexes
\item Using interpreter API
\begin{DoxyItemize}
\item Printing NFA/\+DFA tables
\end{DoxyItemize}
\item AST nodes specification
\end{DoxyItemize}\hypertarget{README.md_autotoc_md28569}{}\doxysubsubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md28569}
The parser can be installed as an \href{https://www.npmjs.com/package/regexp-tree}{\texttt{ npm module}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ -\/g\ regexp-\/tree}

\end{DoxyCode}


You can also \href{https://astexplorer.net/\#/gist/4ea2b52f0e546af6fb14f9b2f5671c1c/39b55944da3e5782396ffa1fea3ba68d126cd394}{\texttt{ try it online}} using {\itshape AST Explorer}.\hypertarget{README.md_autotoc_md28570}{}\doxysubsubsection{\texorpdfstring{Development}{Development}}\label{README.md_autotoc_md28570}

\begin{DoxyEnumerate}
\item Fork \href{https://github.com/DmitrySoshnikov/regexp-tree}{\texttt{ https\+://github.\+com/\+Dmitry\+Soshnikov/regexp-\/tree}} repo
\item If there is an actual issue from the \href{https://github.com/DmitrySoshnikov/regexp-tree/issues}{\texttt{ issues}} list you\textquotesingle{}d like to work on, feel free to assign it yourself, or comment on it to avoid collisions (open a new issue if needed)
\item Make your changes
\item Make sure {\ttfamily npm test} still passes (add new tests if needed)
\item Submit a PR
\end{DoxyEnumerate}

The {\itshape regexp-\/tree} parser is implemented as an automatic LR parser using \href{https://www.npmjs.com/package/syntax-cli}{\texttt{ Syntax}} tool. The parser module is generated from the \href{https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/parser/regexp.bnf}{\texttt{ regexp grammar}}, which is based on the regular expressions grammar used in ECMAScript.

For development from the github repository, run {\ttfamily build} command to generate the parser module, and transpile JS code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git\ clone\ https://github.com/<your-\/github-\/account>/regexp-\/tree.git}
\DoxyCodeLine{cd\ regexp-\/tree}
\DoxyCodeLine{npm\ install}
\DoxyCodeLine{npm\ run\ build}

\end{DoxyCode}


\begin{quote}
NOTE\+: JS code transpilation is used to support older versions of Node. For faster development cycle you can use {\ttfamily npm run watch} command, which continuously transpiles JS code. \end{quote}
\hypertarget{README.md_autotoc_md28571}{}\doxysubsubsection{\texorpdfstring{Usage as a CLI}{Usage as a CLI}}\label{README.md_autotoc_md28571}
{\bfseries{Note\+:}} the CLI is exposed as its own \href{https://www.npmjs.com/package/regexp-tree-cli}{\texttt{ regexp-\/tree-\/cli}} module.

Check the options available from CLI\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regexp-\/tree-\/cli\ -\/-\/help}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{Usage:\ regexp-\/tree-\/cli\ [options]}
\DoxyCodeLine{}
\DoxyCodeLine{Options:}
\DoxyCodeLine{\ \ \ -\/e,\ -\/-\/expression\ \ \ A\ regular\ expression\ to\ be\ parsed}
\DoxyCodeLine{\ \ \ -\/l,\ -\/-\/loc\ \ \ \ \ \ \ \ \ \ Whether\ to\ capture\ AST\ node\ locations}
\DoxyCodeLine{\ \ \ -\/o,\ -\/-\/optimize\ \ \ \ \ Applies\ optimizer\ on\ the\ passed\ expression}
\DoxyCodeLine{\ \ \ -\/c,\ -\/-\/compat\ \ \ \ \ \ \ Applies\ compat-\/transpiler\ on\ the\ passed\ expression}
\DoxyCodeLine{\ \ \ -\/t,\ -\/-\/table\ \ \ \ \ \ \ \ Print\ NFA/DFA\ transition\ tables\ (nfa/dfa/all)}

\end{DoxyCode}


To parse a regular expression, pass {\ttfamily -\/e} option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regexp-\/tree-\/cli\ -\/e\ '/a|b/i'}

\end{DoxyCode}


Which produces an AST node corresponding to this regular expression\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'RegExp',}
\DoxyCodeLine{\ \ body:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Disjunction',}
\DoxyCodeLine{\ \ \ \ left:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ right:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ flags:\ 'i',}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
NOTE\+: the format of a regexp is {\ttfamily / Body / Optional\+Flags}. \end{quote}
\hypertarget{README.md_autotoc_md28572}{}\doxysubsubsection{\texorpdfstring{Usage from Node}{Usage from Node}}\label{README.md_autotoc_md28572}
The parser can also be used as a Node module\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(regexpTree.parse(/a|b/i));\ //\ RegExp\ AST}

\end{DoxyCode}


Note, {\itshape regexp-\/tree} supports parsing regexes from strings, and also from actual {\ttfamily Reg\+Exp} objects (in general -- from any object which can be coerced to a string). If some feature is not implemented yet in an actual Java\+Script Reg\+Exp, it should be passed as a string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Pass\ an\ actual\ JS\ RegExp\ object.}
\DoxyCodeLine{regexpTree.parse(/a|b/i);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Pass\ a\ string,\ since\ \`{}s`\ flag\ may\ not\ be\ supported\ in\ older\ versions.}
\DoxyCodeLine{regexpTree.parse('/./s');}

\end{DoxyCode}


Also note, that in string-\/mode, escaping is done using two slashes {\ttfamily \textbackslash{}\textbackslash{}} per Java\+Script\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ As\ an\ actual\ regexp.}
\DoxyCodeLine{regexpTree.parse(/\(\backslash\)n/);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ As\ a\ string.}
\DoxyCodeLine{regexpTree.parse('/\(\backslash\)\(\backslash\)n/');}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28573}{}\doxysubsubsection{\texorpdfstring{Capturing locations}{Capturing locations}}\label{README.md_autotoc_md28573}
For source code transformation tools it might be useful also to capture {\itshape locations} of the AST nodes. From the command line it\textquotesingle{}s controlled via the {\ttfamily -\/l} option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regexp-\/tree-\/cli\ -\/e\ '/ab/'\ -\/l}

\end{DoxyCode}


This attaches {\ttfamily loc} object to each AST node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'RegExp',}
\DoxyCodeLine{\ \ body:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ \ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 97,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ loc:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ start:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ column:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ offset:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ end:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ column:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ offset:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 98,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ loc:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ start:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ column:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ offset:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ end:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ column:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ offset:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ ],}
\DoxyCodeLine{\ \ \ \ loc:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ start:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ column:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ offset:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ end:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ column:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ offset:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ flags:\ '',}
\DoxyCodeLine{\ \ loc:\ \{}
\DoxyCodeLine{\ \ \ \ start:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ column:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ offset:\ 0,}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ end:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ line:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ column:\ 4,}
\DoxyCodeLine{\ \ \ \ \ \ offset:\ 4,}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


From Node it\textquotesingle{}s controlled via {\ttfamily set\+Options} method exposed on the parser\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ parsed\ =\ regexpTree}
\DoxyCodeLine{\ \ .parser}
\DoxyCodeLine{\ \ .setOptions(\{captureLocations:\ true\})}
\DoxyCodeLine{\ \ .parse(/a|b/);}

\end{DoxyCode}


The {\ttfamily set\+Options} method sets global options, which are preserved between calls. It is also possible to provide options per a single {\ttfamily parse} call, which might be more preferred\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ parsed\ =\ regexpTree.parse(/a|b/,\ \{}
\DoxyCodeLine{\ \ captureLocations:\ true,}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28574}{}\doxysubsubsection{\texorpdfstring{Parsing options}{Parsing options}}\label{README.md_autotoc_md28574}
The parser supports several options which can be set globally via the {\ttfamily set\+Options} method on the parser, or by passing them with each {\ttfamily parse} method invocation.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ parsed\ =\ regexpTree.parse(/a|b/,\ \{}
\DoxyCodeLine{\ \ allowGroupNameDuplicates:\ true,}
\DoxyCodeLine{\});}

\end{DoxyCode}


The following options are supported\+:


\begin{DoxyItemize}
\item {\ttfamily capture\+Locations\+: boolean} -- whether to capture AST node locations ({\ttfamily false} by default)
\item {\ttfamily allow\+Group\+Name\+Duplicates\+: boolean} -- whether to skip duplicates check of the named capturing groups
\end{DoxyItemize}

Set {\ttfamily allow\+Group\+Name\+Duplicates} would make the following expression possible\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/}
\DoxyCodeLine{\ \ \#\ YYY-\/MM-\/DD\ date\ format:}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?<year>\ \ \(\backslash\)d\{4\})\ -\/}
\DoxyCodeLine{\ \ (?<month>\ \(\backslash\)d\{2\})\ -\/}
\DoxyCodeLine{\ \ (?<day>\ \ \ \(\backslash\)d\{2\})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ |}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ DD.MM.YYY\ date\ format}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?<day>\ \ \ \(\backslash\)d\{2\})\ .}
\DoxyCodeLine{\ \ (?<month>\ \(\backslash\)d\{2\})\ .}
\DoxyCodeLine{\ \ (?<year>\ \ \(\backslash\)d\{4\})}
\DoxyCodeLine{}
\DoxyCodeLine{/x}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28575}{}\doxysubsubsection{\texorpdfstring{Using traversal API}{Using traversal API}}\label{README.md_autotoc_md28575}
The \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/traverse}{\texttt{ traverse}} module allows handling needed AST nodes using the {\itshape visitor} pattern. In Node the module is exposed as the {\ttfamily regexp\+Tree.\+traverse} method. Handlers receive an instance of the \href{https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md\#nodepath-class}{\texttt{ Node\+Path}} class, which encapsulates {\ttfamily node} itself, its {\ttfamily parent} node, {\ttfamily property}, and {\ttfamily index} (in case the node is part of a collection).

Visiting a node follows this algorithm\+:
\begin{DoxyItemize}
\item call {\ttfamily pre} handler.
\item recurse into node\textquotesingle{}s children.
\item call {\ttfamily post} handler.
\end{DoxyItemize}

For each node type of interest, you can provide either\+:
\begin{DoxyItemize}
\item a function ({\ttfamily pre}).
\item an object with members {\ttfamily pre} and {\ttfamily post}.
\end{DoxyItemize}

You can also provide a {\ttfamily \texorpdfstring{$\ast$}{*}} handler which will be executed on every node.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Get\ AST.}
\DoxyCodeLine{const\ ast\ =\ regexpTree.parse('/[a-\/z]\{1,\}/');}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Traverse\ AST\ nodes.}
\DoxyCodeLine{regexpTree.traverse(ast,\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Visit\ every\ node\ before\ any\ type-\/specific\ handlers.}
\DoxyCodeLine{\ \ '*':\ function(\{node\})\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Handle\ "{}Quantifier"{}\ node\ type.}
\DoxyCodeLine{\ \ Quantifier(\{node\})\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Handle\ "{}Char"{}\ node\ type,\ before\ and\ after.}
\DoxyCodeLine{\ \ Char:\ \{}
\DoxyCodeLine{\ \ \ \ pre(\{node\})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ post(\{node\})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Generate\ the\ regexp.}
\DoxyCodeLine{const\ re\ =\ regexpTree.generate(ast);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(re);\ //\ '/[a-\/z]+/'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28576}{}\doxysubsubsection{\texorpdfstring{Using transform API}{Using transform API}}\label{README.md_autotoc_md28576}
\begin{quote}
NOTE\+: you can play with transformation APIs, and write actual transforms for quick tests in AST Explorer. See \href{http://astexplorer.net/\#/gist/d293d22742b42cd1f7ee7b7e5dc6f697/39b0aabc42fb6fb106b9e368341d3300098f08c0}{\texttt{ this example}}. \end{quote}


While traverse module provides basic traversal API, which can be used for any purposes of AST handling, {\itshape transform} module focuses mainly on {\itshape transformation} of regular expressions.

It accepts a regular expressions in different formats (string, an actual {\ttfamily Reg\+Exp} object, or an AST), applies a set of transformations, and retuns an instance of \href{https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/transform/README.md\#transformresult}{\texttt{ Transform\+Result}}. Handles receive as a parameter the same \href{https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md\#nodepath-class}{\texttt{ Node\+Path}} object used in traverse.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Handle\ nodes.}
\DoxyCodeLine{const\ re\ =\ regexpTree.transform('/[a-\/z]\{1,\}/i',\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Handle\ "{}Quantifier"{}\ node\ type,}
\DoxyCodeLine{\ \ \ *\ transforming\ \`{}\{1,\}`\ quantifier\ to\ \`{}+`.}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ Quantifier(path)\ \{}
\DoxyCodeLine{\ \ \ \ const\ \{node\}\ =\ path;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ \{1,\}\ -\/>\ +}
\DoxyCodeLine{\ \ \ \ if\ (}
\DoxyCodeLine{\ \ \ \ \ \ node.kind\ ===\ 'Range'\ \&\&}
\DoxyCodeLine{\ \ \ \ \ \ node.from\ ===\ 1\ \&\&}
\DoxyCodeLine{\ \ \ \ \ \ !node.to}
\DoxyCodeLine{\ \ \ \ )\ \{}
\DoxyCodeLine{\ \ \ \ \ \ path.replace(\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ '+',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ greedy:\ node.greedy,}
\DoxyCodeLine{\ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(re.toString());\ //\ '/[a-\/z]+/i'}
\DoxyCodeLine{console.log(re.toRegExp());\ //\ /[a-\/z]+/i}
\DoxyCodeLine{console.log(re.getAST());\ //\ AST\ for\ /[a-\/z]+/i}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28577}{}\doxysubsubsubsection{\texorpdfstring{Transform plugins}{Transform plugins}}\label{README.md_autotoc_md28577}
A {\itshape transformation plugin} is a module which exports a {\itshape transformation handler}. We have seen above how we can pass a handler object directly to the {\ttfamily regexp\+Tree.\+transform} method, here we extract it into a separate module, so it can be implemented and shared independently\+:

Example of a plugin\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ file:\ ./regexp-\/tree-\/a-\/to-\/b-\/transform.js}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{/**}
\DoxyCodeLine{\ *\ This\ plugin\ replaces\ chars\ 'a'\ with\ chars\ 'b'.}
\DoxyCodeLine{\ */}
\DoxyCodeLine{module.exports\ =\ \{}
\DoxyCodeLine{\ \ Char(\{node\})\ \{}
\DoxyCodeLine{\ \ \ \ if\ (node.kind\ ===\ 'simple'\ \&\&\ node.value\ ===\ 'a')\ \{}
\DoxyCodeLine{\ \ \ \ \ \ node.value\ =\ 'b';}
\DoxyCodeLine{\ \ \ \ \ \ node.symbol\ =\ 'b';}
\DoxyCodeLine{\ \ \ \ \ \ node.codePoint\ =\ 98;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\};}

\end{DoxyCode}


Once we have this plugin ready, we can require it, and pass to the {\ttfamily transform} function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{const\ plugin\ =\ require('./regexp-\/tree-\/a-\/to-\/b-\/transform');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ regexpTree.transform(/(a|c)a+[a-\/z]/,\ plugin);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(re.toRegExp());\ //\ /(b|c)b+[b-\/z]/}

\end{DoxyCode}


\begin{quote}
NOTE\+: we can also pass a {\itshape list of plugins} to the {\ttfamily regexp\+Tree.\+transform}. In this case the plugins are applied in one pass in order. Another approach is to run several sequential calls to {\ttfamily transform}, setting up a pipeline, when a transformed AST is passed further to another plugin, etc. \end{quote}


You can see other examples of transform plugins in the \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer/transforms}{\texttt{ optimizer/transforms}} or in the \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler/transforms}{\texttt{ compat-\/transpiler/transforms}} directories.\hypertarget{README.md_autotoc_md28578}{}\doxysubsubsection{\texorpdfstring{Using generator API}{Using generator API}}\label{README.md_autotoc_md28578}
The \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/generator}{\texttt{ generator}} module generates regular expressions from corresponding AST nodes. In Node the module is exposed as {\ttfamily regexp\+Tree.\+generate} method.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ regexpTree.generate(\{}
\DoxyCodeLine{\ \ type:\ 'RegExp',}
\DoxyCodeLine{\ \ body:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ flags:\ 'i',}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(re);\ //\ '/a/i'}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28579}{}\doxysubsubsection{\texorpdfstring{Using optimizer API}{Using optimizer API}}\label{README.md_autotoc_md28579}
\href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer}{\texttt{ Optimizer}} transforms your regexp into an {\itshape optimized} version, replacing some sub-\/expressions with their idiomatic patterns. This might be good for different kinds of minifiers, as well as for regexp machines.

\begin{quote}
NOTE\+: the Optimizer is implemented as a set of {\itshape regexp-\/tree} plugins. \end{quote}


Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ originalRe\ =\ /[a-\/zA-\/Z\_0-\/9][A-\/Z\_\(\backslash\)da-\/z]*\(\backslash\)e\{1,\}/;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ optimizedRe\ =\ regexpTree}
\DoxyCodeLine{\ \ .optimize(originalRe)}
\DoxyCodeLine{\ \ .toRegExp();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(optimizedRe);\ //\ /\(\backslash\)w+e+/}

\end{DoxyCode}


From CLI the optimizer is available via {\ttfamily -\/-\/optimize} ({\ttfamily -\/o}) option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regexp-\/tree-\/cli\ -\/e\ '/[a-\/zA-\/Z\_0-\/9][A-\/Z\_\(\backslash\)da-\/z]*\(\backslash\)e\{1,\}/'\ -\/o}

\end{DoxyCode}


Result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Optimized:\ /\(\backslash\)w+e+/}

\end{DoxyCode}


See the \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer}{\texttt{ optimizer README}} for more details.\hypertarget{README.md_autotoc_md28580}{}\doxysubsubsubsection{\texorpdfstring{Optimizer ESLint plugin}{Optimizer ESLint plugin}}\label{README.md_autotoc_md28580}
The \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer}{\texttt{ optimizer}} module is also available as an {\itshape ESLint plugin}, which can be installed at\+: \href{https://www.npmjs.com/package/eslint-plugin-optimize-regex}{\texttt{ eslint-\/plugin-\/optimize-\/regex}}.\hypertarget{README.md_autotoc_md28581}{}\doxysubsubsection{\texorpdfstring{Using compat-\/transpiler API}{Using compat-\/transpiler API}}\label{README.md_autotoc_md28581}
The \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler}{\texttt{ compat-\/transpiler}} module translates your regexp in new format or in new syntax, into an equivalent regexp in a legacy representation, so it can be used in engines which don\textquotesingle{}t yet implement the new syntax.

\begin{quote}
NOTE\+: the compat-\/transpiler is implemented as a set of {\itshape regexp-\/tree} plugins. \end{quote}


Example, "{}dot\+All"{} {\ttfamily s} flag\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/./s}

\end{DoxyCode}


Is translated into\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/[\(\backslash\)0-\/\(\backslash\)uFFFF]/}

\end{DoxyCode}


Or named capturing groups\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/(?<value>a)\(\backslash\)k<value>\(\backslash\)1/}

\end{DoxyCode}


Becomes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/(a)\(\backslash\)1\(\backslash\)1/}

\end{DoxyCode}


To use the API from Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Using\ new\ syntax.}
\DoxyCodeLine{const\ originalRe\ =\ '/(?<all>.)\(\backslash\)\(\backslash\)k<all>/s';}
\DoxyCodeLine{}
\DoxyCodeLine{//\ For\ legacy\ engines.}
\DoxyCodeLine{const\ compatTranspiledRe\ =\ regexpTree}
\DoxyCodeLine{\ \ .compatTranspile(originalRe)}
\DoxyCodeLine{\ \ .toRegExp();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(compatTranspiledRe);\ //\ /([\(\backslash\)0-\/\(\backslash\)uFFFF])\(\backslash\)1/}

\end{DoxyCode}


From CLI the compat-\/transpiler is available via {\ttfamily -\/-\/compat} ({\ttfamily -\/c}) option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{regexp-\/tree-\/cli\ -\/e\ '/(?<all>.)\(\backslash\)k<all>/s'\ -\/c}

\end{DoxyCode}


Result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Compat:\ /([\(\backslash\)0-\/\(\backslash\)uFFFF])\(\backslash\)1/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28582}{}\doxysubsubsubsection{\texorpdfstring{Compat-\/transpiler Babel plugin}{Compat-\/transpiler Babel plugin}}\label{README.md_autotoc_md28582}
The \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler}{\texttt{ compat-\/transpiler}} module is also available as a {\itshape Babel plugin}, which can be installed at\+: \href{https://www.npmjs.com/package/babel-plugin-transform-modern-regexp}{\texttt{ babel-\/plugin-\/transform-\/modern-\/regexp}}.

Note, the plugin also includes extended regexp features.\hypertarget{README.md_autotoc_md28583}{}\doxysubsubsection{\texorpdfstring{Reg\+Exp extensions}{Reg\+Exp extensions}}\label{README.md_autotoc_md28583}
Some of the {\itshape non-\/standard} feature are also supported by {\itshape regexp-\/tree}.

\begin{quote}
NOTE\+: {\itshape "{}non-\/standard"{}} means specifically ECMAScript standard, since in other regexp egnines, e.\+g. PCRE, Python, etc. these features are standard. \end{quote}


One of such features is the {\ttfamily x} flag, which enables {\itshape extended} mode of regular expressions. In this mode most of whitespaces are ignored, and expressions can use \#-\/comments.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/}
\DoxyCodeLine{\ \ \#\ A\ regular\ expression\ for\ date.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?<year>\(\backslash\)d\{4\})-\/\ \ \ \ \#\ year\ part\ of\ a\ date}
\DoxyCodeLine{\ \ (?<month>\(\backslash\)d\{2\})-\/\ \ \ \#\ month\ part\ of\ a\ date}
\DoxyCodeLine{\ \ (?<day>\(\backslash\)d\{2\})\ \ \ \ \ \ \#\ day\ part\ of\ a\ date}
\DoxyCodeLine{}
\DoxyCodeLine{/x}

\end{DoxyCode}


This is normally parsed by the {\itshape regexp-\/tree} parser, and compat-\/transpiler has full support for it; it\textquotesingle{}s translated into\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/(\(\backslash\)d\{4\})-\/(\(\backslash\)d\{2\})-\/(\(\backslash\)d\{2\})/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28584}{}\doxysubsubsubsection{\texorpdfstring{Reg\+Exp extensions Babel plugin}{Reg\+Exp extensions Babel plugin}}\label{README.md_autotoc_md28584}
The regexp extensions are also available as a {\itshape Babel plugin}, which can be installed at\+: \href{https://www.npmjs.com/package/babel-plugin-transform-modern-regexp}{\texttt{ babel-\/plugin-\/transform-\/modern-\/regexp}}.

Note, the plugin also includes compat-\/transpiler features.\hypertarget{README.md_autotoc_md28585}{}\doxysubsubsection{\texorpdfstring{Creating Reg\+Exp objects}{Creating Reg\+Exp objects}}\label{README.md_autotoc_md28585}
To create an actual {\ttfamily Reg\+Exp} Java\+Script object, we can use {\ttfamily regexp\+Tree.\+to\+Reg\+Exp} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ regexpTree.toRegExp('/[a-\/z]/i');}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(}
\DoxyCodeLine{\ \ re.test('a'),\ //\ true}
\DoxyCodeLine{\ \ re.test('Z'),\ //\ true}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28586}{}\doxysubsubsection{\texorpdfstring{Executing regexes}{Executing regexes}}\label{README.md_autotoc_md28586}
It is also possible to execute regular expressions using {\ttfamily exec} API method, which has support for new syntax, and features, such as named capturing group, etc\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regexpTree\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ \`{}/}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \#\ A\ regular\ expression\ for\ date.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ (?<year>\(\backslash\)\(\backslash\)d\{4\})-\/\ \ \ \ \#\ year\ part\ of\ a\ date}
\DoxyCodeLine{\ \ (?<month>\(\backslash\)\(\backslash\)d\{2\})-\/\ \ \ \#\ month\ part\ of\ a\ date}
\DoxyCodeLine{\ \ (?<day>\(\backslash\)\(\backslash\)d\{2\})\ \ \ \ \ \ \#\ day\ part\ of\ a\ date}
\DoxyCodeLine{}
\DoxyCodeLine{/x`;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ string\ =\ '2017-\/04-\/14';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ result\ =\ regexpTree.exec(re,\ string);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(result.groups);\ //\ \{year:\ '2017',\ month:\ '04',\ day:\ '14'\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28587}{}\doxysubsubsection{\texorpdfstring{Using interpreter API}{Using interpreter API}}\label{README.md_autotoc_md28587}
\begin{quote}
NOTE\+: you can read more about implementation details of the interpreter in \href{https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-1-regular-grammars-d4986b585d7e}{\texttt{ this series of articles}}. \end{quote}


In addition to executing regular expressions using Java\+Script built-\/in Reg\+Exp engine, Reg\+Exp Tree also implements own \href{https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/interpreter/finite-automaton}{\texttt{ interpreter}} based on classic NFA/\+DFA finite automaton engine.

Currently it aims educational purposes -- to trace the regexp matching process, transitioning in NFA/\+DFA states. It also allows building state transitioning table, which can be used for custom implementation. In API the module is exposed as {\ttfamily fa} (finite-\/automaton) object.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{fa\}\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ re\ =\ /ab|c*/;}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(fa.test(re,\ 'ab'));\ //\ true}
\DoxyCodeLine{console.log(fa.test(re,\ ''));\ //\ true}
\DoxyCodeLine{console.log(fa.test(re,\ 'c'));\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ NFA,\ and\ its\ transition\ table.}
\DoxyCodeLine{const\ nfa\ =\ fa.toNFA(re);}
\DoxyCodeLine{console.log(nfa.getTransitionTable());}
\DoxyCodeLine{}
\DoxyCodeLine{//\ DFA,\ and\ its\ transition\ table.}
\DoxyCodeLine{const\ dfa\ =\ fa.toDFA(re);}
\DoxyCodeLine{console.log(dfa.getTransitionTable());}

\end{DoxyCode}


For more granular work with NFA and DFA, {\ttfamily fa} module also exposes convenient builders, so you can build NFA fragments directly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{fa\}\ =\ require('regexp-\/tree');}
\DoxyCodeLine{}
\DoxyCodeLine{const\ \{}
\DoxyCodeLine{\ \ alt,}
\DoxyCodeLine{\ \ char,}
\DoxyCodeLine{\ \ or,}
\DoxyCodeLine{\ \ rep,}
\DoxyCodeLine{\}\ =\ fa.builders;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ ab|c*}
\DoxyCodeLine{const\ re\ =\ or(}
\DoxyCodeLine{\ \ alt(char('a'),\ char('b')),}
\DoxyCodeLine{\ \ rep(char('c'))}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(re.matches('ab'));\ //\ true}
\DoxyCodeLine{console.log(re.matches(''));\ //\ true}
\DoxyCodeLine{console.log(re.matches('c'));\ //\ true}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Build\ DFA\ from\ NFA}
\DoxyCodeLine{const\ \{DFA\}\ =\ fa;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ reDFA\ =\ new\ DFA(re);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(reDFA.matches('ab'));\ //\ true}
\DoxyCodeLine{console.log(reDFA.matches(''));\ //\ true}
\DoxyCodeLine{console.log(reDFA.matches('c'));\ //\ true}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28588}{}\doxysubsubsubsection{\texorpdfstring{Printing NFA/\+DFA tables}{Printing NFA/\+DFA tables}}\label{README.md_autotoc_md28588}
The {\ttfamily -\/-\/table} option allows displaying NFA/\+DFA transition tables. Reg\+Exp Tree also applies {\itshape DFA minimization} (using {\itshape N-\/equivalence} algorithm), and produces the minimal transition table as its final result.

In the example below for the {\ttfamily /a\texorpdfstring{$\vert$}{|}b\texorpdfstring{$\vert$}{|}c/} regexp, we first obtain the NFA transition table, which is further converted to the original DFA transition table (down from the 10 non-\/deterministic states to 4 deterministic states), and eventually minimized to the final DFA table (from 4 to only 2 states).


\begin{DoxyCode}{0}
\DoxyCodeLine{./bin/regexp-\/tree-\/cli\ -\/e\ '/a|b|c/'\ -\/-\/table\ all}

\end{DoxyCode}


Result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ -\/\ starting}
\DoxyCodeLine{✓\ -\/\ accepting}
\DoxyCodeLine{}
\DoxyCodeLine{NFA\ transition\ table:}
\DoxyCodeLine{}
\DoxyCodeLine{┌─────┬───┬───┬────┬─────────────┐}
\DoxyCodeLine{│\ \ \ \ \ │\ a\ │\ b\ │\ c\ \ │\ ε*\ \ \ \ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 1\ >\ │\ \ \ │\ \ \ │\ \ \ \ │\ \{1,2,3,7,9\}\ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 2\ \ \ │\ \ \ │\ \ \ │\ \ \ \ │\ \{2,3,7\}\ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 3\ \ \ │\ 4\ │\ \ \ │\ \ \ \ │\ 3\ \ \ \ \ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 4\ \ \ │\ \ \ │\ \ \ │\ \ \ \ │\ \{4,5,6\}\ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 5\ \ \ │\ \ \ │\ \ \ │\ \ \ \ │\ \{5,6\}\ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 6\ ✓\ │\ \ \ │\ \ \ │\ \ \ \ │\ 6\ \ \ \ \ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 7\ \ \ │\ \ \ │\ 8\ │\ \ \ \ │\ 7\ \ \ \ \ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 8\ \ \ │\ \ \ │\ \ \ │\ \ \ \ │\ \{8,5,6\}\ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 9\ \ \ │\ \ \ │\ \ \ │\ 10\ │\ 9\ \ \ \ \ \ \ \ \ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼────┼─────────────┤}
\DoxyCodeLine{│\ 10\ \ │\ \ \ │\ \ \ │\ \ \ \ │\ \{10,6\}\ \ \ \ \ \ │}
\DoxyCodeLine{└─────┴───┴───┴────┴─────────────┘}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{DFA:\ Original\ transition\ table:}
\DoxyCodeLine{}
\DoxyCodeLine{┌─────┬───┬───┬───┐}
\DoxyCodeLine{│\ \ \ \ \ │\ a\ │\ b\ │\ c\ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 1\ >\ │\ 4\ │\ 3\ │\ 2\ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 2\ ✓\ │\ \ \ │\ \ \ │\ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 3\ ✓\ │\ \ \ │\ \ \ │\ \ \ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 4\ ✓\ │\ \ \ │\ \ \ │\ \ \ │}
\DoxyCodeLine{└─────┴───┴───┴───┘}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{DFA:\ Minimized\ transition\ table:}
\DoxyCodeLine{}
\DoxyCodeLine{┌─────┬───┬───┬───┐}
\DoxyCodeLine{│\ \ \ \ \ │\ a\ │\ b\ │\ c\ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 1\ >\ │\ 2\ │\ 2\ │\ 2\ │}
\DoxyCodeLine{├─────┼───┼───┼───┤}
\DoxyCodeLine{│\ 2\ ✓\ │\ \ \ │\ \ \ │\ \ \ │}
\DoxyCodeLine{└─────┴───┴───┴───┘}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28589}{}\doxysubsubsection{\texorpdfstring{AST nodes specification}{AST nodes specification}}\label{README.md_autotoc_md28589}
Below are the AST node types for different regular expressions patterns\+:


\begin{DoxyItemize}
\item Char
\begin{DoxyItemize}
\item Simple char
\item Escaped char
\item Meta char
\item Control char
\item Hex char-\/code
\item Decimal char-\/code
\item Octal char-\/code
\item \doxylink{README.md_unicode}{Unicode}
\end{DoxyItemize}
\item Character class
\begin{DoxyItemize}
\item Positive character class
\item Negative character class
\item Character class ranges
\end{DoxyItemize}
\item Unicode properties
\item Alternative
\item Disjunction
\item \doxylink{README.md_groups}{Groups}
\begin{DoxyItemize}
\item Capturing group
\item Named capturing group
\item Non-\/capturing group
\item Backreferences
\end{DoxyItemize}
\item Quantifiers
\begin{DoxyItemize}
\item ? zero-\/or-\/one
\item \texorpdfstring{$\ast$}{*} zero-\/or-\/more
\item + one-\/or-\/more
\item Range-\/based quantifiers
\begin{DoxyItemize}
\item Exact number of matches
\item Open range
\item Closed range
\end{DoxyItemize}
\item Non-\/greedy
\end{DoxyItemize}
\item Assertions
\begin{DoxyItemize}
\item \texorpdfstring{$^\wedge$}{\string^} begin marker
\item \$ end marker
\item Boundary assertions
\item Lookahead assertions
\begin{DoxyItemize}
\item Positive lookahead assertion
\item Negative lookahead assertion
\end{DoxyItemize}
\item Lookbehind assertions
\begin{DoxyItemize}
\item Positive lookbehind assertion
\item Negative lookbehind assertion
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md28590}{}\doxysubsubsubsection{\texorpdfstring{Char}{Char}}\label{README.md_autotoc_md28590}
A basic building block, single character. Can be {\itshape escaped}, and be of different {\itshape kinds}.\hypertarget{README.md_autotoc_md28591}{}\doxysubsubsubsubsection{\texorpdfstring{Simple char}{Simple char}}\label{README.md_autotoc_md28591}
Basic {\itshape non-\/escaped} char in a regexp\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{z}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ 'z',}
\DoxyCodeLine{\ \ symbol:\ 'z',}
\DoxyCodeLine{\ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ codePoint:\ 122}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
NOTE\+: to test this from CLI, the char should be in an actual regexp -- {\ttfamily /z/}. \end{quote}
\hypertarget{README.md_autotoc_md28592}{}\doxysubsubsubsubsection{\texorpdfstring{Escaped char}{Escaped char}}\label{README.md_autotoc_md28592}

\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)z}

\end{DoxyCode}


The same value, {\ttfamily escaped} flag is added\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ 'z',}
\DoxyCodeLine{\ \ symbol:\ 'z',}
\DoxyCodeLine{\ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ codePoint:\ 122,}
\DoxyCodeLine{\ \ escaped:\ true}
\DoxyCodeLine{\}}

\end{DoxyCode}


Escaping is mostly used with meta symbols\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Syntax\ error}
\DoxyCodeLine{*}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)*}

\end{DoxyCode}


OK, node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '*',}
\DoxyCodeLine{\ \ symbol:\ '*',}
\DoxyCodeLine{\ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ codePoint:\ 42,}
\DoxyCodeLine{\ \ escaped:\ true}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28593}{}\doxysubsubsubsubsection{\texorpdfstring{Meta char}{Meta char}}\label{README.md_autotoc_md28593}
A {\itshape meta character} should not be confused with an escaped char.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)n}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)n',}
\DoxyCodeLine{\ \ symbol:\ '\(\backslash\)n',}
\DoxyCodeLine{\ \ kind:\ 'meta',}
\DoxyCodeLine{\ \ codePoint:\ 10}
\DoxyCodeLine{\}}

\end{DoxyCode}


Among other meta character are\+: {\ttfamily .}, {\ttfamily \textbackslash{}f}, {\ttfamily \textbackslash{}r}, {\ttfamily \textbackslash{}n}, {\ttfamily \textbackslash{}t}, {\ttfamily \textbackslash{}v}, {\ttfamily \textbackslash{}0}, {\ttfamily \mbox{[}\textbackslash{}b\mbox{]}} (backspace char), {\ttfamily \textbackslash{}s}, {\ttfamily \textbackslash{}S}, {\ttfamily \textbackslash{}w}, {\ttfamily \textbackslash{}W}, {\ttfamily \textbackslash{}d}, {\ttfamily \textbackslash{}D}.

\begin{quote}
NOTE\+: Meta characters representing ranges (like {\ttfamily .}, {\ttfamily \textbackslash{}s}, etc.) have {\ttfamily undefined} value for {\ttfamily symbol} and {\ttfamily NaN} for {\ttfamily code\+Point}. \end{quote}


\begin{quote}
NOTE\+: {\ttfamily \textbackslash{}b} and {\ttfamily \textbackslash{}B} are parsed as {\ttfamily Assertion} node type, not {\ttfamily Char}. \end{quote}
\hypertarget{README.md_autotoc_md28594}{}\doxysubsubsubsubsection{\texorpdfstring{Control char}{Control char}}\label{README.md_autotoc_md28594}
A char preceded with {\ttfamily \textbackslash{}c}, e.\+g. {\ttfamily \textbackslash{}cx}, which stands for {\ttfamily CTRL+x}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)cx}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)cx',}
\DoxyCodeLine{\ \ symbol:\ undefined,}
\DoxyCodeLine{\ \ kind:\ 'control',}
\DoxyCodeLine{\ \ codePoint:\ NaN}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28595}{}\doxysubsubsubsubsection{\texorpdfstring{HEX char-\/code}{HEX char-\/code}}\label{README.md_autotoc_md28595}
A char preceded with {\ttfamily \textbackslash{}x}, followed by a HEX-\/code, e.\+g. {\ttfamily \textbackslash{}x3B} (symbol {\ttfamily ;})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)x3B}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)x3B',}
\DoxyCodeLine{\ \ symbol:\ ';',}
\DoxyCodeLine{\ \ kind:\ 'hex',}
\DoxyCodeLine{\ \ codePoint:\ 59}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28596}{}\doxysubsubsubsubsection{\texorpdfstring{Decimal char-\/code}{Decimal char-\/code}}\label{README.md_autotoc_md28596}
Char-\/code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)42}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)42',}
\DoxyCodeLine{\ \ symbol:\ '*',}
\DoxyCodeLine{\ \ kind:\ 'decimal',}
\DoxyCodeLine{\ \ codePoint:\ 42}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28597}{}\doxysubsubsubsubsection{\texorpdfstring{Octal char-\/code}{Octal char-\/code}}\label{README.md_autotoc_md28597}
Char-\/code started with {\ttfamily \textbackslash{}0}, followed by an octal number\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)073}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)073',}
\DoxyCodeLine{\ \ symbol:\ ';',}
\DoxyCodeLine{\ \ kind:\ 'oct',}
\DoxyCodeLine{\ \ codePoint:\ 59}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28598}{}\doxysubsubsubsubsection{\texorpdfstring{Unicode}{Unicode}}\label{README.md_autotoc_md28598}
Unicode char started with {\ttfamily \textbackslash{}u}, followed by a hex number\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)u003B}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)u003B',}
\DoxyCodeLine{\ \ symbol:\ ';',}
\DoxyCodeLine{\ \ kind:\ 'unicode',}
\DoxyCodeLine{\ \ codePoint:\ 59}
\DoxyCodeLine{\}}

\end{DoxyCode}


When using the {\ttfamily u} flag, unicode chars can also be represented using {\ttfamily \textbackslash{}u} followed by a hex number between curly braces\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)u\{1F680\}}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)u\{1F680\}',}
\DoxyCodeLine{\ \ symbol:\ '🚀',}
\DoxyCodeLine{\ \ kind:\ 'unicode',}
\DoxyCodeLine{\ \ codePoint:\ 128640}
\DoxyCodeLine{\}}

\end{DoxyCode}


When using the {\ttfamily u} flag, unicode chars can also be represented using a surrogate pair\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\(\backslash\)ud83d\(\backslash\)ude80}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Char',}
\DoxyCodeLine{\ \ value:\ '\(\backslash\)\(\backslash\)ud83d\(\backslash\)\(\backslash\)ude80',}
\DoxyCodeLine{\ \ symbol:\ '🚀',}
\DoxyCodeLine{\ \ kind:\ 'unicode',}
\DoxyCodeLine{\ \ codePoint:\ 128640,}
\DoxyCodeLine{\ \ isSurrogatePair:\ true}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28599}{}\doxysubsubsubsection{\texorpdfstring{Character class}{Character class}}\label{README.md_autotoc_md28599}
Character classes define a {\itshape set} of characters. A set may include as simple characters, as well as {\itshape character ranges}. A class can be {\itshape positive} (any from the characters in the class match), or {\itshape negative} (any {\itshape but} the characters from the class match).\hypertarget{README.md_autotoc_md28600}{}\doxysubsubsubsubsection{\texorpdfstring{Positive character class}{Positive character class}}\label{README.md_autotoc_md28600}
A positive character class is defined between {\ttfamily \mbox{[}} and {\ttfamily \mbox{]}} brackets\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[a*]}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'CharacterClass',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ '*',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ '*',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 42}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
NOTE\+: some meta symbols are treated as normal characters in a character class. E.\+g. {\ttfamily \texorpdfstring{$\ast$}{*}} is not a repetition quantifier, but a simple char. \end{quote}
\hypertarget{README.md_autotoc_md28601}{}\doxysubsubsubsubsection{\texorpdfstring{Negative character class}{Negative character class}}\label{README.md_autotoc_md28601}
A negative character class is defined between {\ttfamily \mbox{[}\texorpdfstring{$^\wedge$}{\string^}} and {\ttfamily \mbox{]}} brackets\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\string^ab]}

\end{DoxyCode}


An AST node is the same, just {\ttfamily negative} property is added\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'CharacterClass',}
\DoxyCodeLine{\ \ negative:\ true,}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28602}{}\doxysubsubsubsubsection{\texorpdfstring{Character class ranges}{Character class ranges}}\label{README.md_autotoc_md28602}
As mentioned, a character class may also contain {\itshape ranges} of symbols\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[a-\/z]}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'CharacterClass',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'ClassRange',}
\DoxyCodeLine{\ \ \ \ \ \ from:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ to:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'z',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'z',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 122}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
NOTE\+: it is a {\itshape syntax error} if {\ttfamily to} value is less than {\ttfamily from} value\+: {\ttfamily /\mbox{[}z-\/a\mbox{]}/}. \end{quote}


The range value can be the same for {\ttfamily from} and {\ttfamily to}, and the special range {\ttfamily -\/} character is treated as a simple character when it stands in a char position\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ from:\ 'a',\ to:\ 'a'}
\DoxyCodeLine{[a-\/a]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ from:\ '-\/',\ to:\ '-\/'}
\DoxyCodeLine{[-\/-\/-\/]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ simple\ '-\/'\ char:}
\DoxyCodeLine{[-\/]}
\DoxyCodeLine{}
\DoxyCodeLine{//\ 3\ ranges:}
\DoxyCodeLine{[a-\/zA-\/Z0-\/9]+}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28603}{}\doxysubsubsubsection{\texorpdfstring{Unicode properties}{Unicode properties}}\label{README.md_autotoc_md28603}
Unicode property escapes are a new type of escape sequence available in regular expressions that have the {\ttfamily u} flag set. With this feature it is possible to write Unicode expressions as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ greekSymbolRe\ =\ /\(\backslash\)p\{Script=Greek\}/u;}
\DoxyCodeLine{}
\DoxyCodeLine{greekSymbolRe.test('π');\ //\ true}

\end{DoxyCode}


The AST node for this expression is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'UnicodeProperty',}
\DoxyCodeLine{\ \ name:\ 'Script',}
\DoxyCodeLine{\ \ value:\ 'Greek',}
\DoxyCodeLine{\ \ negative:\ false,}
\DoxyCodeLine{\ \ shorthand:\ false,}
\DoxyCodeLine{\ \ binary:\ false,}
\DoxyCodeLine{\ \ canonicalName:\ 'Script',}
\DoxyCodeLine{\ \ canonicalValue:\ 'Greek'}
\DoxyCodeLine{\}}

\end{DoxyCode}


All possible property names, values, and their aliases can be found at the \href{https://tc39.github.io/ecma262/\#sec-runtime-semantics-unicodematchproperty-p}{\texttt{ specification}}.

For {\ttfamily General\+\_\+\+Category} it is possible to use a shorthand\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/\(\backslash\)p\{Letter\}/u;\ \ \ //\ Shorthand}
\DoxyCodeLine{}
\DoxyCodeLine{/\(\backslash\)p\{General\_Category=Letter\}/u;\ //\ Full\ notation}

\end{DoxyCode}


Binary names use the single value as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/\(\backslash\)p\{ASCII\_Hex\_Digit\}/u;\ //\ Same\ as:\ /[0-\/9A-\/Fa-\/f]/}

\end{DoxyCode}


The capitalized {\ttfamily P} defines the negation of the expression\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/\(\backslash\)P\{ASCII\_Hex\_Digit\}/u;\ //\ NOT\ a\ ASCII\ Hex\ digit}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28604}{}\doxysubsubsubsection{\texorpdfstring{Alternative}{Alternative}}\label{README.md_autotoc_md28604}
An {\itshape alternative} (or {\itshape concatenation}) defines a chain of patterns followed one after another\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{abc}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 99}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


Another examples\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ 'a'\ with\ a\ quantifier,\ followed\ by\ 'b'}
\DoxyCodeLine{a?b}
\DoxyCodeLine{}
\DoxyCodeLine{//\ A\ group\ followed\ by\ a\ class:}
\DoxyCodeLine{(ab)[a-\/z]}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28605}{}\doxysubsubsubsection{\texorpdfstring{Disjunction}{Disjunction}}\label{README.md_autotoc_md28605}
The {\itshape disjunction} defines "{}\+OR"{} operation for regexp patterns. It\textquotesingle{}s a {\itshape binary} operation, having {\ttfamily left}, and {\ttfamily right} nodes.

Matches {\ttfamily a} or {\ttfamily b}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a|b}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Disjunction',}
\DoxyCodeLine{\ \ left:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ right:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28606}{}\doxysubsubsubsection{\texorpdfstring{Groups}{Groups}}\label{README.md_autotoc_md28606}
The groups play two roles\+: they define {\itshape grouping precedence}, and allow to {\itshape capture} needed sub-\/expressions in case of a capturing group.\hypertarget{README.md_autotoc_md28607}{}\doxysubsubsubsubsection{\texorpdfstring{Capturing group}{Capturing group}}\label{README.md_autotoc_md28607}
{\itshape "{}\+Capturing"{}} means the matched string can be referred later by a user, including in the pattern itself -- by using backreferences.

Char {\ttfamily a}, and {\ttfamily b} are grouped, followed by the {\ttfamily c} char\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(ab)c}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Group',}
\DoxyCodeLine{\ \ \ \ \ \ capturing:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 99}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


As we can see, it also tracks the number of the group.

Another example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ A\ grouped\ disjunction\ of\ a\ symbol,\ and\ a\ character\ class:}
\DoxyCodeLine{(5|[a-\/z])}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28608}{}\doxysubsubsubsubsection{\texorpdfstring{Named capturing group}{Named capturing group}}\label{README.md_autotoc_md28608}
A capturing group can be given a name using the {\ttfamily (?\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}...)} syntax, for any identifier {\ttfamily name}.

For example, a regular expressions for a date\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/(?<year>\(\backslash\)d\{4\})-\/(?<month>\(\backslash\)d\{2\})-\/(?<day>\(\backslash\)d\{2\})/u}

\end{DoxyCode}


For the group\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<foo>x)}

\end{DoxyCode}


We have the following node (the {\ttfamily name} property with value {\ttfamily foo} is added)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Group',}
\DoxyCodeLine{\ \ capturing:\ true,}
\DoxyCodeLine{\ \ name:\ 'foo',}
\DoxyCodeLine{\ \ nameRaw:\ 'foo',}
\DoxyCodeLine{\ \ number:\ 1,}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'x',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'x',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 120}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Note\+: The {\ttfamily name\+Raw} property represents the name {\itshape as parsed from the original source}, including escape sequences. The {\ttfamily name} property represents the canonical decoded form of the name.

For example, given the {\ttfamily /u} flag and the following group\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<\(\backslash\)u\{03C0\}>x)}

\end{DoxyCode}


We would have the following node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Group',}
\DoxyCodeLine{\ \ capturing:\ true,}
\DoxyCodeLine{\ \ name:\ 'π',}
\DoxyCodeLine{\ \ nameRaw:\ '\(\backslash\)\(\backslash\)u\{03C0\}',}
\DoxyCodeLine{\ \ number:\ 1,}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'x',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'x',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 120}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28609}{}\doxysubsubsubsubsection{\texorpdfstring{Non-\/capturing group}{Non-\/capturing group}}\label{README.md_autotoc_md28609}
Sometimes we don\textquotesingle{}t need to actually capture the matched string from a group. In this case we can use a {\itshape non-\/capturing} group\+:

Char {\ttfamily a}, and {\ttfamily b} are grouped, {\itshape but not captured}, followed by the {\ttfamily c} char\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?:ab)c}

\end{DoxyCode}


The same node, the {\ttfamily capturing} flag is {\ttfamily false}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Group',}
\DoxyCodeLine{\ \ \ \ \ \ capturing:\ false,}
\DoxyCodeLine{\ \ \ \ \ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'c',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 99}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28610}{}\doxysubsubsubsubsection{\texorpdfstring{Backreferences}{Backreferences}}\label{README.md_autotoc_md28610}
A capturing group can be referenced in the pattern using notation of an escaped group number.

Matches {\ttfamily abab} string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(ab)\(\backslash\)1}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Group',}
\DoxyCodeLine{\ \ \ \ \ \ capturing:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Backreference',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'number',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ reference:\ 1,}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


A named capturing group can be accessed using {\ttfamily \textbackslash{}k\texorpdfstring{$<$}{<}name\texorpdfstring{$>$}{>}} pattern, and also using a numbered reference.

Matches {\ttfamily www}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<foo>w)\(\backslash\)k<foo>\(\backslash\)1}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Group',}
\DoxyCodeLine{\ \ \ \ \ \ capturing:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ name:\ 'foo',}
\DoxyCodeLine{\ \ \ \ \ \ nameRaw:\ 'foo',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'w',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'w',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 119}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Backreference',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'name',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ reference:\ 'foo',}
\DoxyCodeLine{\ \ \ \ \ \ referenceRaw:\ 'foo'}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Backreference',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'number',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ reference:\ 1}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


Note\+: The {\ttfamily reference\+Raw} property represents the reference {\itshape as parsed from the original source}, including escape sequences. The {\ttfamily reference} property represents the canonical decoded form of the reference.

For example, given the {\ttfamily /u} flag and the following pattern (matches {\ttfamily www})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<π>w)\(\backslash\)k<\(\backslash\)u\{03C0\}>\(\backslash\)1}

\end{DoxyCode}


We would have the following node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Group',}
\DoxyCodeLine{\ \ \ \ \ \ capturing:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ name:\ 'π',}
\DoxyCodeLine{\ \ \ \ \ \ nameRaw:\ 'π',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'w',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'w',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 119}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Backreference',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'name',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ reference:\ 'π',}
\DoxyCodeLine{\ \ \ \ \ \ referenceRaw:\ '\(\backslash\)\(\backslash\)u\{03C0\}'}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Backreference',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'number',}
\DoxyCodeLine{\ \ \ \ \ \ number:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ reference:\ 1}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28611}{}\doxysubsubsubsection{\texorpdfstring{Quantifiers}{Quantifiers}}\label{README.md_autotoc_md28611}
Quantifiers specify {\itshape repetition} of a regular expression (or of its part). Below are the quantifiers which {\itshape wrap} a parsed expression into a {\ttfamily Repetition} node. The quantifier itself can be of different {\itshape kinds}, and has {\ttfamily Quantifier} node type.\hypertarget{README.md_autotoc_md28612}{}\doxysubsubsubsubsection{\texorpdfstring{? zero-\/or-\/one}{? zero-\/or-\/one}}\label{README.md_autotoc_md28612}
The {\ttfamily ?} quantifier is short for {\ttfamily \{0,1\}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{a?}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ '?',}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28613}{}\doxysubsubsubsubsection{\texorpdfstring{\texorpdfstring{$\ast$}{*} zero-\/or-\/more}{\texorpdfstring{$\ast$}{*} zero-\/or-\/more}}\label{README.md_autotoc_md28613}
The {\ttfamily \texorpdfstring{$\ast$}{*}} quantifier is short for {\ttfamily \{0,\}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{a*}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ '*',}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28614}{}\doxysubsubsubsubsection{\texorpdfstring{+ one-\/or-\/more}{+ one-\/or-\/more}}\label{README.md_autotoc_md28614}
The {\ttfamily +} quantifier is short for {\ttfamily \{1,\}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Same\ as\ \`{}aa*`,\ or\ \`{}a\{1,\}`}
\DoxyCodeLine{a+}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ '+',}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28615}{}\doxysubsubsubsubsection{\texorpdfstring{Range-\/based quantifiers}{Range-\/based quantifiers}}\label{README.md_autotoc_md28615}
Explicit {\itshape range-\/based} quantifiers are parsed as follows\+:\hypertarget{README.md_autotoc_md28616}{}\doxysubsubsubsubsubsection{\texorpdfstring{Exact number of matches}{Exact number of matches}}\label{README.md_autotoc_md28616}

\begin{DoxyCode}{0}
\DoxyCodeLine{a\{3\}}

\end{DoxyCode}


The type of the quantifier is {\ttfamily Range}, and {\ttfamily from}, and {\ttfamily to} properties have the same value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ 'Range',}
\DoxyCodeLine{\ \ \ \ from:\ 3,}
\DoxyCodeLine{\ \ \ \ to:\ 3,}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28617}{}\doxysubsubsubsubsubsection{\texorpdfstring{Open range}{Open range}}\label{README.md_autotoc_md28617}
An open range doesn\textquotesingle{}t have max value (assuming semantic "{}more"{}, or Infinity value)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a\{3,\}}

\end{DoxyCode}


An AST node for such range doesn\textquotesingle{}t contain {\ttfamily to} property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ 'Range',}
\DoxyCodeLine{\ \ \ \ from:\ 3,}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28618}{}\doxysubsubsubsubsubsection{\texorpdfstring{Closed range}{Closed range}}\label{README.md_autotoc_md28618}
A closed range has explicit max value\+: (which syntactically can be the same as min value)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a\{3,5\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Same\ as\ a\{3\}}
\DoxyCodeLine{a\{3,3\}}

\end{DoxyCode}


An AST node for a closed range\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ 'Range',}
\DoxyCodeLine{\ \ \ \ from:\ 3,}
\DoxyCodeLine{\ \ \ \ to:\ 5,}
\DoxyCodeLine{\ \ \ \ greedy:\ true}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
NOTE\+: it is a {\itshape syntax error} if the max value is less than min value\+: {\ttfamily /a\{3,2\}/} \end{quote}
\hypertarget{README.md_autotoc_md28619}{}\doxysubsubsubsubsection{\texorpdfstring{Non-\/greedy}{Non-\/greedy}}\label{README.md_autotoc_md28619}
If any quantifier is followed by the {\ttfamily ?}, the quantifier becomes {\itshape non-\/greedy}.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a+?}

\end{DoxyCode}


Node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Repetition',}
\DoxyCodeLine{\ \ expression:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ quantifier:\ \{}
\DoxyCodeLine{\ \ \ \ type:\ 'Quantifier',}
\DoxyCodeLine{\ \ \ \ kind:\ '+',}
\DoxyCodeLine{\ \ \ \ greedy:\ false}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Other examples\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a??}
\DoxyCodeLine{a*?}
\DoxyCodeLine{a\{1\}?}
\DoxyCodeLine{a\{1,\}?}
\DoxyCodeLine{a\{1,3\}?}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28620}{}\doxysubsubsubsection{\texorpdfstring{Assertions}{Assertions}}\label{README.md_autotoc_md28620}
Assertions appear as separate AST nodes, however instread of manipulating on the characters themselves, they {\itshape assert} certain conditions of a matching string. Examples\+: {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} -- beginning of a string (or a line in multiline mode), {\ttfamily \$} -- end of a string, etc.\hypertarget{README.md_autotoc_md28621}{}\doxysubsubsubsubsection{\texorpdfstring{\texorpdfstring{$^\wedge$}{\string^} begin marker}{\texorpdfstring{$^\wedge$}{\string^} begin marker}}\label{README.md_autotoc_md28621}
The {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} assertion checks whether a scanner is at the beginning of a string (or a line in multiline mode).

In the example below {\ttfamily \texorpdfstring{$^\wedge$}{\string^}} is not a property of the {\ttfamily a} symbol, but a separate AST node for the assertion. The parsed node is actually an {\ttfamily Alternative} with two nodes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\string^a}

\end{DoxyCode}


The node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ '\string^'}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


Since assertion is a separate node, it may appear anywhere in the matching string. The following regexp is completely valid, and asserts beginning of the string; it\textquotesingle{}ll match an empty string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\string^\string^\string^\string^\string^}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28622}{}\doxysubsubsubsubsection{\texorpdfstring{\$ end marker}{\$ end marker}}\label{README.md_autotoc_md28622}
The {\ttfamily \$} assertion is similar to {\ttfamily \texorpdfstring{$^\wedge$}{\string^}}, but asserts the end of a string (or a line in a multiline mode)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a\$}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ '\$'}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


And again, this is a completely valid regexp, and matches an empty string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\string^\string^\string^\string^\$\$\$\$\$}
\DoxyCodeLine{}
\DoxyCodeLine{//\ valid\ too:}
\DoxyCodeLine{\$\string^}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28623}{}\doxysubsubsubsubsection{\texorpdfstring{Boundary assertions}{Boundary assertions}}\label{README.md_autotoc_md28623}
The {\ttfamily \textbackslash{}b} assertion check for {\itshape word boundary}, i.\+e. the position between a word and a space.

Matches {\ttfamily x} in {\ttfamily x y}, but not in {\ttfamily xy}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{x\(\backslash\)b}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'x',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'x',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 120}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ '\(\backslash\)\(\backslash\)b'}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}


The {\ttfamily \textbackslash{}B} is vice-\/versa checks for {\itshape non-\/word} boundary. The following example matches {\ttfamily x} in {\ttfamily xy}, but not in {\ttfamily x y}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{x\(\backslash\)B}

\end{DoxyCode}


A node is the same\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'x',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'x',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 120}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ '\(\backslash\)\(\backslash\)B'}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28624}{}\doxysubsubsubsubsection{\texorpdfstring{Lookahead assertions}{Lookahead assertions}}\label{README.md_autotoc_md28624}
These assertions check whether a pattern is {\itshape followed} (or not followed for the negative assertion) by another pattern.\hypertarget{README.md_autotoc_md28625}{}\doxysubsubsubsubsubsection{\texorpdfstring{Positive lookahead assertion}{Positive lookahead assertion}}\label{README.md_autotoc_md28625}
Matches {\ttfamily a} only if it\textquotesingle{}s followed by {\ttfamily b}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a(?=b)}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'Lookahead',}
\DoxyCodeLine{\ \ \ \ \ \ assertion:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28626}{}\doxysubsubsubsubsubsection{\texorpdfstring{Negative lookahead assertion}{Negative lookahead assertion}}\label{README.md_autotoc_md28626}
Matches {\ttfamily a} only if it\textquotesingle{}s {\itshape not} followed by {\ttfamily b}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{a(?!b)}

\end{DoxyCode}


A node is similar, just {\ttfamily negative} flag is added\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'Lookahead',}
\DoxyCodeLine{\ \ \ \ \ \ negative:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ assertion:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28627}{}\doxysubsubsubsubsection{\texorpdfstring{Lookbehind assertions}{Lookbehind assertions}}\label{README.md_autotoc_md28627}
\begin{quote}
NOTE\+: {\itshape Lookbehind assertions} are not yet supported by Java\+Script Reg\+Exp. It is an ECMAScript \href{https://tc39.github.io/proposal-regexp-lookbehind/}{\texttt{ proposal}} which is at stage 3 at the moment. \end{quote}


These assertions check whether a pattern is {\itshape preceded} (or not preceded for the negative assertion) by another pattern.\hypertarget{README.md_autotoc_md28628}{}\doxysubsubsubsubsubsection{\texorpdfstring{Positive lookbehind assertion}{Positive lookbehind assertion}}\label{README.md_autotoc_md28628}
Matches {\ttfamily b} only if it\textquotesingle{}s preceded by {\ttfamily a}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<=a)b}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'Lookbehind',}
\DoxyCodeLine{\ \ \ \ \ \ assertion:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28629}{}\doxysubsubsubsubsubsection{\texorpdfstring{Negative lookbehind assertion}{Negative lookbehind assertion}}\label{README.md_autotoc_md28629}
Matches {\ttfamily b} only if it\textquotesingle{}s {\itshape not} preceded by {\ttfamily a}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(?<!a)b}

\end{DoxyCode}


A node\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ type:\ 'Alternative',}
\DoxyCodeLine{\ \ expressions:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Assertion',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'Lookbehind',}
\DoxyCodeLine{\ \ \ \ \ \ negative:\ true,}
\DoxyCodeLine{\ \ \ \ \ \ assertion:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ value:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ symbol:\ 'a',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ \ \ codePoint:\ 97}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ type:\ 'Char',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ symbol:\ 'b',}
\DoxyCodeLine{\ \ \ \ \ \ kind:\ 'simple',}
\DoxyCodeLine{\ \ \ \ \ \ codePoint:\ 98}
\DoxyCodeLine{\ \ \ \ \},}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
 