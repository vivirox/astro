\doxysection{node\+\_\+modules/refa Directory Reference}
\hypertarget{dir_1a5d4eb5dbd5eee9070f0f8c201096c5}{}\label{dir_1a5d4eb5dbd5eee9070f0f8c201096c5}\index{node\_modules/refa Directory Reference@{node\_modules/refa Directory Reference}}


\doxysubsection{Detailed Description}
\href{https://github.com/RunDevelopment/refa/actions}{\texttt{ }} \href{https://www.npmjs.com/package/refa}{\texttt{ }}

A library for regular expressions (RE) and finite automata (FA) in the context of \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp}{\texttt{ Javascript Reg\+Exp}}.\hypertarget{README.md_autotoc_md28096}{}\doxysubsection{\texorpdfstring{About}{About}}\label{README.md_autotoc_md28096}
refa is a general library for \href{https://en.wikipedia.org/wiki/Deterministic_finite_automaton}{\texttt{ DFA}}, \href{https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton}{\texttt{ NFA}}, and REs of \href{https://en.wikipedia.org/wiki/Induction_of_regular_languages}{\texttt{ formal regular languages}}. It also includes methods to easily convert from JS Reg\+Exp to the internal RE AST and vice versa.\hypertarget{README.md_autotoc_md28097}{}\doxysubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md28097}
Get \href{https://www.npmjs.com/package/refa}{\texttt{ refa from NPM}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ i\ -\/-\/save\ refa}

\end{DoxyCode}


or


\begin{DoxyCode}{0}
\DoxyCodeLine{yarn\ add\ refa}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28098}{}\doxysubsection{\texorpdfstring{Features}{Features}}\label{README.md_autotoc_md28098}

\begin{DoxyItemize}
\item Conversions
\begin{DoxyItemize}
\item RE AST to NFA and ENFA ({\itshape assertions are not implemented yet})
\item DFA, NFA, and ENFA can all be converted into each other
\item DFA, NFA, and ENFA to RE AST
\end{DoxyItemize}
\item DFA, NFA, and ENFA operations
\begin{DoxyItemize}
\item Construction from other FA, the intersection of two FA, or a finite set of words
\item Print as \href{https://en.wikipedia.org/wiki/DOT_(graph_description_language)}{\texttt{ DOT}} or \href{https://mermaid.js.org/}{\texttt{ Mermaid}}.
\item Test whether a word is accepted
\item Test whether the accepted language is the empty set/a finite set
\item Accept all prefixes/suffixes of a language
\end{DoxyItemize}
\item DFA specific operations
\begin{DoxyItemize}
\item Minimization
\item Complement
\item Structural equality
\end{DoxyItemize}
\item NFA and ENFA specific operations
\begin{DoxyItemize}
\item Union and Concatenation with other FA
\item Quantification
\item Reverse
\end{DoxyItemize}
\item AST transformations
\begin{DoxyItemize}
\item Simplify and change the AST of a regex
\item Remove assertions
\end{DoxyItemize}
\item Java\+Script Reg\+Exp
\begin{DoxyItemize}
\item Reg\+Exp to RE AST and RE AST to Reg\+Exp
\begin{DoxyItemize}
\item All flags are fully supported
\item Unicode properties
\item Change flags
\item Limited support for simple backreferences
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

See the \href{https://rundevelopment.github.io/refa/docs/latest/}{\texttt{ API documentation}} for a complete list of all currently implemented operations.\hypertarget{README.md_autotoc_md28099}{}\doxysubsubsection{\texorpdfstring{RE AST format}{RE AST format}}\label{README.md_autotoc_md28099}
refa uses its own AST format to represent regular expressions. The RE AST format is language agnostic and relatively simple.

It supports\+:


\begin{DoxyItemize}
\item Concatenation (e.\+g. {\ttfamily ab})
\item Alternation (e.\+g. {\ttfamily a\texorpdfstring{$\vert$}{|}b})
\item Quantifiers (greedy and lazy) (e.\+g. {\ttfamily a\{4,6\}}, {\ttfamily a\{2,\}?}, {\ttfamily a?}, {\ttfamily a\texorpdfstring{$\ast$}{*}})
\item Assertions (e.\+g. {\ttfamily (?=a)}, {\ttfamily (?\texorpdfstring{$<$}{<}!a)})
\item Characters/character sets (represented by interval sets)
\item Unknowns (elements that cannot be represented otherwise. E.\+g. backreferences)
\end{DoxyItemize}

Some features like atomic groups and capturing groups are not supported (but might be added in the future).

For information on how to parse JS Reg\+Exp and convert RE AST to JS Reg\+Exp, see the \href{https://rundevelopment.github.io/refa/docs/latest/modules/JS.html}{\texttt{ {\ttfamily JS} namespace}}.\hypertarget{README.md_autotoc_md28100}{}\doxysubsubsection{\texorpdfstring{Universal characters}{Universal characters}}\label{README.md_autotoc_md28100}
refa does not use Java\+Script strings represent characters or a sequences of characters. Instead it uses integers to represent characters (see the \href{https://rundevelopment.github.io/refa/docs/latest/modules.html\#Char}{\texttt{ {\ttfamily Char} type}}) and arrays of numbers to represent words/strings (see the \href{https://rundevelopment.github.io/refa/docs/latest/modules.html\#Word}{\texttt{ {\ttfamily Word} type}}).

This means that any text encoding can be used.

The \href{https://rundevelopment.github.io/refa/docs/latest/modules/Words.html}{\texttt{ {\ttfamily Words} namespace}} contains functions to convert Java\+Script data into refa-\/compatible words and characters.

For the sets of characters, the \href{https://rundevelopment.github.io/refa/docs/latest/classes/CharSet.html}{\texttt{ {\ttfamily Char\+Set} class}} is used.\hypertarget{README.md_autotoc_md28101}{}\doxysubsubsection{\texorpdfstring{General limitations}{General limitations}}\label{README.md_autotoc_md28101}
This library will never be able to support some modern features of regex engines such as \href{https://www.rexegg.com/regex-capture.html}{\texttt{ backreferences}} and \href{https://www.rexegg.com/regex-recursion.html}{\texttt{ recursion}} because these features, generally, cannot be be represented by a DFA or NFA.\hypertarget{README.md_autotoc_md28102}{}\doxysubsection{\texorpdfstring{Usage examples}{Usage examples}}\label{README.md_autotoc_md28102}
refa is a relatively low-\/level library. It only provides the basic building blocks. In the following examples, JS Reg\+Exps are used a lot so we will define a few useful helper function beforehand.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ DFA,\ FiniteAutomaton,\ JS,\ NFA\ \}\ from\ "{}refa"{};}
\DoxyCodeLine{}
\DoxyCodeLine{function\ toNFA(regex:\ RegExp):\ NFA\ \{}
\DoxyCodeLine{\ \ \ \ const\ \{\ expression,\ maxCharacter\ \}\ =\ JS.Parser.fromLiteral(regex).parse();}
\DoxyCodeLine{\ \ \ \ return\ NFA.fromRegex(expression,\ \{\ maxCharacter\ \});}
\DoxyCodeLine{\}}
\DoxyCodeLine{function\ toDFA(regex:\ RegExp):\ DFA\ \{}
\DoxyCodeLine{\ \ \ \ return\ DFA.fromFA(toNFA(regex));}
\DoxyCodeLine{\}}
\DoxyCodeLine{function\ toRegExp(fa:\ FiniteAutomaton):\ RegExp\ \{}
\DoxyCodeLine{\ \ \ \ const\ literal\ =\ JS.toLiteral(fa.toRegex());}
\DoxyCodeLine{\ \ \ \ return\ new\ RegExp(literal.source,\ literal.flags);}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily to\+NFA} parses the given Reg\+Exp and constructs a new NFA from the parsed AST.
\item {\ttfamily to\+DFA} constructs a new NFA from the Reg\+Exp first and then converts that NFA into a new DFA.
\item {\ttfamily to\+Regex} takes an FA (= NFA or DFA) and converts it into a Reg\+Exp.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md28103}{}\doxysubsubsection{\texorpdfstring{Testing whether a word is accepted}{Testing whether a word is accepted}}\label{README.md_autotoc_md28103}

\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ Words\ \}\ from\ "{}refa"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ regex\ =\ /\(\backslash\)w+\(\backslash\)d+/;}
\DoxyCodeLine{const\ nfa\ =\ toNFA(regex);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(nfa.test(Words.fromStringToUTF16("{}abc"{})));}
\DoxyCodeLine{//\ =>\ false}
\DoxyCodeLine{console.log(nfa.test(Words.fromStringToUTF16("{}123"{})));}
\DoxyCodeLine{//\ =>\ true}
\DoxyCodeLine{console.log(nfa.test(Words.fromStringToUTF16("{}abc123"{})));}
\DoxyCodeLine{//\ =>\ true}
\DoxyCodeLine{console.log(nfa.test(Words.fromStringToUTF16("{}123abc"{})));}
\DoxyCodeLine{//\ =>\ false}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28104}{}\doxysubsubsection{\texorpdfstring{Finding the intersection of two JS Reg\+Exps}{Finding the intersection of two JS Reg\+Exps}}\label{README.md_autotoc_md28104}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex1\ =\ /a+B+c+/i;}
\DoxyCodeLine{const\ regex2\ =\ /Ab*C\(\backslash\)d?/;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ intersection\ =\ NFA.fromIntersection(toNFA(regex1),\ toNFA(regex2));}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(toRegExp(intersection));}
\DoxyCodeLine{//\ =>\ /Ab+C/}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28105}{}\doxysubsubsection{\texorpdfstring{Finding the complement of a JS Reg\+Exp}{Finding the complement of a JS Reg\+Exp}}\label{README.md_autotoc_md28105}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex\ =\ /a+b*/i;}
\DoxyCodeLine{}
\DoxyCodeLine{const\ dfa\ =\ toDFA(regex);}
\DoxyCodeLine{dfa.complement();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(toRegExp(dfa));}
\DoxyCodeLine{//\ =>\ /(?:(?:[\string^A]|A+(?:[\string^AB]|B+[\string^B]))[\string^]*)?/i}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md28106}{}\doxysubsubsection{\texorpdfstring{Converting a JS Reg\+Exp to an NFA}{Converting a JS Reg\+Exp to an NFA}}\label{README.md_autotoc_md28106}
In the above examples, we have been using the {\ttfamily to\+NFA} helper function to parse and convert Reg\+Exps. This function assumes that the given Reg\+Exp is a pure regular expression without assertions and backreferences and will throw an error if the assumption is not met.

However, the JS parser and {\ttfamily NFA.\+from\+Regex} provide some options to work around and even solve this problem.\hypertarget{README.md_autotoc_md28107}{}\doxysubsubsubsection{\texorpdfstring{Backreferences}{Backreferences}}\label{README.md_autotoc_md28107}
Firstly, the parser will automatically resolve simple backreferences. Even {\ttfamily to\+NFA} will do this since it\textquotesingle{}s on by default\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{console.log(toRegExp(toNFA(/("{}|').*?\(\backslash\)1/)));}
\DoxyCodeLine{//\ =>\ /"{}.*"{}|'.*'/i}

\end{DoxyCode}


But it will throw an error for non-\/trivial backreferences that cannot be resolved\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{toNFA(/(\#+).*\(\backslash\)1|foo/);}
\DoxyCodeLine{//\ Error:\ Backreferences\ are\ not\ supported.}

\end{DoxyCode}


The only way to parse the Reg\+Exp despite unresolvable backreferences is to remove the backreferences. This means that the result will be imperfect but it might still be useful.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex\ =\ /(\#+).*\(\backslash\)1|foo/;}
\DoxyCodeLine{const\ \{\ expression\ \}\ =}
\DoxyCodeLine{\ \ \ \ JS.Parser.fromLiteral(regex).parse(\{\ backreferences:\ "{}disable"{}\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(JS.toLiteral(expression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ 'foo',\ flags:\ ''\ \}}

\end{DoxyCode}


Note that the {\ttfamily foo} alternative is kept because it is completely unaffected by the unresolvable backreferences.\hypertarget{README.md_autotoc_md28108}{}\doxysubsubsubsection{\texorpdfstring{Assertions}{Assertions}}\label{README.md_autotoc_md28108}
While the parser and AST format can handle assertions, the NFA construction cannot.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex\ =\ /\(\backslash\)b(?!\(\backslash\)d)\(\backslash\)w+\(\backslash\)b|-\/>/;}
\DoxyCodeLine{const\ \{\ expression,\ maxCharacter\ \}\ =\ JS.Parser.fromLiteral(regex).parse();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(JS.toLiteral(expression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '\(\backslash\)\(\backslash\)b(?!\(\backslash\)\(\backslash\)d)\(\backslash\)\(\backslash\)w+\(\backslash\)\(\backslash\)b|-\/>',\ flags:\ 'i'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{NFA.fromRegex(expression,\ \{\ maxCharacter\ \});}
\DoxyCodeLine{//\ Error:\ Assertions\ are\ not\ supported\ yet.}

\end{DoxyCode}


Similarly to backreferences, we can let the parser remove them\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex\ =\ /\(\backslash\)b(?!\(\backslash\)d)\(\backslash\)w+\(\backslash\)b|-\/>/;}
\DoxyCodeLine{const\ \{\ expression,\ maxCharacter\ \}\ =}
\DoxyCodeLine{\ \ \ \ JS.Parser.fromLiteral(regex).parse(\{\ assertions:\ "{}disable"{}\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(JS.toLiteral(expression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '-\/>',\ flags:\ 'i'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ nfa\ =\ NFA.fromRegex(expression,\ \{\ maxCharacter\ \});}
\DoxyCodeLine{console.log(toRegExp(nfa));}
\DoxyCodeLine{//\ =>\ /-\/>/i}

\end{DoxyCode}




{\bfseries{Details}}\begin{adjustwidth}{1em}{0em}


Or we can let the NFA construction method remove them\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ regex\ =\ /\(\backslash\)b(?!\(\backslash\)d)\(\backslash\)w+\(\backslash\)b|-\/>/;}
\DoxyCodeLine{const\ \{\ expression,\ maxCharacter\ \}\ =\ JS.Parser.fromLiteral(regex).parse();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(JS.toLiteral(expression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '\(\backslash\)\(\backslash\)b(?!\(\backslash\)\(\backslash\)d)\(\backslash\)\(\backslash\)w+\(\backslash\)\(\backslash\)b|-\/>',\ flags:\ 'i'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ nfa\ =\ NFA.fromRegex(expression,\ \{\ maxCharacter\ \},\ \{\ assertions:\ "{}disable"{}\ \});}
\DoxyCodeLine{console.log(toRegExp(nfa));}
\DoxyCodeLine{//\ =>\ /-\/>/i}

\end{DoxyCode}


Prefer using the parser to remove assertions if possible. The parser is quite clever and will optimize based on that assertions can be removed resulting in faster parse times.

\end{adjustwidth}


However, simply removing assertions is not ideal since they are a lot more common than backreferences. To work around this, refa has AST transformers. AST transformers can make changes to a given AST. While each transformer is rather simple, they can also work together to accomplish more complex tasks. Applying and removing assertions is one such task.

The simplest transformer to remove assertions (among other things) is the {\ttfamily simplify} transformer. It will inline expressions, remove dead branches, apply/remove assertions, optimize quantifiers, and more.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ JS,\ NFA,\ Transformers,\ transform\ \}\ from\ "{}refa"{};}
\DoxyCodeLine{}
\DoxyCodeLine{const\ regex\ =\ /\(\backslash\)b(?!\(\backslash\)d)\(\backslash\)w+\(\backslash\)b|-\/>/;}
\DoxyCodeLine{const\ \{\ expression,\ maxCharacter\ \}\ =\ JS.Parser.fromLiteral(regex).parse();}
\DoxyCodeLine{console.log(JS.toLiteral(expression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '\(\backslash\)\(\backslash\)b(?!\(\backslash\)\(\backslash\)d)\(\backslash\)\(\backslash\)w+\(\backslash\)\(\backslash\)b|-\/>',\ flags:\ ''\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ modifiedExpression\ =\ transform(Transformers.simplify(),\ expression);}
\DoxyCodeLine{console.log(JS.toLiteral(modifiedExpression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '(?<!\(\backslash\)\(\backslash\)w)[A-\/Z\_]\(\backslash\)\(\backslash\)w*(?!\(\backslash\)\(\backslash\)w)|-\/>',\ flags:\ 'i'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Most\ assertions\ have\ been\ removed\ but\ the\ patterns\ are\ still\ equivalent.}
\DoxyCodeLine{//\ The\ only\ assertions\ left\ assert\ characters\ beyond\ the\ edge\ of\ the\ pattern.}
\DoxyCodeLine{//\ Removing\ those\ assertions\ is\ easy\ but\ slightly\ changes\ the\ pattern.}
\DoxyCodeLine{}
\DoxyCodeLine{const\ finalExpression\ =\ transform(Transformers.patternEdgeAssertions(\{\ remove:\ true\ \}),\ modifiedExpression);}
\DoxyCodeLine{console.log(JS.toLiteral(finalExpression));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '[A-\/Z\_]\(\backslash\)\(\backslash\)w*|-\/>',\ flags:\ 'i'\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ nfa\ =\ NFA.fromRegex(finalExpression,\ \{\ maxCharacter\ \});}
\DoxyCodeLine{console.log(JS.toLiteral(nfa.toRegex()));}
\DoxyCodeLine{//\ =>\ \{\ source:\ '-\/>|[A-\/Z\_]\(\backslash\)\(\backslash\)w*',\ flags:\ 'i'\ \}}

\end{DoxyCode}


AST transformers can handle a lot of assertions, but there are limitations. Transformers cannot handle assertions that are too complex or require large-\/scale changes to the AST. Let\textquotesingle{}s take a look at a few examples\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ JS,\ Transformers,\ transform\ \}\ from\ "{}refa"{};}
\DoxyCodeLine{}
\DoxyCodeLine{function\ simplify(regex:\ RegExp):\ void\ \{}
\DoxyCodeLine{\ \ const\ \{\ expression\ \}\ =\ JS.Parser.fromLiteral(regex).parse();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ const\ simplifiedExpression\ =\ transform(Transformers.simplify(),\ expression);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ const\ literal\ =\ JS.toLiteral(simplifiedExpression);}
\DoxyCodeLine{\ \ console.log(new\ RegExp(literal.source,\ literal.flags));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{simplify(/\(\backslash\)b(?!\(\backslash\)d)\(\backslash\)b\(\backslash\)w+\(\backslash\)b\(\backslash\)s*\(\backslash\)(/);}
\DoxyCodeLine{//\ =>\ /(?<!\(\backslash\)w)[A-\/Z\_]\(\backslash\)w*\(\backslash\)s*\(\backslash\)(/i}
\DoxyCodeLine{simplify(/(?:\string^|@)\(\backslash\)b\(\backslash\)w+\(\backslash\)b/);}
\DoxyCodeLine{//\ =>\ /(?:\string^|@)\(\backslash\)w+(?!\(\backslash\)w)/}
\DoxyCodeLine{simplify(/"{}"{}"{}(?:(?!"{}"{}"{}).)*"{}"{}"{}/s);}
\DoxyCodeLine{//\ =>\ /"{}"{}"{}(?:"{}\{0,2\}[\string^"{}])*"{}"{}"{}/}
\DoxyCodeLine{simplify(/"{}"{}"{}((?!"{}"{}"{})(?:[\string^\(\backslash\)\(\backslash\)]|\(\backslash\)\(\backslash\)"{}))*"{}"{}"{}/);}
\DoxyCodeLine{//\ =>\ /"{}"{}"{}(?:"{}\{0,2\}(?:[\string^"{}\(\backslash\)\(\backslash\)]|\(\backslash\)\(\backslash\)"{}))*"{}"{}"{}/}
\DoxyCodeLine{simplify(/<title>(?:(?!<\(\backslash\)/title>).)*<\(\backslash\)/title>/s);}
\DoxyCodeLine{//\ =>\ /<title>(?:[\string^<]|<+(?:[\string^/<]|\(\backslash\)/(?!title>)))*<+\(\backslash\)/title>/}
\DoxyCodeLine{simplify(/\string^}

\end{DoxyCode}
 \$.\texorpdfstring{$\ast$}{*}?\texorpdfstring{$^\wedge$}{\string^}{\ttfamily \$/ms); // =\texorpdfstring{$>$}{>} /\texorpdfstring{$^\wedge$}{\string^}}\mbox{[}~\newline
\textbackslash{}r\textbackslash{}u2028\textbackslash{}u2029\mbox{]}(?\+:\mbox{[}\texorpdfstring{$^\wedge$}{\string^}\mbox{]}\texorpdfstring{$\ast$}{*}?\mbox{[}~\newline
\textbackslash{}r\textbackslash{}u2028\textbackslash{}u2029\mbox{]})??{\ttfamily \$/m }



{\bfseries{Note }}\begin{adjustwidth}{1em}{0em}


{\ttfamily Transformers.\+simplify} is {\itshape very} aggressive when it comes to assertions. It will try to remove assertions whenever possible even if it means that the overall AST will become more complex (within some limits). This may result in longer/more complex regexes, but it will also allow {\ttfamily NFA} and {\ttfamily ENFA} to support many more regexes.

\end{adjustwidth}
