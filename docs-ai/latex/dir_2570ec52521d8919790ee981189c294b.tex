\doxysection{node\+\_\+modules/p-\/queue Directory Reference}
\hypertarget{dir_2570ec52521d8919790ee981189c294b}{}\label{dir_2570ec52521d8919790ee981189c294b}\index{node\_modules/p-\/queue Directory Reference@{node\_modules/p-\/queue Directory Reference}}


\doxysubsection{Detailed Description}
\begin{quote}
Promise queue with concurrency control \end{quote}


Useful for rate-\/limiting async (or sync) operations. For example, when interacting with a REST API or when doing CPU/memory intensive tasks.

For servers, you probably want a Redis-\/backed \href{https://github.com/sindresorhus/awesome-nodejs\#job-queues}{\texttt{ job queue}} instead.

Note that the project is feature complete. We are happy to review pull requests, but we don\textquotesingle{}t plan any further development. We are also not answering email support questions.\hypertarget{readme.md_autotoc_md25392}{}\doxysubsection{\texorpdfstring{Install}{Install}}\label{readme.md_autotoc_md25392}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm\ install\ p-\/queue}

\end{DoxyCode}


{\bfseries{Warning\+:}} This package is native \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules}{\texttt{ ESM}} and no longer provides a Common\+JS export. If your project uses Common\+JS, you\textquotesingle{}ll have to \href{https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c}{\texttt{ convert to ESM}}. Please don\textquotesingle{}t open issues for questions regarding Common\+JS / ESM.\hypertarget{readme.md_autotoc_md25393}{}\doxysubsection{\texorpdfstring{Usage}{Usage}}\label{readme.md_autotoc_md25393}
Here we run only one promise at the time. For example, set {\ttfamily concurrency} to 4 to run four promises at the same time.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{import\ got\ from\ 'got';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.add(()\ =>\ got('https://sindresorhus.com'));}
\DoxyCodeLine{\ \ \ \ console.log('Done:\ sindresorhus.com');}
\DoxyCodeLine{\})();}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.add(()\ =>\ got('https://avajs.dev'));}
\DoxyCodeLine{\ \ \ \ console.log('Done:\ avajs.dev');}
\DoxyCodeLine{\})();}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ const\ task\ =\ await\ getUnicornTask();}
\DoxyCodeLine{\ \ \ \ await\ queue.add(task);}
\DoxyCodeLine{\ \ \ \ console.log('Done:\ Unicorn\ task');}
\DoxyCodeLine{\})();}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25394}{}\doxysubsection{\texorpdfstring{API}{API}}\label{readme.md_autotoc_md25394}
\hypertarget{readme.md_autotoc_md25395}{}\doxysubsubsection{\texorpdfstring{PQueue(options?)}{PQueue(options?)}}\label{readme.md_autotoc_md25395}
Returns a new {\ttfamily queue} instance, which is an \href{https://github.com/primus/eventemitter3}{\texttt{ {\ttfamily Event\+Emitter3}}} subclass.\hypertarget{readme.md_autotoc_md25396}{}\doxysubsubsubsection{\texorpdfstring{options}{options}}\label{readme.md_autotoc_md25396}
Type\+: {\ttfamily object}\hypertarget{readme.md_autotoc_md25397}{}\doxysubsubsubsubsection{\texorpdfstring{concurrency}{concurrency}}\label{readme.md_autotoc_md25397}
Type\+: {\ttfamily number}\textbackslash{} Default\+: {\ttfamily Infinity}\textbackslash{} Minimum\+: {\ttfamily 1}

Concurrency limit.\hypertarget{readme.md_autotoc_md25398}{}\doxysubsubsubsubsection{\texorpdfstring{timeout}{timeout}}\label{readme.md_autotoc_md25398}
Type\+: {\ttfamily number}

Per-\/operation timeout in milliseconds. Operations fulfill once {\ttfamily timeout} elapses if they haven\textquotesingle{}t already.\hypertarget{readme.md_autotoc_md25399}{}\doxysubsubsubsubsection{\texorpdfstring{throw\+On\+Timeout}{throw\+On\+Timeout}}\label{readme.md_autotoc_md25399}
Type\+: {\ttfamily boolean}\textbackslash{} Default\+: {\ttfamily false}

Whether or not a timeout is considered an exception.\hypertarget{readme.md_autotoc_md25400}{}\doxysubsubsubsubsection{\texorpdfstring{auto\+Start}{auto\+Start}}\label{readme.md_autotoc_md25400}
Type\+: {\ttfamily boolean}\textbackslash{} Default\+: {\ttfamily true}

Whether queue tasks within concurrency limit, are auto-\/executed as soon as they\textquotesingle{}re added.\hypertarget{readme.md_autotoc_md25401}{}\doxysubsubsubsubsection{\texorpdfstring{queue\+Class}{queue\+Class}}\label{readme.md_autotoc_md25401}
Type\+: {\ttfamily Function}

Class with a {\ttfamily enqueue} and {\ttfamily dequeue} method, and a {\ttfamily size} getter. See the Custom Queue\+Class section.\hypertarget{readme.md_autotoc_md25402}{}\doxysubsubsubsubsection{\texorpdfstring{interval\+Cap}{interval\+Cap}}\label{readme.md_autotoc_md25402}
Type\+: {\ttfamily number}\textbackslash{} Default\+: {\ttfamily Infinity}\textbackslash{} Minimum\+: {\ttfamily 1}

The max number of runs in the given interval of time.\hypertarget{readme.md_autotoc_md25403}{}\doxysubsubsubsubsection{\texorpdfstring{interval}{interval}}\label{readme.md_autotoc_md25403}
Type\+: {\ttfamily number}\textbackslash{} Default\+: {\ttfamily 0}\textbackslash{} Minimum\+: {\ttfamily 0}

The length of time in milliseconds before the interval count resets. Must be finite.\hypertarget{readme.md_autotoc_md25404}{}\doxysubsubsubsubsection{\texorpdfstring{carryover\+Concurrency\+Count}{carryover\+Concurrency\+Count}}\label{readme.md_autotoc_md25404}
Type\+: {\ttfamily boolean}\textbackslash{} Default\+: {\ttfamily false}

If {\ttfamily true}, specifies that any \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{\texttt{ pending}} Promises, should be carried over into the next interval and counted against the {\ttfamily interval\+Cap}. If {\ttfamily false}, any of those pending Promises will not count towards the next {\ttfamily interval\+Cap}.\hypertarget{readme.md_autotoc_md25405}{}\doxysubsubsection{\texorpdfstring{queue}{queue}}\label{readme.md_autotoc_md25405}
{\ttfamily PQueue} instance.\hypertarget{readme.md_autotoc_md25406}{}\doxysubsubsubsection{\texorpdfstring{.add(fn, options?)}{.add(fn, options?)}}\label{readme.md_autotoc_md25406}
Adds a sync or async task to the queue.

Returns a promise with the return value of {\ttfamily fn}.

Note\+: If your items can potentially throw an exception, you must handle those errors from the returned Promise or they may be reported as an unhandled Promise rejection and potentially cause your process to exit immediately.\hypertarget{readme.md_autotoc_md25407}{}\doxysubsubsubsubsection{\texorpdfstring{fn}{fn}}\label{readme.md_autotoc_md25407}
Type\+: {\ttfamily Function}

Promise-\/returning/async function. When executed, it will receive {\ttfamily \{signal\}} as the first argument.\hypertarget{readme.md_autotoc_md25408}{}\doxysubsubsubsection{\texorpdfstring{options}{options}}\label{readme.md_autotoc_md25408}
Type\+: {\ttfamily object}\hypertarget{readme.md_autotoc_md25409}{}\doxysubsubsubsubsection{\texorpdfstring{priority}{priority}}\label{readme.md_autotoc_md25409}
Type\+: {\ttfamily number}\textbackslash{} Default\+: {\ttfamily 0}

Priority of operation. Operations with greater priority will be scheduled first.\hypertarget{readme.md_autotoc_md25410}{}\doxysubsubsubsubsection{\texorpdfstring{id}{id}}\label{readme.md_autotoc_md25410}
Type {\ttfamily string}

Unique identifier for the promise function, used to update its priority before execution. If not specified, it is auto-\/assigned an incrementing Big\+Int starting from {\ttfamily 1n}.\hypertarget{readme.md_autotoc_md25411}{}\doxysubsubsubsubsection{\texorpdfstring{signal}{signal}}\label{readme.md_autotoc_md25411}
\href{https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}{\texttt{ {\ttfamily Abort\+Signal}}} for cancellation of the operation. When aborted, it will be removed from the queue and the {\ttfamily queue.\+add()} call will reject with an \href{https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason}{\texttt{ error}}. If the operation is already running, the signal will need to be handled by the operation itself.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{import\ got,\ \{CancelError\}\ from\ 'got';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue();}
\DoxyCodeLine{}
\DoxyCodeLine{const\ controller\ =\ new\ AbortController();}
\DoxyCodeLine{}
\DoxyCodeLine{try\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.add((\{signal\})\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ const\ request\ =\ got('https://sindresorhus.com');}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ signal.addEventListener('abort',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ request.cancel();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ try\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ return\ await\ request;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}\ catch\ (error)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ if\ (!(error\ instanceof\ CancelError))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ throw\ error;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \},\ \{signal:\ controller.signal\});}
\DoxyCodeLine{\}\ catch\ (error)\ \{}
\DoxyCodeLine{\ \ \ \ if\ (!(error\ instanceof\ DOMException))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ throw\ error;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25412}{}\doxysubsubsubsection{\texorpdfstring{.add\+All(fns, options?)}{.add\+All(fns, options?)}}\label{readme.md_autotoc_md25412}
Same as {\ttfamily .add()}, but accepts an array of sync or async functions and returns a promise that resolves when all functions are resolved.\hypertarget{readme.md_autotoc_md25413}{}\doxysubsubsubsection{\texorpdfstring{.pause()}{.pause()}}\label{readme.md_autotoc_md25413}
Put queue execution on hold.\hypertarget{readme.md_autotoc_md25414}{}\doxysubsubsubsection{\texorpdfstring{.start()}{.start()}}\label{readme.md_autotoc_md25414}
Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via {\ttfamily options.\+auto\+Start = false} or by {\ttfamily .pause()} method.)

Returns {\ttfamily this} (the instance).\hypertarget{readme.md_autotoc_md25415}{}\doxysubsubsubsection{\texorpdfstring{.on\+Empty()}{.on\+Empty()}}\label{readme.md_autotoc_md25415}
Returns a promise that settles when the queue becomes empty.

Can be called multiple times. Useful if you for example add additional items at a later time.\hypertarget{readme.md_autotoc_md25416}{}\doxysubsubsubsection{\texorpdfstring{.on\+Idle()}{.on\+Idle()}}\label{readme.md_autotoc_md25416}
Returns a promise that settles when the queue becomes empty, and all promises have completed; {\ttfamily queue.\+size === 0 \&\& queue.\+pending === 0}.

The difference with {\ttfamily .on\+Empty} is that {\ttfamily .on\+Idle} guarantees that all work from the queue has finished. {\ttfamily .on\+Empty} merely signals that the queue is empty, but it could mean that some promises haven\textquotesingle{}t completed yet.\hypertarget{readme.md_autotoc_md25417}{}\doxysubsubsubsection{\texorpdfstring{.on\+Size\+Less\+Than(limit)}{.on\+Size\+Less\+Than(limit)}}\label{readme.md_autotoc_md25417}
Returns a promise that settles when the queue size is less than the given limit\+: {\ttfamily queue.\+size \texorpdfstring{$<$}{<} limit}.

If you want to avoid having the queue grow beyond a certain size you can {\ttfamily await queue.\+on\+Size\+Less\+Than()} before adding a new item.

Note that this only limits the number of items waiting to start. There could still be up to {\ttfamily concurrency} jobs already running that this call does not include in its calculation.\hypertarget{readme.md_autotoc_md25418}{}\doxysubsubsubsection{\texorpdfstring{.clear()}{.clear()}}\label{readme.md_autotoc_md25418}
Clear the queue.\hypertarget{readme.md_autotoc_md25419}{}\doxysubsubsubsection{\texorpdfstring{.size}{.size}}\label{readme.md_autotoc_md25419}
Size of the queue, the number of queued items waiting to run.\hypertarget{readme.md_autotoc_md25420}{}\doxysubsubsubsection{\texorpdfstring{.size\+By(options)}{.size\+By(options)}}\label{readme.md_autotoc_md25420}
Size of the queue, filtered by the given options.

For example, this can be used to find the number of items remaining in the queue with a specific priority level.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue();}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 0\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(queue.sizeBy(\{priority:\ 1\}));}
\DoxyCodeLine{//=>\ 2}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(queue.sizeBy(\{priority:\ 0\}));}
\DoxyCodeLine{//=>\ 1}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25421}{}\doxysubsubsubsection{\texorpdfstring{.set\+Priority(id, priority)}{.set\+Priority(id, priority)}}\label{readme.md_autotoc_md25421}
Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.

For example, this can be used to prioritize a promise function to run earlier.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ä',\ \{priority:\ 0,\ id:\ 'ü¶Ä'\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.setPriority('ü¶Ä',\ 2);}

\end{DoxyCode}


In this case, the promise function with `id\+: \textquotesingle{}ü¶Ä'\`{} runs second.

You can also deprioritize a promise function to delay its execution\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 1\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ä',\ \{priority:\ 1,\ id:\ 'ü¶Ä'\});}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ');}
\DoxyCodeLine{queue.add(async\ ()\ =>\ 'ü¶Ñ',\ \{priority:\ 0\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.setPriority('ü¶Ä',\ -\/1);}

\end{DoxyCode}


Here, the promise function with `id\+: \textquotesingle{}ü¶Ä'\`{} executes last.\hypertarget{readme.md_autotoc_md25422}{}\doxysubsubsubsection{\texorpdfstring{.pending}{.pending}}\label{readme.md_autotoc_md25422}
Number of running items (no longer in the queue).\hypertarget{readme.md_autotoc_md25423}{}\doxysubsubsubsection{\texorpdfstring{\protect\doxylink{README.md_timeout}{.timeout}}{{.timeout}}}\label{readme.md_autotoc_md25423}
\hypertarget{readme.md_autotoc_md25424}{}\doxysubsubsubsection{\texorpdfstring{\protect\doxylink{README.md_concurrency}{.concurrency}}{{.concurrency}}}\label{readme.md_autotoc_md25424}
\hypertarget{readme.md_autotoc_md25425}{}\doxysubsubsubsection{\texorpdfstring{.is\+Paused}{.is\+Paused}}\label{readme.md_autotoc_md25425}
Whether the queue is currently paused.\hypertarget{readme.md_autotoc_md25426}{}\doxysubsection{\texorpdfstring{Events}{Events}}\label{readme.md_autotoc_md25426}
\hypertarget{readme.md_autotoc_md25427}{}\doxysubsubsubsection{\texorpdfstring{active}{active}}\label{readme.md_autotoc_md25427}
Emitted as each item is processed in the queue for the purpose of tracking progress.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 2\});}
\DoxyCodeLine{}
\DoxyCodeLine{let\ count\ =\ 0;}
\DoxyCodeLine{queue.on('active',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log(`Working\ on\ item\ \#\$\{++count\}.\ \ Size:\ \$\{queue.size\}\ \ Pending:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(()\ =>\ Promise.resolve());}
\DoxyCodeLine{queue.add(()\ =>\ delay(2000));}
\DoxyCodeLine{queue.add(()\ =>\ Promise.resolve());}
\DoxyCodeLine{queue.add(()\ =>\ Promise.resolve());}
\DoxyCodeLine{queue.add(()\ =>\ delay(500));}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25428}{}\doxysubsubsubsection{\texorpdfstring{completed}{completed}}\label{readme.md_autotoc_md25428}
Emitted when an item completes without error.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 2\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.on('completed',\ result\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log(result);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(()\ =>\ Promise.resolve('hello,\ world!'));}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25429}{}\doxysubsubsubsection{\texorpdfstring{error}{error}}\label{readme.md_autotoc_md25429}
Emitted if an item throws an error.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 2\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.on('error',\ error\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.error(error);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(()\ =>\ Promise.reject(new\ Error('error')));}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25430}{}\doxysubsubsubsection{\texorpdfstring{empty}{empty}}\label{readme.md_autotoc_md25430}
Emitted every time the queue becomes empty.

Useful if you for example add additional items at a later time.\hypertarget{readme.md_autotoc_md25431}{}\doxysubsubsubsection{\texorpdfstring{idle}{idle}}\label{readme.md_autotoc_md25431}
Emitted every time the queue becomes empty and all promises have completed; {\ttfamily queue.\+size === 0 \&\& queue.\+pending === 0}.

The difference with {\ttfamily empty} is that {\ttfamily idle} guarantees that all work from the queue has finished. {\ttfamily empty} merely signals that the queue is empty, but it could mean that some promises haven\textquotesingle{}t completed yet.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue();}
\DoxyCodeLine{}
\DoxyCodeLine{queue.on('idle',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log(`Queue\ is\ idle.\ \ Size:\ \$\{queue.size\}\ \ Pending:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ job1\ =\ queue.add(()\ =>\ delay(2000));}
\DoxyCodeLine{const\ job2\ =\ queue.add(()\ =>\ delay(500));}
\DoxyCodeLine{}
\DoxyCodeLine{await\ job1;}
\DoxyCodeLine{await\ job2;}
\DoxyCodeLine{//\ =>\ 'Queue\ is\ idle.\ \ Size:\ 0\ \ Pending:\ 0'}
\DoxyCodeLine{}
\DoxyCodeLine{await\ queue.add(()\ =>\ delay(600));}
\DoxyCodeLine{//\ =>\ 'Queue\ is\ idle.\ \ Size:\ 0\ \ Pending:\ 0'}

\end{DoxyCode}


The {\ttfamily idle} event is emitted every time the queue reaches an idle state. On the other hand, the promise the {\ttfamily on\+Idle()} function returns resolves once the queue becomes idle instead of every time the queue is idle.\hypertarget{readme.md_autotoc_md25432}{}\doxysubsubsubsection{\texorpdfstring{add}{add}}\label{readme.md_autotoc_md25432}
Emitted every time the add method is called and the number of pending or queued tasks is increased.\hypertarget{readme.md_autotoc_md25433}{}\doxysubsubsubsection{\texorpdfstring{next}{next}}\label{readme.md_autotoc_md25433}
Emitted every time a task is completed and the number of pending or queued tasks is decreased. This is emitted regardless of whether the task completed normally or with an error.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue();}
\DoxyCodeLine{}
\DoxyCodeLine{queue.on('add',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log(`Task\ is\ added.\ \ Size:\ \$\{queue.size\}\ \ Pending:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{queue.on('next',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log(`Task\ is\ completed.\ \ Size:\ \$\{queue.size\}\ \ Pending:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ job1\ =\ queue.add(()\ =>\ delay(2000));}
\DoxyCodeLine{const\ job2\ =\ queue.add(()\ =>\ delay(500));}
\DoxyCodeLine{}
\DoxyCodeLine{await\ job1;}
\DoxyCodeLine{await\ job2;}
\DoxyCodeLine{//=>\ 'Task\ is\ added.\ \ Size:\ 0\ \ Pending:\ 1'}
\DoxyCodeLine{//=>\ 'Task\ is\ added.\ \ Size:\ 0\ \ Pending:\ 2'}
\DoxyCodeLine{}
\DoxyCodeLine{await\ queue.add(()\ =>\ delay(600));}
\DoxyCodeLine{//=>\ 'Task\ is\ completed.\ \ Size:\ 0\ \ Pending:\ 1'}
\DoxyCodeLine{//=>\ 'Task\ is\ completed.\ \ Size:\ 0\ \ Pending:\ 0'}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25434}{}\doxysubsection{\texorpdfstring{Advanced example}{Advanced example}}\label{readme.md_autotoc_md25434}
A more advanced example to help you understand the flow.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ delay\ from\ 'delay';}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{concurrency:\ 1\});}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ delay(200);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ console.log(`8.\ Pending\ promises:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\ \ \ \ //=>\ '8.\ Pending\ promises:\ 0'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ (async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ await\ queue.add(async\ ()\ =>\ 'üêô');}
\DoxyCodeLine{\ \ \ \ \ \ \ \ console.log('11.\ Resolved')}
\DoxyCodeLine{\ \ \ \ \})();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ console.log('9.\ Added\ üêô');}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ console.log(`10.\ Pending\ promises:\ \$\{queue.pending\}`);}
\DoxyCodeLine{\ \ \ \ //=>\ '10.\ Pending\ promises:\ 1'}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ await\ queue.onIdle();}
\DoxyCodeLine{\ \ \ \ console.log('12.\ All\ work\ is\ done');}
\DoxyCodeLine{\})();}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.add(async\ ()\ =>\ 'ü¶Ñ');}
\DoxyCodeLine{\ \ \ \ console.log('5.\ Resolved')}
\DoxyCodeLine{\})();}
\DoxyCodeLine{console.log('1.\ Added\ ü¶Ñ');}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.add(async\ ()\ =>\ 'üê¥');}
\DoxyCodeLine{\ \ \ \ console.log('6.\ Resolved')}
\DoxyCodeLine{\})();}
\DoxyCodeLine{console.log('2.\ Added\ üê¥');}
\DoxyCodeLine{}
\DoxyCodeLine{(async\ ()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ await\ queue.onEmpty();}
\DoxyCodeLine{\ \ \ \ console.log('7.\ Queue\ is\ empty');}
\DoxyCodeLine{\})();}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(`3.\ Queue\ size:\ \$\{queue.size\}`);}
\DoxyCodeLine{//=>\ '3.\ Queue\ size:\ 1`}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(`4.\ Pending\ promises:\ \$\{queue.pending\}`);}
\DoxyCodeLine{//=>\ '4.\ Pending\ promises:\ 1'}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ node\ example.js}
\DoxyCodeLine{1.\ Added\ ü¶Ñ}
\DoxyCodeLine{2.\ Added\ üê¥}
\DoxyCodeLine{3.\ Queue\ size:\ 1}
\DoxyCodeLine{4.\ Pending\ promises:\ 1}
\DoxyCodeLine{5.\ Resolved\ ü¶Ñ}
\DoxyCodeLine{6.\ Resolved\ üê¥}
\DoxyCodeLine{7.\ Queue\ is\ empty}
\DoxyCodeLine{8.\ Pending\ promises:\ 0}
\DoxyCodeLine{9.\ Added\ üêô}
\DoxyCodeLine{10.\ Pending\ promises:\ 1}
\DoxyCodeLine{11.\ Resolved\ üêô}
\DoxyCodeLine{12.\ All\ work\ is\ done}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md25435}{}\doxysubsection{\texorpdfstring{Custom Queue\+Class}{Custom Queue\+Class}}\label{readme.md_autotoc_md25435}
For implementing more complex scheduling policies, you can provide a Queue\+Class in the options\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ PQueue\ from\ 'p-\/queue';}
\DoxyCodeLine{}
\DoxyCodeLine{class\ QueueClass\ \{}
\DoxyCodeLine{\ \ \ \ constructor()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ this.\_queue\ =\ [];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ enqueue(run,\ options)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ this.\_queue.push(run);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ dequeue()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ this.\_queue.shift();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ get\ size()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ this.\_queue.length;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ filter(options)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ return\ this.\_queue;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const\ queue\ =\ new\ PQueue(\{queueClass:\ QueueClass\});}

\end{DoxyCode}


{\ttfamily p-\/queue} will call corresponding methods to put and get operations from this queue.\hypertarget{readme.md_autotoc_md25436}{}\doxysubsection{\texorpdfstring{FAQ}{FAQ}}\label{readme.md_autotoc_md25436}
\hypertarget{readme.md_autotoc_md25437}{}\doxysubsubsubsection{\texorpdfstring{How do the {\ttfamily concurrency} and {\ttfamily interval\+Cap} options affect each other?}{How do the {\ttfamily concurrency} and {\ttfamily interval\+Cap} options affect each other?}}\label{readme.md_autotoc_md25437}
They are just different constraints. The {\ttfamily concurrency} option limits how many things run at the same time. The {\ttfamily interval\+Cap} option limits how many things run in total during the interval (over time).\hypertarget{readme.md_autotoc_md25438}{}\doxysubsection{\texorpdfstring{Maintainers}{Maintainers}}\label{readme.md_autotoc_md25438}

\begin{DoxyItemize}
\item \href{https://github.com/sindresorhus}{\texttt{ Sindre Sorhus}}
\item \href{https://github.com/Richienb}{\texttt{ Richie Bendall}}
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md25439}{}\doxysubsection{\texorpdfstring{Related}{Related}}\label{readme.md_autotoc_md25439}

\begin{DoxyItemize}
\item \href{https://github.com/sindresorhus/p-limit}{\texttt{ p-\/limit}} -\/ Run multiple promise-\/returning \& async functions with limited concurrency
\item \href{https://github.com/sindresorhus/p-throttle}{\texttt{ p-\/throttle}} -\/ Throttle promise-\/returning \& async functions
\item \href{https://github.com/sindresorhus/p-debounce}{\texttt{ p-\/debounce}} -\/ Debounce promise-\/returning \& async functions
\item \href{https://github.com/sindresorhus/p-all}{\texttt{ p-\/all}} -\/ Run promise-\/returning \& async functions concurrently with optional limited concurrency
\item \href{https://github.com/sindresorhus/promise-fun}{\texttt{ More‚Ä¶}} 
\end{DoxyItemize}