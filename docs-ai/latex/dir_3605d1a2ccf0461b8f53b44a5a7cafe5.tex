\doxysection{node\+\_\+modules/swrv Directory Reference}
\hypertarget{dir_3605d1a2ccf0461b8f53b44a5a7cafe5}{}\label{dir_3605d1a2ccf0461b8f53b44a5a7cafe5}\index{node\_modules/swrv Directory Reference@{node\_modules/swrv Directory Reference}}


\doxysubsection{Detailed Description}


 

\doxysubsection*{swrv}

\href{https://www.npmjs.com/package/swrv}{\texttt{ }} \href{https://www.npmjs.com/package/swrv}{\texttt{ }} 

{\ttfamily swrv} (pronounced "{}swerve"{}) is a library using the \href{https://vuejs.org/guide/extras/composition-api-faq.html}{\texttt{ Vue Composition API}} for remote data fetching. It is largely a port of \href{https://github.com/zeit/swr}{\texttt{ swr}}.


\begin{DoxyItemize}
\item \href{https://docs-swrv.netlify.app/}{\texttt{ Documentation}}
\end{DoxyItemize}

The name “\+SWR” is derived from stale-\/while-\/revalidate, a cache invalidation strategy popularized by HTTP \href{https://tools.ietf.org/html/rfc5861}{\texttt{ RFC 5861}}. SWR first returns the data from cache (stale), then sends the fetch request (revalidate), and finally comes with the up-\/to-\/date data again.

Features\+:


\begin{DoxyItemize}
\item Transport and protocol agnostic data fetching
\item Fast page navigation
\item Interval polling
\item \sout{SSR support} (removed as of version {\ttfamily 0.\+10.\+0} -\/ \href{https://github.com/Kong/swrv/pull/304}{\texttt{ read more}})
\item Vue 3 Support
\item Revalidation on focus
\item Request deduplication
\item Type\+Script ready
\item Minimal API
\item Stale-\/if-\/error
\item Customizable cache implementation
\item Error Retry
\end{DoxyItemize}

With {\ttfamily swrv}, components will get a stream of data updates constantly and automatically. Thus, the UI will be always fast and reactive.\hypertarget{README.md_autotoc_md31781}{}\doxysubsubsection{\texorpdfstring{Table of Contents}{Table of Contents}}\label{README.md_autotoc_md31781}

\begin{DoxyItemize}
\item \doxylink{README.md_installation}{Installation}
\begin{DoxyItemize}
\item Vue 3
\item Vue 2.7
\item Vue 2.6 and below
\end{DoxyItemize}
\item Getting Started
\item \doxylink{README.md_api}{Api}
\begin{DoxyItemize}
\item Parameters
\item Return Values
\item Config options
\end{DoxyItemize}
\item Prefetching
\item Dependent Fetching
\item Stale-\/if-\/error
\item State Management
\begin{DoxyItemize}
\item use\+Swrv\+State
\item Vuex
\end{DoxyItemize}
\item \doxylink{README.md_cache}{Cache}
\begin{DoxyItemize}
\item local\+Storage
\item Serve from cache only
\end{DoxyItemize}
\item Error Handling
\item \doxylink{md_node__modules_2safer-buffer_2_porting-_buffer_faq}{FAQ}
\begin{DoxyItemize}
\item How is swrv different from the swr react library
\item Why does swrv make so many requests
\item How can I refetch swrv data to update it
\end{DoxyItemize}
\item Contributors ✨
\end{DoxyItemize}\hypertarget{README.md_autotoc_md31782}{}\doxysubsubsection{\texorpdfstring{Installation}{Installation}}\label{README.md_autotoc_md31782}
The version of {\ttfamily swrv} you install depends on the Vue dependency in your project.\hypertarget{README.md_autotoc_md31783}{}\doxysubsubsubsection{\texorpdfstring{Vue 3}{Vue 3}}\label{README.md_autotoc_md31783}

\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ Install\ the\ latest\ version}
\DoxyCodeLine{yarn\ add\ swrv}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31784}{}\doxysubsubsubsection{\texorpdfstring{Vue 2.\+7}{Vue 2.\+7}}\label{README.md_autotoc_md31784}
This version removes the dependency of the external {\ttfamily @vue/composition-\/api} plugin and adds {\ttfamily vue} to the {\ttfamily peer\+Dependencies}, requiring a version that matches the following pattern\+: {\ttfamily \texorpdfstring{$>$}{>}= 2.\+7.\+0 \texorpdfstring{$<$}{<} 3}


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ Install\ the\ 0.10.x\ version\ for\ Vue\ 2.7}
\DoxyCodeLine{yarn\ add\ swrv@v2-\/latest}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31785}{}\doxysubsubsubsection{\texorpdfstring{Vue 2.\+6 and below}{Vue 2.\+6 and below}}\label{README.md_autotoc_md31785}
If you\textquotesingle{}re installing for Vue {\ttfamily 2.\+6.\+x} and below, you may want to check out a \href{https://github.com/Kong/swrv/blob/b621aac02b7780a4143c5743682070223e793b10/README.md}{\texttt{ previous version of the README}} to view how to initialize {\ttfamily swrv} utilizing the external {\ttfamily @vue/composition-\/api} plugin.


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ Install\ the\ 0.9.x\ version\ for\ Vue\ <\ 2.7}
\DoxyCodeLine{yarn\ add\ swrv@legacy}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31786}{}\doxysubsubsection{\texorpdfstring{Getting Started}{Getting Started}}\label{README.md_autotoc_md31786}

\begin{DoxyCode}{0}
\DoxyCodeLine{<template>}
\DoxyCodeLine{\ \ <div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/if="{}error"{}>failed\ to\ load</div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/if="{}!data"{}>loading...</div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/else>hello\ \{\{\ data.name\ \}\}</div>}
\DoxyCodeLine{\ \ </div>}
\DoxyCodeLine{</template>}
\DoxyCodeLine{}
\DoxyCodeLine{<script>}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ \{}
\DoxyCodeLine{\ \ name:\ 'Profile',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ setup()\ \{}
\DoxyCodeLine{\ \ \ \ const\ \{\ data,\ error\ \}\ =\ useSWRV('/api/user',\ fetcher)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ data,}
\DoxyCodeLine{\ \ \ \ \ \ error,}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}
\DoxyCodeLine{</script>}

\end{DoxyCode}


In this example, the Vue Hook {\ttfamily use\+SWRV} accepts a {\ttfamily key} and a {\ttfamily fetcher} function. {\ttfamily key} is a unique identifier of the request, normally the URL of the API. And the fetcher accepts key as its parameter and returns the data asynchronously.

{\ttfamily use\+SWRV} also returns 2 values\+: {\ttfamily data} and {\ttfamily error}. When the request (fetcher) is not yet finished, data will be {\ttfamily undefined}. And when we get a response, it sets {\ttfamily data} and {\ttfamily error} based on the result of fetcher and rerenders the component. This is because {\ttfamily data} and {\ttfamily error} are Vue \href{https://vuejs.org/api/reactivity-core.html\#ref}{\texttt{ Refs}}, and their values will be set by the fetcher response.

Note that fetcher can be any asynchronous function, so you can use your favorite data-\/fetching library to handle that part. When omitted, swrv falls back to the browser \href{https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}{\texttt{ Fetch API}}.\hypertarget{README.md_autotoc_md31787}{}\doxysubsubsection{\texorpdfstring{Api}{Api}}\label{README.md_autotoc_md31787}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ \{\ data,\ error,\ isValidating,\ mutate\ \}\ =\ useSWRV(key,\ fetcher,\ options)}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31788}{}\doxysubsubsubsection{\texorpdfstring{Parameters}{Parameters}}\label{README.md_autotoc_md31788}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Param   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Param   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-3}
\endhead
{\ttfamily key}   &yes   &a unique key string for the request (or a reactive reference / watcher function / null) (advanced usage)    \\\cline{1-3}
{\ttfamily fetcher}   &&a Promise returning function to fetch your data. If {\ttfamily null}, swrv will fetch from cache only and not revalidate. If omitted (i.\+e. {\ttfamily undefined}) then the \href{https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}{\texttt{ fetch}} api will be used.    \\\cline{1-3}
{\ttfamily options}   &&an object of configuration options   \\\cline{1-3}
\end{longtabu}
\hypertarget{README.md_autotoc_md31789}{}\doxysubsubsubsection{\texorpdfstring{Return Values}{Return Values}}\label{README.md_autotoc_md31789}

\begin{DoxyItemize}
\item {\ttfamily data}\+: data for the given key resolved by fetcher (or undefined if not loaded)
\item {\ttfamily error}\+: error thrown by fetcher (or undefined)
\item {\ttfamily is\+Validating}\+: if there\textquotesingle{}s a request or revalidation loading
\item {\ttfamily mutate}\+: function to trigger the validation manually
\end{DoxyItemize}\hypertarget{README.md_autotoc_md31790}{}\doxysubsubsubsection{\texorpdfstring{Config options}{Config options}}\label{README.md_autotoc_md31790}
See \href{https://github.com/Kong/swrv/blob/1587416e59dad12f9261e289b8cf63da81aa2dd4/src/use-swrv.ts\#L43}{\texttt{ Config Defaults}}


\begin{DoxyItemize}
\item {\ttfamily refresh\+Interval = 0} -\/ polling interval in milliseconds. 0 means this is disabled.
\item {\ttfamily deduping\+Interval = 2000} -\/ dedupe requests with the same key in this time span
\item {\ttfamily ttl = 0} -\/ time to live of response data in cache. 0 mean it stays around forever.
\item {\ttfamily should\+Retry\+On\+Error = true} -\/ retry when fetcher has an error
\item {\ttfamily error\+Retry\+Interval = 5000} -\/ error retry interval
\item {\ttfamily error\+Retry\+Count\+: 5} -\/ max error retry count
\item {\ttfamily revalidate\+On\+Focus = true} -\/ auto revalidate when window gets focused
\item {\ttfamily revalidate\+Debounce = 0} -\/ debounce in milliseconds for revalidation. Useful for when a component is serving from the cache immediately, but then un-\/mounts soon thereafter (e.\+g. a user clicking "{}next"{} in pagination quickly) to avoid unnecessary fetches.
\item {\ttfamily cache} -\/ caching instance to store response data in. See \href{src/lib/cache.ts}{\texttt{ src/lib/cache}}, and \doxylink{README.md_cache}{Cache} below.
\end{DoxyItemize}\hypertarget{README.md_autotoc_md31791}{}\doxysubsubsection{\texorpdfstring{Prefetching}{Prefetching}}\label{README.md_autotoc_md31791}
Prefetching can be useful for when you anticipate user actions, like hovering over a link. SWRV exposes the {\ttfamily mutate} function so that results can be stored in the SWRV cache at a predetermined time.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ mutate\ \}\ from\ 'swrv'}
\DoxyCodeLine{}
\DoxyCodeLine{function\ prefetch()\ \{}
\DoxyCodeLine{\ \ mutate(}
\DoxyCodeLine{\ \ \ \ '/api/data',}
\DoxyCodeLine{\ \ \ \ fetch('/api/data').then((res)\ =>\ res.json())}
\DoxyCodeLine{\ \ )}
\DoxyCodeLine{\ \ //\ the\ second\ parameter\ is\ a\ Promise}
\DoxyCodeLine{\ \ //\ SWRV\ will\ use\ the\ result\ when\ it\ resolves}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31792}{}\doxysubsubsection{\texorpdfstring{Dependent Fetching}{Dependent Fetching}}\label{README.md_autotoc_md31792}
swrv also allows you to fetch data that depends on other data. It ensures the maximum possible parallelism (avoiding waterfalls), as well as serial fetching when a piece of dynamic data is required for the next data fetch to happen.


\begin{DoxyCode}{0}
\DoxyCodeLine{<template>}
\DoxyCodeLine{\ \ <p\ v-\/if="{}!projects"{}>loading...</p>}
\DoxyCodeLine{\ \ <p\ v-\/else>You\ have\ \{\{\ projects.length\ \}\}\ projects</p>}
\DoxyCodeLine{</template>}
\DoxyCodeLine{}
\DoxyCodeLine{<script>}
\DoxyCodeLine{import\ \{\ ref\ \}\ from\ 'vue'}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ \{}
\DoxyCodeLine{\ \ name:\ 'Profile',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ setup()\ \{}
\DoxyCodeLine{\ \ \ \ const\ \{\ data:\ user\ \}\ =\ useSWRV('/api/user',\ fetch)}
\DoxyCodeLine{\ \ \ \ const\ \{\ data:\ projects\ \}\ =\ useSWRV(()\ =>\ user.value\ \&\&\ '/api/projects?uid='\ +\ user.value.id,\ fetch)}
\DoxyCodeLine{\ \ \ \ //\ if\ the\ return\ value\ of\ the\ cache\ key\ function\ is\ falsy,\ the\ fetcher}
\DoxyCodeLine{\ \ \ \ //\ will\ not\ trigger,\ but\ since\ \`{}user`\ is\ inside\ the\ cache\ key\ function,}
\DoxyCodeLine{\ \ \ \ //\ it\ is\ being\ watched\ so\ when\ it\ is\ available,\ then\ the\ projects\ will}
\DoxyCodeLine{\ \ \ \ //\ be\ fetched.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ user,}
\DoxyCodeLine{\ \ \ \ \ \ projects}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31793}{}\doxysubsubsection{\texorpdfstring{Stale-\/if-\/error}{Stale-\/if-\/error}}\label{README.md_autotoc_md31793}
One of the benefits of a stale content caching strategy is that the cache can be served when requests fail.{\ttfamily swrv} uses a \href{https://tools.ietf.org/html/rfc5861\#section-4}{\texttt{ stale-\/if-\/error}} strategy and will maintain {\ttfamily data} in the cache even if a {\ttfamily use\+SWRV} fetch returns an {\ttfamily error}.


\begin{DoxyCode}{0}
\DoxyCodeLine{<template>}
\DoxyCodeLine{\ \ <div\ v-\/if="{}error"{}>failed\ to\ load</div>}
\DoxyCodeLine{\ \ <div\ v-\/if="{}data\ ===\ undefined\ \&\&\ !error"{}>loading...</div>}
\DoxyCodeLine{\ \ <p\ v-\/if="{}data"{}>}
\DoxyCodeLine{\ \ \ \ hello\ \{\{\ data.name\ \}\}\ of\ \{\{\ data.birthplace\ \}\}.\ This\ content\ will\ continue}
\DoxyCodeLine{\ \ \ \ to\ appear\ even\ if\ future\ requests\ to\ \{\{\ endpoint\ \}\}\ fail!}
\DoxyCodeLine{\ \ </p>}
\DoxyCodeLine{</template>}
\DoxyCodeLine{}
\DoxyCodeLine{<script>}
\DoxyCodeLine{import\ \{\ ref\ \}\ from\ 'vue'}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ \{}
\DoxyCodeLine{\ \ name:\ 'Profile',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ setup()\ \{}
\DoxyCodeLine{\ \ \ \ const\ endpoint\ =\ ref('/api/user/Geralt')}
\DoxyCodeLine{\ \ \ \ const\ \{\ data,\ error\ \}\ =\ useSWRV(endpoint.value,\ fetch)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ endpoint,}
\DoxyCodeLine{\ \ \ \ \ \ data,}
\DoxyCodeLine{\ \ \ \ \ \ error,}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31794}{}\doxysubsubsection{\texorpdfstring{State Management}{State Management}}\label{README.md_autotoc_md31794}
\hypertarget{README.md_autotoc_md31795}{}\doxysubsubsubsection{\texorpdfstring{use\+Swrv\+State}{use\+Swrv\+State}}\label{README.md_autotoc_md31795}
Sometimes you might want to know the exact state where swrv is during stale-\/while-\/revalidate lifecyle. This is helpful when representing the UI as a function of state. Here is one way to detect state using a user-\/land composable {\ttfamily use\+Swrv\+State} function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ \{\ ref,\ watchEffect\ \}\ from\ 'vue'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ STATES\ =\ \{}
\DoxyCodeLine{\ \ VALIDATING:\ 'VALIDATING',}
\DoxyCodeLine{\ \ PENDING:\ 'PENDING',}
\DoxyCodeLine{\ \ SUCCESS:\ 'SUCCESS',}
\DoxyCodeLine{\ \ ERROR:\ 'ERROR',}
\DoxyCodeLine{\ \ STALE\_IF\_ERROR:\ 'STALE\_IF\_ERROR',}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ function(data,\ error,\ isValidating)\ \{}
\DoxyCodeLine{\ \ const\ state\ =\ ref('idle')}
\DoxyCodeLine{\ \ watchEffect(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ if\ (data.value\ \&\&\ isValidating.value)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state.value\ =\ STATES.VALIDATING}
\DoxyCodeLine{\ \ \ \ \ \ return}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ if\ (data.value\ \&\&\ error.value)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state.value\ =\ STATES.STALE\_IF\_ERROR}
\DoxyCodeLine{\ \ \ \ \ \ return}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ if\ (data.value\ ===\ undefined\ \&\&\ !error.value)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state.value\ =\ STATES.PENDING}
\DoxyCodeLine{\ \ \ \ \ \ return}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ if\ (data.value\ \&\&\ !error.value)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state.value\ =\ STATES.SUCCESS}
\DoxyCodeLine{\ \ \ \ \ \ return}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ if\ (data.value\ ===\ undefined\ \&\&\ error)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state.value\ =\ STATES.ERROR}
\DoxyCodeLine{\ \ \ \ \ \ return}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ return\ \{}
\DoxyCodeLine{\ \ \ \ state,}
\DoxyCodeLine{\ \ \ \ STATES,}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


And then in your template you can use it like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<template>}
\DoxyCodeLine{\ \ <div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/if="{}[STATES.ERROR,\ STATES.STALE\_IF\_ERROR].includes(state)"{}>}
\DoxyCodeLine{\ \ \ \ \ \ \{\{\ error\ \}\}}
\DoxyCodeLine{\ \ \ \ </div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/if="{}[STATES.PENDING].includes(state)"{}>Loading...</div>}
\DoxyCodeLine{\ \ \ \ <div\ v-\/if="{}[STATES.VALIDATING].includes(state)"{}>}
\DoxyCodeLine{\ \ \ \ \ \ <!-\/-\/\ serve\ stale\ content\ without\ "{}loading"{}\ -\/-\/>}
\DoxyCodeLine{\ \ \ \ </div>}
\DoxyCodeLine{\ \ \ \ <div}
\DoxyCodeLine{\ \ \ \ \ \ v-\/if="{}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ [STATES.SUCCESS,\ STATES.VALIDATING,\ STATES.STALE\_IF\_ERROR].includes(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ state}
\DoxyCodeLine{\ \ \ \ \ \ \ \ )}
\DoxyCodeLine{\ \ \ \ \ \ "{}}
\DoxyCodeLine{\ \ \ \ >}
\DoxyCodeLine{\ \ \ \ \ \ \{\{\ data\ \}\}}
\DoxyCodeLine{\ \ \ \ </div>}
\DoxyCodeLine{\ \ </div>}
\DoxyCodeLine{</template>}
\DoxyCodeLine{}
\DoxyCodeLine{<script>}
\DoxyCodeLine{import\ \{\ computed\ \}\ from\ 'vue'}
\DoxyCodeLine{import\ useSwrvState\ from\ '@/composables/useSwrvState'}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ \{}
\DoxyCodeLine{\ \ name:\ 'Repo',}
\DoxyCodeLine{\ \ setup(props,\ \{\ root\ \})\ \{}
\DoxyCodeLine{\ \ \ \ const\ page\ =\ computed(()\ =>\ root.\$route.params.id)}
\DoxyCodeLine{\ \ \ \ const\ \{\ data,\ error,\ isValidating\ \}\ =\ useSWRV(}
\DoxyCodeLine{\ \ \ \ \ \ ()\ =>\ \`{}/api/\$\{root.\$route.params.id\}`,}
\DoxyCodeLine{\ \ \ \ \ \ fetcher}
\DoxyCodeLine{\ \ \ \ )}
\DoxyCodeLine{\ \ \ \ const\ \{\ state,\ STATES\ \}\ =\ useSwrvState(data,\ error,\ isValidating)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ state,}
\DoxyCodeLine{\ \ \ \ \ \ STATES,}
\DoxyCodeLine{\ \ \ \ \ \ data,}
\DoxyCodeLine{\ \ \ \ \ \ error,}
\DoxyCodeLine{\ \ \ \ \ \ page,}
\DoxyCodeLine{\ \ \ \ \ \ isValidating,}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31796}{}\doxysubsubsubsection{\texorpdfstring{Vuex}{Vuex}}\label{README.md_autotoc_md31796}
Most of the features of swrv handle the complex logic / ceremony that you\textquotesingle{}d have to implement yourself inside a vuex store. All swrv instances use the same global cache, so if you are using swrv alongside vuex, you can use global watchers on resolved swrv returned refs. It is encouraged to wrap use\+SWRV in a custom composable function so that you can do application level side effects if desired (e.\+g. dispatch a vuex action when data changes to log events or perform some logic).

Vue 3 example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<script>}
\DoxyCodeLine{import\ \{\ defineComponent,\ ref,\ computed,\ watch\ \}\ from\ 'vue'}
\DoxyCodeLine{import\ \{\ useStore\ \}\ from\ 'vuex'}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{import\ \{\ getAllTasks\ \}\ from\ './api'}
\DoxyCodeLine{}
\DoxyCodeLine{export\ default\ defineComponent(\{}
\DoxyCodeLine{\ \ setup()\ \{}
\DoxyCodeLine{\ \ \ \ const\ store\ =\ useStore()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ const\ tasks\ =\ computed(\{}
\DoxyCodeLine{\ \ \ \ \ \ get:\ ()\ =>\ store.getters.allTasks,}
\DoxyCodeLine{\ \ \ \ \ \ set:\ (tasks)\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ store.dispatch('setTaskList',\ tasks)}
\DoxyCodeLine{\ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ const\ addTasks\ =\ (newTasks)\ =>\ store.dispatch('addTasks',\ \{\ tasks:\ newTasks\ \})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ const\ \{\ data\ \}\ =\ useSWRV('tasks',\ getAllTasks)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Using\ a\ watcher,\ you\ can\ update\ the\ store\ with\ any\ changes\ coming\ from\ swrv}
\DoxyCodeLine{\ \ \ \ watch(data,\ newTasks\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ store.dispatch('addTasks',\ \{\ source:\ 'Todoist',\ tasks:\ newTasks\ \})}
\DoxyCodeLine{\ \ \ \ \})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ tasks}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\})}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31797}{}\doxysubsubsection{\texorpdfstring{Cache}{Cache}}\label{README.md_autotoc_md31797}
By default, a custom cache implementation is used to store fetcher response data cache, in-\/flight promise cache, and ref cache. Response data cache can be customized via the {\ttfamily config.\+cache} property. Built in cache adapters\+:\hypertarget{README.md_autotoc_md31798}{}\doxysubsubsubsection{\texorpdfstring{local\+Storage}{local\+Storage}}\label{README.md_autotoc_md31798}
A common usage case to have a better {\itshape offline} experience is to read from {\ttfamily local\+Storage}. Checkout the \href{https://github.com/Kong/swrv/tree/master/examples/pwa}{\texttt{ PWA example}} for more inspiration.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ useSWRV\ from\ 'swrv'}
\DoxyCodeLine{import\ LocalStorageCache\ from\ 'swrv/dist/cache/adapters/localStorage'}
\DoxyCodeLine{}
\DoxyCodeLine{function\ useTodos\ ()\ \{}
\DoxyCodeLine{\ \ const\ \{\ data,\ error\ \}\ =\ useSWRV('/todos',\ undefined,\ \{}
\DoxyCodeLine{\ \ \ \ cache:\ new\ LocalStorageCache('swrv'),}
\DoxyCodeLine{\ \ \ \ shouldRetryOnError:\ false}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ return\ \{}
\DoxyCodeLine{\ \ \ \ data,}
\DoxyCodeLine{\ \ \ \ error}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31799}{}\doxysubsubsubsection{\texorpdfstring{Serve from cache only}{Serve from cache only}}\label{README.md_autotoc_md31799}
To only retrieve a swrv cache response without revalidating, you can set the fetcher function to {\ttfamily null} from the use\+SWRV call. This can be useful when there is some higher level swrv composable that is always sending data to other instances, so you can assume that composables with a {\ttfamily null} fetcher will have data available. This \href{https://github.com/Kong/swrv/issues/148}{\texttt{ isn\textquotesingle{}t very intuitive}}, so will be looking for ways to improve this api in the future.


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Component\ A}
\DoxyCodeLine{const\ \{\ data\ \}\ =\ useSWRV('/api/config',\ fetcher)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Component\ B,\ only\ retrieve\ from\ cache}
\DoxyCodeLine{const\ \{\ data\ \}\ =\ useSWRV('/api/config',\ null)}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31800}{}\doxysubsubsection{\texorpdfstring{Error Handling}{Error Handling}}\label{README.md_autotoc_md31800}
Since {\ttfamily error} is returned as a Vue Ref, you can use watchers to handle any on\+Error callback functionality. Check out \href{https://github.com/Kong/swrv/blob/a063c4aa142a5a13dbd39496cefab7aef54e610c/tests/use-swrv.spec.tsx\#L481}{\texttt{ the test}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{export\ default\ \{}
\DoxyCodeLine{\ \ setup()\ \{}
\DoxyCodeLine{\ \ \ \ const\ \{\ data,\ error\ \}\ =\ useSWRV(key,\ fetch)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ function\ handleError(error)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ console.error(error\ \&\&\ error.message)}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ watch(error,\ handleError)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ return\ \{}
\DoxyCodeLine{\ \ \ \ \ \ data,}
\DoxyCodeLine{\ \ \ \ \ \ error,}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md31801}{}\doxysubsubsection{\texorpdfstring{FAQ}{FAQ}}\label{README.md_autotoc_md31801}
\hypertarget{README.md_autotoc_md31802}{}\doxysubsubsubsection{\texorpdfstring{How is swrv different from the \href{https://github.com/zeit/swr}{\texttt{ swr}} react library}{How is swrv different from the \href{https://github.com/zeit/swr}{\texttt{ swr}} react library}}\label{README.md_autotoc_md31802}
\hypertarget{README.md_autotoc_md31803}{}\doxysubsubsubsubsection{\texorpdfstring{Vue and Reactivity}{Vue and Reactivity}}\label{README.md_autotoc_md31803}
The {\ttfamily swrv} library is meant to be used with the Vue Composition API (and eventually Vue 3) so it utilizes Vue\textquotesingle{}s reactivity system to track dependencies and returns vue {\ttfamily Ref}\textquotesingle{}s as it\textquotesingle{}s return values. This allows you to watch {\ttfamily data} or build your own computed props. For example, the key function is implemented as Vue {\ttfamily watch}er, so any changes to the dependencies in this function will trigger a revalidation in {\ttfamily swrv}.\hypertarget{README.md_autotoc_md31804}{}\doxysubsubsubsubsection{\texorpdfstring{Features}{Features}}\label{README.md_autotoc_md31804}
Features were built as needed for {\ttfamily swrv}, and while the initial development of {\ttfamily swrv} was mostly a port of swr, the feature sets are not 1-\/1, and are subject to diverge as they already have.\hypertarget{README.md_autotoc_md31805}{}\doxysubsubsubsection{\texorpdfstring{Why does swrv make so many requests}{Why does swrv make so many requests}}\label{README.md_autotoc_md31805}
The idea behind stale-\/while-\/revalidate is that you always get fresh data eventually. You can disable some of the eager fetching such as {\ttfamily config.\+revalidate\+On\+Focus}, but it is preferred to serve a fast response from cache while also revalidating so users are always getting the most up to date data.\hypertarget{README.md_autotoc_md31806}{}\doxysubsubsubsection{\texorpdfstring{How can I refetch swrv data to update it}{How can I refetch swrv data to update it}}\label{README.md_autotoc_md31806}
Swrv fetcher functions can be triggered on-\/demand by using the {\ttfamily mutate} \href{https://github.com/Kong/swrv/\#return-values}{\texttt{ return value}}. This is useful when there is some event that needs to trigger a revalidation such a PATCH request that updates the initial GET request response data.\hypertarget{README.md_autotoc_md31807}{}\doxysubsubsection{\texorpdfstring{Contributors ✨}{Contributors ✨}}\label{README.md_autotoc_md31807}
Thanks goes to these wonderful people (\href{https://allcontributors.org/docs/en/emoji-key}{\texttt{ emoji key}})\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \href{https://guuu.io/}{\texttt{ ~\newline
\textsubscript{{\bfseries{Darren Jennings}}}}}~\newline
\href{https://github.com/Kong/swrv/commits?author=darrenjennings}{\texttt{ 💻}} \href{https://github.com/Kong/swrv/commits?author=darrenjennings}{\texttt{ 📖}} &\PBS\centering \href{https://atinux.com}{\texttt{ ~\newline
\textsubscript{{\bfseries{Sébastien Chopin}}}}}~\newline
\href{https://github.com/Kong/swrv/commits?author=Atinux}{\texttt{ 💻}} \href{\#ideas-Atinux}{\texttt{ 🤔}} &\PBS\centering \href{https://github.com/chuca}{\texttt{ ~\newline
\textsubscript{{\bfseries{Fernando Machuca}}}}}~\newline
\href{\#design-chuca}{\texttt{ 🎨}} &\PBS\centering \href{https://zeit.co}{\texttt{ ~\newline
\textsubscript{{\bfseries{ZEIT}}}}}~\newline
\href{\#ideas-zeit}{\texttt{ 🤔}} &\PBS\centering \href{https://www.adamdehaven.com}{\texttt{ ~\newline
\textsubscript{{\bfseries{Adam De\+Haven}}}}}~\newline
\href{https://github.com/Kong/swrv/commits?author=adamdehaven}{\texttt{ 💻}} \href{https://github.com/Kong/swrv/commits?author=adamdehaven}{\texttt{ 📖}} \href{\#maintenance-adamdehaven}{\texttt{ 🚧}}  \\\cline{1-5}
\end{longtabu}


This project follows the \href{https://github.com/all-contributors/all-contributors}{\texttt{ all-\/contributors}} specification. Contributions of any kind welcome! 