\doxysection{node\+\_\+modules/yaml-\/language-\/server Directory Reference}
\hypertarget{dir_8a100e877d7f58a6f949972da2de05bd}{}\label{dir_8a100e877d7f58a6f949972da2de05bd}\index{node\_modules/yaml-\/language-\/server Directory Reference@{node\_modules/yaml-\/language-\/server Directory Reference}}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_eae7655781f06f65e3012281b40f2d44}{node\+\_\+modules}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
!\mbox{[}CI\mbox{]}(\href{https://github.com/redhat-developer/yaml-language-server/workflows/CI/badge.svg}{\texttt{ https\+://github.\+com/redhat-\/developer/yaml-\/language-\/server/workflows/\+CI/badge.\+svg}}) \mbox{[}!\mbox{[}version\mbox{]}(\href{https://img.shields.io/npm/v/yaml-language-server.svg}{\texttt{ https\+://img.\+shields.\+io/npm/v/yaml-\/language-\/server.\+svg}})\mbox{]}(\href{https://www.npmjs.com/package/yaml-language-server}{\texttt{ https\+://www.\+npmjs.\+com/package/yaml-\/language-\/server}}) \mbox{[}!\mbox{[}Coverage Status\mbox{]}(\href{https://coveralls.io/repos/github/redhat-developer/yaml-language-server/badge.svg?branch=main}{\texttt{ https\+://coveralls.\+io/repos/github/redhat-\/developer/yaml-\/language-\/server/badge.\+svg?branch=main}})\mbox{]}(\href{https://coveralls.io/github/redhat-developer/yaml-language-server?branch=main}{\texttt{ https\+://coveralls.\+io/github/redhat-\/developer/yaml-\/language-\/server?branch=main}})\hypertarget{README.md_autotoc_md36086}{}\doxysubsection{\texorpdfstring{YAML Language Server}{YAML Language Server}}\label{README.md_autotoc_md36086}
Supports JSON Schema 7 and below. Starting from {\ttfamily 1.\+0.\+0} the language server uses \href{https://github.com/eemeli/yaml}{\texttt{ eemeli/yaml}} as the new YAML parser, which strictly enforces the specified YAML spec version. Default YAML spec version is {\ttfamily 1.\+2}, it can be changed with {\ttfamily yaml.\+yaml\+Version} setting.\hypertarget{README.md_autotoc_md36087}{}\doxysubsubsection{\texorpdfstring{Features}{Features}}\label{README.md_autotoc_md36087}

\begin{DoxyEnumerate}
\item YAML validation\+:
\begin{DoxyItemize}
\item Detects whether the entire file is valid yaml
\end{DoxyItemize}
\item Validation\+:
\begin{DoxyItemize}
\item Detects errors such as\+:
\begin{DoxyItemize}
\item Node is not found
\item Node has an invalid key node type
\item Node has an invalid type
\item Node is not a valid child node
\end{DoxyItemize}
\item Detects warnings such as\+:
\begin{DoxyItemize}
\item Node is an additional property of parent
\end{DoxyItemize}
\end{DoxyItemize}
\item Auto completion\+:
\begin{DoxyItemize}
\item Auto completes on all commands
\item Scalar nodes autocomplete to schema\textquotesingle{}s defaults if they exist
\end{DoxyItemize}
\item Hover support\+:
\begin{DoxyItemize}
\item Hovering over a node shows description {\itshape if available}
\end{DoxyItemize}
\item Document outlining\+:
\begin{DoxyItemize}
\item Shows a complete document outline of all nodes in the document
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36088}{}\doxysubsubsection{\texorpdfstring{Language Server Settings}{Language Server Settings}}\label{README.md_autotoc_md36088}
The following settings are supported\+:


\begin{DoxyItemize}
\item {\ttfamily yaml.\+yaml\+Version}\+: Set default YAML spec version (1.\+2 or 1.\+1)
\item {\ttfamily yaml.\+format.\+enable}\+: Enable/disable default YAML formatter (requires restart)
\item {\ttfamily yaml.\+format.\+single\+Quote}\+: Use single quotes instead of double quotes
\item {\ttfamily yaml.\+format.\+bracket\+Spacing}\+: Print spaces between brackets in objects
\item {\ttfamily yaml.\+format.\+prose\+Wrap}\+: Always\+: wrap prose if it exceeds the print width, Never\+: never wrap the prose, Preserve\+: wrap prose as-\/is
\item {\ttfamily yaml.\+format.\+print\+Width}\+: Specify the line length that the printer will wrap on
\item {\ttfamily yaml.\+validate}\+: Enable/disable validation feature
\item {\ttfamily yaml.\+hover}\+: Enable/disable hover
\item {\ttfamily yaml.\+completion}\+: Enable/disable autocompletion
\item {\ttfamily yaml.\+schemas}\+: Helps you associate schemas with files in a glob pattern
\item {\ttfamily yaml.\+schema\+Store.\+enable}\+: When set to true the YAML language server will pull in all available schemas from \href{https://www.schemastore.org/json/}{\texttt{ JSON Schema Store}}
\item {\ttfamily yaml.\+schema\+Store.\+url}\+: URL of a schema store catalog to use when downloading schemas.
\item {\ttfamily yaml.\+custom\+Tags}\+: Array of custom tags that the parser will validate against. It has two ways to be used. Either an item in the array is a custom tag such as "{}!\+Ref"{} and it will automatically map !\+Ref to scalar or you can specify the type of the object !\+Ref should be e.\+g. "{}!\+Ref sequence"{}. The type of object can be either scalar (for strings and booleans), sequence (for arrays), map (for objects).
\item {\ttfamily yaml.\+max\+Items\+Computed}\+: The maximum number of outline symbols and folding regions computed (limited for performance reasons).
\item {\ttfamily \mbox{[}yaml\mbox{]}.editor.\+tab\+Size}\+: the number of spaces to use when autocompleting. Takes priority over editor.\+tab\+Size.
\item {\ttfamily editor.\+tab\+Size}\+: the number of spaces to use when autocompleting. Default is 2.
\item {\ttfamily http.\+proxy}\+: The URL of the proxy server that will be used when attempting to download a schema. If it is not set or it is undefined no proxy server will be used.
\item {\ttfamily http.\+proxy\+Strict\+SSL}\+: If true the proxy server certificate should be verified against the list of supplied CAs. Default is false.
\item {\ttfamily \mbox{[}yaml\mbox{]}.editor.\+format\+On\+Type}\+: Enable/disable on type indent and auto formatting array
\item {\ttfamily yaml.\+disable\+Default\+Properties}\+: Disable adding not required properties with default values into completion text
\item {\ttfamily yaml.\+suggest.\+parent\+Skeleton\+Selected\+First}\+: If true, the user must select some parent skeleton first before autocompletion starts to suggest the rest of the properties.\textbackslash{}n\+When yaml object is not empty, autocompletion ignores this setting and returns all properties and skeletons.
\item {\ttfamily yaml.\+style.\+flow\+Mapping} \+: Forbids flow style mappings if set to {\ttfamily forbid}
\item {\ttfamily yaml.\+style.\+flow\+Sequence} \+: Forbids flow style sequences if set to {\ttfamily forbid}
\item {\ttfamily yaml.\+key\+Ordering} \+: Enforces alphabetical ordering of keys in mappings when set to {\ttfamily true}. Default is {\ttfamily false}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36089}{}\doxysubsubsubsubsubsection{\texorpdfstring{Adding custom tags}{Adding custom tags}}\label{README.md_autotoc_md36089}
In order to use the custom tags in your YAML file you need to first specify the custom tags in the setting of your code editor. For example, we can have the following custom tags\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}yaml.customTags"{}:\ [}
\DoxyCodeLine{\ \ \ \ "{}!Scalar-\/example\ scalar"{},}
\DoxyCodeLine{\ \ \ \ "{}!Seq-\/example\ sequence"{},}
\DoxyCodeLine{\ \ \ \ "{}!Mapping-\/example\ mapping"{}}
\DoxyCodeLine{]}

\end{DoxyCode}


The !\+Scalar-\/example would map to a scalar custom tag, the !\+Seq-\/example would map to a sequence custom tag, the !\+Mapping-\/example would map to a mapping custom tag.

We can then use the newly defined custom tags inside our YAML file\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{some\_key:\ !Scalar-\/example\ some\_value}
\DoxyCodeLine{some\_sequence:\ !Seq-\/example}
\DoxyCodeLine{\ \ -\/\ some\_seq\_key\_1:\ some\_seq\_value\_1}
\DoxyCodeLine{\ \ -\/\ some\_seq\_key\_2:\ some\_seq\_value\_2}
\DoxyCodeLine{some\_mapping:\ !Mapping-\/example}
\DoxyCodeLine{\ \ some\_mapping\_key\_1:\ some\_mapping\_value\_1}
\DoxyCodeLine{\ \ some\_mapping\_key\_2:\ some\_mapping\_value\_2}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36090}{}\doxysubsubsubsubsubsection{\texorpdfstring{Associating a schema to a glob pattern via yaml.\+schemas\+:}{Associating a schema to a glob pattern via yaml.\+schemas\+:}}\label{README.md_autotoc_md36090}
yaml.\+schemas applies a schema to a file. In other words, the schema (placed on the left) is applied to the glob pattern on the right. Your schema can be local or online. Your schema path must be relative to the project root and not an absolute path to the schema.

For example\+: If you have project structure

my\+Project

~~~\texorpdfstring{$>$}{>} my\+Yaml\+File.\+yaml

you can do


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}https://json.schemastore.org/composer"{}:\ "{}/myYamlFile.yaml"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


and that will associate the composer schema with my\+Yaml\+File.\+yaml.\hypertarget{README.md_autotoc_md36091}{}\doxysubsubsection{\texorpdfstring{More examples of schema association\+:}{More examples of schema association\+:}}\label{README.md_autotoc_md36091}
\hypertarget{README.md_autotoc_md36092}{}\doxysubsubsubsection{\texorpdfstring{Using yaml.\+schemas settings}{Using yaml.\+schemas settings}}\label{README.md_autotoc_md36092}
\hypertarget{README.md_autotoc_md36093}{}\doxysubsubsubsubsection{\texorpdfstring{Single root schema association\+:}{Single root schema association\+:}}\label{README.md_autotoc_md36093}
When associating a schema it should follow the format below


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}url"{}:\ "{}globPattern"{},}
\DoxyCodeLine{\ \ \ \ "{}Kubernetes"{}:\ "{}globPattern"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}https://json.schemastore.org/composer"{}:\ "{}/*"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}kubernetes"{}:\ "{}/myYamlFile.yaml"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}https://json.schemastore.org/composer"{}:\ "{}/*"{},}
\DoxyCodeLine{\ \ \ \ "{}kubernetes"{}:\ "{}/myYamlFile.yaml"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


On Windows with full path\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}C:\(\backslash\)\(\backslash\)Users\(\backslash\)\(\backslash\)user\(\backslash\)\(\backslash\)Documents\(\backslash\)\(\backslash\)custom\_schema.json"{}:\ "{}someFilePattern.yaml"{},}
\DoxyCodeLine{\}}

\end{DoxyCode}


On Mac/\+Linux with full path\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}/home/user/custom\_schema.json"{}:\ "{}someFilePattern.yaml"{},}
\DoxyCodeLine{\}}

\end{DoxyCode}


Since {\ttfamily 0.\+11.\+0} YAML Schemas can be used for validation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}/home/user/custom\_schema.yaml"{}:\ "{}someFilePattern.yaml"{}}

\end{DoxyCode}


A schema can be associated with multiple globs using a json array, e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}kubernetes"{}:\ ["{}filePattern1.yaml"{},\ "{}filePattern2.yaml"{}]}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}yaml.schemas"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}http://json.schemastore.org/composer"{}:\ ["{}/*"{}],}
\DoxyCodeLine{\ \ \ \ "{}file:///home/johnd/some-\/schema.json"{}:\ ["{}some.yaml"{}],}
\DoxyCodeLine{\ \ \ \ "{}../relative/path/schema.json"{}:\ ["{}/config*.yaml"{}],}
\DoxyCodeLine{\ \ \ \ "{}/Users/johnd/some-\/schema.json"{}:\ ["{}some.yaml"{}],}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}yaml.schemas"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}kubernetes"{}:\ ["{}/myYamlFile.yaml"{}]}
\DoxyCodeLine{\}}

\end{DoxyCode}


e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{"{}yaml.schemas"{}:\ \{}
\DoxyCodeLine{\ \ \ \ "{}http://json.schemastore.org/composer"{}:\ ["{}/*"{}],}
\DoxyCodeLine{\ \ \ \ "{}kubernetes"{}:\ ["{}/myYamlFile.yaml"{}]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36094}{}\doxysubsubsubsubsection{\texorpdfstring{Multi root schema association\+:}{Multi root schema association\+:}}\label{README.md_autotoc_md36094}
You can also use relative paths when working with multi root workspaces.

Suppose you have a multi root workspace that is laid out like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{My\_first\_project:}
\DoxyCodeLine{\ \ \ test.yaml}
\DoxyCodeLine{\ \ \ my\_schema.json}
\DoxyCodeLine{My\_second\_project:}
\DoxyCodeLine{\ \ \ test2.yaml}
\DoxyCodeLine{\ \ \ my\_schema2.json}

\end{DoxyCode}


You must then associate schemas relative to the root of the multi root workspace project.


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}My\_first\_project/my\_schema.json"{}:\ "{}test.yaml"{},}
\DoxyCodeLine{\ \ \ \ "{}My\_second\_project/my\_schema2.json"{}:\ "{}test2.yaml"{}}
\DoxyCodeLine{\}}

\end{DoxyCode}


{\ttfamily yaml.\+schemas} allows you to specify json schemas that you want to validate against the yaml that you write. Kubernetes is an optional field. It does not require a url as the language server will provide that. You just need the keyword kubernetes and a glob pattern.\hypertarget{README.md_autotoc_md36095}{}\doxysubsubsubsection{\texorpdfstring{Nested Schema References}{Nested Schema References}}\label{README.md_autotoc_md36095}
Suppose a file is meant to be a component of an existing schema (like a {\ttfamily job.\+yaml} file in a circleci orb), but there isn\textquotesingle{}t a standalone schema that you can reference. If there is a nested schema definition for this subcomponent, you can reference it using a url fragment, e.\+g.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{yaml.schemas:\ \{}
\DoxyCodeLine{\ \ \ \ "{}https://json.schemastore.org/circleciconfig\#/definitions/jobs/additionalProperties"{}:\ "{}/src/jobs/*.yaml"{},}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
{\bfseries{Note}} This will require reading your existing schema and understanding the schemastore structure a bit. (TODO\+: link to a documentation or blog post here?) \end{quote}
\hypertarget{README.md_autotoc_md36096}{}\doxysubsubsubsection{\texorpdfstring{Using inlined schema}{Using inlined schema}}\label{README.md_autotoc_md36096}
It is possible to specify a yaml schema using a modeline.


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ yaml-\/language-\/server:\ \$schema=<urlToTheSchema>}

\end{DoxyCode}


Also it is possible to use relative path in a modeline\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ yaml-\/language-\/server:\ \$schema=../relative/path/to/schema}

\end{DoxyCode}


or absolute path\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ yaml-\/language-\/server:\ \$schema=/absolute/path/to/schema}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36097}{}\doxysubsubsubsection{\texorpdfstring{Schema priority}{Schema priority}}\label{README.md_autotoc_md36097}
The following is the priority of schema association in highest to lowest priority\+:
\begin{DoxyEnumerate}
\item Modeline
\item Custom\+Schema\+Provider API
\item yaml.\+settings
\item Schema association notification
\item Schema Store
\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36098}{}\doxysubsubsection{\texorpdfstring{Containerized Language Server}{Containerized Language Server}}\label{README.md_autotoc_md36098}
An image is provided for users who would like to use the YAML language server without having to install dependencies locally.

The image is located at {\ttfamily quay.\+io/redhat-\/developer/yaml-\/language-\/server}

To run the image you can use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{docker\ run\ -\/it\ quay.io/redhat-\/developer/yaml-\/language-\/server:latest}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36099}{}\doxysubsubsection{\texorpdfstring{Language Server Protocol version}{Language Server Protocol version}}\label{README.md_autotoc_md36099}
{\ttfamily yaml-\/language-\/server} use {\ttfamily vscode-\/languageserver@7.\+0.\+0} which implements \href{https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-16.md}{\texttt{ LSP 3.\+16}}\hypertarget{README.md_autotoc_md36100}{}\doxysubsubsection{\texorpdfstring{Language Server Protocol extensions}{Language Server Protocol extensions}}\label{README.md_autotoc_md36100}
\hypertarget{README.md_autotoc_md36101}{}\doxysubsubsubsection{\texorpdfstring{Schema\+Selection\+Requests}{Schema\+Selection\+Requests}}\label{README.md_autotoc_md36101}
\hypertarget{README.md_autotoc_md36102}{}\doxysubsubsubsubsection{\texorpdfstring{Support\+Schema\+Selection Notification}{Support\+Schema\+Selection Notification}}\label{README.md_autotoc_md36102}
The support schema selection notification is sent from a client to the server to inform server that client supports JSON Schema selection.

{\itshape Notification\+:}


\begin{DoxyItemize}
\item method\+: `\textquotesingle{}yaml/support\+Schema\+Selection'{\ttfamily }
\item {\ttfamily params\+:}void\`{}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36103}{}\doxysubsubsubsubsection{\texorpdfstring{Schema\+Store\+Initialized Notification}{Schema\+Store\+Initialized Notification}}\label{README.md_autotoc_md36103}
The schema store initialized notification is sent from the server to a client to inform client that server has finished initializing/loading schemas from schema store, and client now can ask for schemas.

{\itshape Notification\+:}


\begin{DoxyItemize}
\item method\+: `\textquotesingle{}yaml/schema/store/initialized'{\ttfamily }
\item {\ttfamily params\+:}void\`{}
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36104}{}\doxysubsubsubsubsection{\texorpdfstring{Get\+All\+Schemas Request}{Get\+All\+Schemas Request}}\label{README.md_autotoc_md36104}
The get all schemas request sent from a client to server to get all known schemas.

{\itshape Request\+:}


\begin{DoxyItemize}
\item method\+: `\textquotesingle{}yaml/get/all/json\+Schemas'\`{};
\item params\+: the document uri, server will mark used schema for document
\end{DoxyItemize}

{\itshape Response\+:}


\begin{DoxyItemize}
\item result\+: {\ttfamily JSONSchema\+Description\+Ext\mbox{[}\mbox{]}}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{interface\ JSONSchemaDescriptionExt\ \{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ URI}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ uri:\ string;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ name,\ from\ schema\ store}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ name?:\ string;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ description,\ from\ schema\ store}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ description?:\ string;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Is\ schema\ used\ for\ current\ document}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ usedForCurrentFile:\ boolean;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Is\ schema\ from\ schema\ store}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ fromStore:\ boolean;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36105}{}\doxysubsubsubsubsection{\texorpdfstring{Get\+Schemas Request}{Get\+Schemas Request}}\label{README.md_autotoc_md36105}
The request sent from a client to server to get schemas used for current document. Client can use this method to indicate in UI which schemas used for current YAML document.

{\itshape Request\+:}


\begin{DoxyItemize}
\item method\+: `\textquotesingle{}yaml/get/json\+Schema'\`{};
\item params\+: the document uri to get used schemas
\end{DoxyItemize}

{\itshape Response\+:}


\begin{DoxyItemize}
\item result\+: {\ttfamily JSONSchema\+Description\mbox{[}\mbox{]}}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{interface\ JSONSchemaDescriptionExt\ \{}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ URI}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ uri:\ string;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ name,\ from\ schema\ store}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ name?:\ string;}
\DoxyCodeLine{\ \ /**}
\DoxyCodeLine{\ \ \ *\ Schema\ description,\ from\ schema\ store}
\DoxyCodeLine{\ \ \ */}
\DoxyCodeLine{\ \ description?:\ string;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{README.md_autotoc_md36106}{}\doxysubsubsection{\texorpdfstring{Clients}{Clients}}\label{README.md_autotoc_md36106}
This repository only contains the server implementation. Here are some known clients consuming this server\+:


\begin{DoxyItemize}
\item \href{https://www.eclipse.org/che/}{\texttt{ Eclipse Che}}
\item \href{https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml}{\texttt{ vscode-\/yaml}} for VSCode
\item \href{https://github.com/neoclide/coc-yaml}{\texttt{ coc-\/yaml}} for \href{https://github.com/neoclide/coc.nvim}{\texttt{ coc.\+nvim}}
\item \href{https://marketplace.eclipse.org/content/eclipse-wild-web-developer-web-development-eclipse-ide}{\texttt{ Eclipse Wild Web Developer}} for Eclipse IDE
\item \href{https://github.com/emacs-lsp/lsp-mode}{\texttt{ lsp-\/mode}} for Emacs
\item \href{https://github.com/prabirshrestha/vim-lsp}{\texttt{ vim-\/lsp}} for Vim
\item \href{https://packagecontrol.io/packages/LSP-yaml}{\texttt{ LSP-\/yaml}} for Sublime Text
\item \href{https://monaco-yaml.js.org}{\texttt{ monaco-\/yaml}} for Monaco editor
\item \href{https://github.com/jayli/vim-easycomplete}{\texttt{ Vim-\/\+Easy\+Complete}} for Vim/\+Neo\+Vim
\item \href{https://github.com/robb-j/nova-yaml/}{\texttt{ nova-\/yaml}} for Nova
\item \href{https://github.com/volarjs/services/tree/master/packages/yaml}{\texttt{ volar-\/service-\/yaml}} for Volar
\end{DoxyItemize}\hypertarget{README.md_autotoc_md36107}{}\doxysubsubsection{\texorpdfstring{Developer Support}{Developer Support}}\label{README.md_autotoc_md36107}
\hypertarget{README.md_autotoc_md36108}{}\doxysubsubsubsection{\texorpdfstring{Getting started}{Getting started}}\label{README.md_autotoc_md36108}

\begin{DoxyEnumerate}
\item Install prerequisites\+:
\begin{DoxyItemize}
\item latest \href{https://code.visualstudio.com/}{\texttt{ Visual Studio Code}}
\item \href{https://nodejs.org/}{\texttt{ Node.\+js}} v12.\+0.\+0 or higher
\end{DoxyItemize}
\item Fork and clone this repository
\item Install the dependencies 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd\ yaml-\/language-\/server}
\DoxyCodeLine{\$\ yarn\ install}

\end{DoxyCode}

\item Build the language server 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ yarn\ run\ build}

\end{DoxyCode}

\item The new built server is now located in ./out/server/src/server.js. 
\begin{DoxyCode}{0}
\DoxyCodeLine{node\ (Yaml\ Language\ Server\ Location)/out/server/src/server.js\ [-\/-\/stdio]}

\end{DoxyCode}

\end{DoxyEnumerate}\hypertarget{README.md_autotoc_md36109}{}\doxysubsubsubsection{\texorpdfstring{Connecting to the language server via stdio}{Connecting to the language server via stdio}}\label{README.md_autotoc_md36109}
We have included the option to connect to the language server via \href{https://github.com/redhat-developer/yaml-language-server/blob/681985b5a059c2cb55c8171235b07e1651b6c546/src/server.ts\#L46-L51}{\texttt{ stdio}} to help with integrating the language server into different clients.\hypertarget{README.md_autotoc_md36110}{}\doxysubsubsubsection{\texorpdfstring{ESM and UMD Modules}{ESM and UMD Modules}}\label{README.md_autotoc_md36110}
Building the YAML Language Server produces \href{http://www.commonjs.org/}{\texttt{ Common\+JS}} modules in the {\ttfamily /out/server/src} directory. In addition, a build also produces \href{https://github.com/umdjs/umd}{\texttt{ UMD}} (Universal Module Definition) modules and \href{https://tc39.es/ecma262/\#sec-modules}{\texttt{ ES Modules}} (ESM) in the {\ttfamily /lib} directory. That gives you choices in using the YAML Language Server with different module loaders on the server side and in the browser with bundlers like webpack.\hypertarget{README.md_autotoc_md36111}{}\doxysubsubsubsection{\texorpdfstring{CI}{CI}}\label{README.md_autotoc_md36111}
We use a Git\+Hub Action to publish each change in the {\ttfamily main} branch to \href{https://www.npmjs.com/package/yaml-language-server}{\texttt{ npm registry}} with the {\ttfamily next} tag. You may use the {\ttfamily next} version to adopt the latest changes into your project. 