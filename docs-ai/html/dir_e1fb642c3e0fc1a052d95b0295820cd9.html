<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/xxhash-wasm Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_e1fb642c3e0fc1a052d95b0295820cd9.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">xxhash-wasm Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://github.com/jungomi/xxhash-wasm/actions/workflows/nodejs.yml"><img src="https://github.com/jungomi/xxhash-wasm/actions/workflows/nodejs.yml/badge.svg" alt="Node.js" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/xxhash-wasm"><img src="https://img.shields.io/npm/v/xxhash-wasm.svg?style=flat-square" alt="npm" style="pointer-events: none;" class="inline"/></a></p>
<p>A WebAssembly implementation of <a href="https://github.com/Cyan4973/xxHash">xxHash</a>, a fast non-cryptographic hash algorithm. It can be called seamlessly from JavaScript. You can use it like any other JavaScript library but still get the benefits of WebAssembly, no special setup needed.</p>
<h1><a class="anchor" id="autotoc_md35835"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#installation">Installation</a><ul>
<li>From npm</li>
<li>From Unpkg<ul>
<li>ES Modules</li>
<li>UMD build</li>
</ul>
</li>
<li>Cloudflare Workers</li>
</ul>
</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/@sinclair/typebox/readme.md#usage">Usage</a><ul>
<li>Streaming Example</li>
<li>Node</li>
</ul>
</li>
<li>Performance<ul>
<li>Engine Requirements</li>
</ul>
</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#api">API</a><ul>
<li>h32</li>
<li>h64</li>
<li>Streaming</li>
</ul>
</li>
<li>Comparison to xxhashjs<ul>
<li>Benchmarks</li>
<li>Bundle size</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md35836"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md35837"></a>
From npm</h2>
<div class="fragment"><div class="line">npm install --save xxhash-wasm</div>
</div><!-- fragment --><p>Or with Yarn:</p>
<div class="fragment"><div class="line">yarn add xxhash-wasm</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35838"></a>
From <a href="https://unpkg.com/">Unpkg</a></h2>
<h3><a class="anchor" id="autotoc_md35839"></a>
ES Modules</h3>
<div class="fragment"><div class="line">&lt;script type=&quot;module&quot;&gt;</div>
<div class="line">  import xxhash from &quot;https://unpkg.com/xxhash-wasm/esm/xxhash-wasm.js&quot;;</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35840"></a>
UMD build</h3>
<div class="fragment"><div class="line">&lt;script src=&quot;https://unpkg.com/xxhash-wasm/umd/xxhash-wasm.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>The global <code>xxhash</code> will be available.</p>
<h2><a class="anchor" id="autotoc_md35841"></a>
Cloudflare Workers</h2>
<p>If you are using <a href="https://developers.cloudflare.com/workers/">Cloudflare Workers</a> (workerd) you can use the installed npm package as is. The <code>xxhash-wasm</code> package is compatible with Cloudflare Workers.</p>
<div class="fragment"><div class="line">import xxhash from &quot;xxhash-wasm&quot;;</div>
</div><!-- fragment --><p>Importing it will pick the correct file base on the <a href="https://developers.cloudflare.com/workers/wrangler/bundling/#conditional-exports">conditional import</a> from the package.json.</p>
<h1><a class="anchor" id="autotoc_md35842"></a>
Usage</h1>
<p>The WebAssembly is contained in the JavaScript bundle, so you don't need to manually fetch it and create a new WebAssembly instance.</p>
<div class="fragment"><div class="line">import xxhash from &quot;xxhash-wasm&quot;;</div>
<div class="line"> </div>
<div class="line">// Creates the WebAssembly instance.</div>
<div class="line">xxhash().then(hasher =&gt; {</div>
<div class="line">  const input = &quot;The string that is being hashed&quot;;</div>
<div class="line"> </div>
<div class="line">  // 32-bit version</div>
<div class="line">  hasher.h32(input); // 3998627172 (decimal representation)</div>
<div class="line">  // For convenience, get hash as string of its zero-padded hex representation</div>
<div class="line">  hasher.h32ToString(input); // &quot;ee563564&quot;</div>
<div class="line"> </div>
<div class="line">  // 64-bit version</div>
<div class="line">  hasher.h64(input); // 5776724552493396044n (BigInt)</div>
<div class="line">  // For convenience, get hash as string of its zero-padded hex representation</div>
<div class="line">  hasher.h64ToString(input); // &quot;502b0c5fc4a5704c&quot;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Or with <code>async</code>/<code>await</code> and destructuring:</p>
<div class="fragment"><div class="line">// Creates the WebAssembly instance.</div>
<div class="line">const { h32, h64 } = await xxhash();</div>
<div class="line"> </div>
<div class="line">const input = &quot;The string that is being hashed&quot;;</div>
<div class="line">// 32-bit version</div>
<div class="line">h32(input); // 3998627172 (decimal representation)</div>
<div class="line">// 64-bit version</div>
<div class="line">h64(input); // 5776724552493396044n (BigInt)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35843"></a>
Streaming Example</h2>
<p><code>xxhash-wasm</code> supports a <code>crypto</code>-like streaming api, useful for avoiding memory consumption when hashing large amounts of data:</p>
<div class="fragment"><div class="line">const { create32, create64 } = await xxhash();</div>
<div class="line"> </div>
<div class="line">// 32-bit version</div>
<div class="line">create32()</div>
<div class="line">  .update(&quot;some data&quot;)</div>
<div class="line">  // update accepts either a string or Uint8Array</div>
<div class="line">  .update(Uint8Array.from([1, 2, 3]))</div>
<div class="line">  .digest(); // 955607085</div>
<div class="line"> </div>
<div class="line">// 64-bit version</div>
<div class="line">create64()</div>
<div class="line">  .update(&quot;some data&quot;)</div>
<div class="line">  // update accepts either a string or Uint8Array</div>
<div class="line">  .update(Uint8Array.from([1, 2, 3]))</div>
<div class="line">  .digest(); // 883044157688673477n</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35844"></a>
Node</h2>
<p>It doesn't matter whether you are using CommonJS or ES Modules in Node (e.g. with <code>"type": "module"</code> in <code>package.json</code> or using the explicit file extensions <code>.cjs</code> or <code>.mjs</code> respectively), importing <code>xxhash-wasm</code> will always load the corresponding module, as both bundles are provided and specified in the <code>exports</code> field of its <code>package.json</code>, therefore the appropriate one will automatically be selected.</p>
<p><b>Using ES Modules</b></p>
<div class="fragment"><div class="line">import xxhash from &quot;xxhash-wasm&quot;;</div>
</div><!-- fragment --><p><b>Using CommonJS</b></p>
<div class="fragment"><div class="line">const xxhash = require(&quot;xxhash-wasm&quot;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35845"></a>
Performance</h1>
<p>For performance sensitive applications, <code>xxhash-wasm</code> provides the <code>h**</code> and <code>h**Raw</code> APIs, which return raw numeric hash results rather than zero-padded hex strings. The overhead of the string conversion in the <code>h**ToString</code> APIs can be as much as 20% of overall runtime when hashing small byte-size inputs, and the string result is often inconsequential (for example when simply checking if the the resulting hashes are the same). When necessary, getting a zero-padded hex string from the provided <code>number</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> results is easily achieved via <code>result.toString(16).padStart(16, "0")</code> and the <code>h**ToString</code> APIs are purely for convenience.</p>
<p>The <code>h**</code>, <code>h**ToString</code>, and streaming APIs make use of <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encodeInto"><code>TextEncoder.encodeInto</code></a> to directly encode strings as a stream of UTF-8 bytes into the WebAssembly memory buffer, meaning that for string-hashing purposes, these APIs will be significantly faster than converting the string to bytes externally and using the <code>Raw</code> API. That said, for large strings it may be beneficial to consider the streaming API or another approach to encoding, as <code>encodeInto</code> is forced to allocate 3-times the string length to account for the chance the input string contains high-byte-count code units.</p>
<p><em>If possible, defer the encoding of the string to the hashing, unless you need to use the encoded string (bytes) for other purposes as well, or you are creating the bytes differently (e.g. different encoding), in which case it's much more efficient to use the <code>h**Raw</code> APIs instead of having to unnecessarily convert them to a string first.</em></p>
<h2><a class="anchor" id="autotoc_md35846"></a>
Engine Requirements</h2>
<p>In an effort to make this library as performant as possible, it uses several recent additions to browsers, Node and the WebAssembly specification. Notably, these include:</p>
<ol type="1">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> support in WebAssembly</li>
<li>Bulk memory operations in WebAssembly</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encodeInto"><code>TextEncoder.encodeInto</code></a></li>
</ol>
<p>Taking all of these requirements into account, <code>xxhash-wasm</code> should be compatible with:</p>
<ul>
<li>Chrome &gt;= 85</li>
<li>Edge &gt;= 79</li>
<li>Firefox &gt;= 79</li>
<li>Safari &gt;= 15.0</li>
<li>Node &gt;= 15.0</li>
</ul>
<p>If support for an older engine is required, <code>xxhash-wasm@0.4.2</code> is available with much broader engine support, but 3-4x slower hashing performance.</p>
<h1><a class="anchor" id="autotoc_md35847"></a>
API</h1>
<div class="fragment"><div class="line">const {</div>
<div class="line">  h32,</div>
<div class="line">  h32ToString,</div>
<div class="line">  h32Raw,</div>
<div class="line">  create32,</div>
<div class="line">  h64,</div>
<div class="line">  h64ToString,</div>
<div class="line">  h64Raw,</div>
<div class="line">  create64,</div>
<div class="line">} = await xxhash();</div>
</div><!-- fragment --><p>Create a WebAssembly instance.</p>
<h2><a class="anchor" id="autotoc_md35848"></a>
h32</h2>
<div class="fragment"><div class="line">h32(input: string, [seed: u32]): number</div>
</div><!-- fragment --><p>Generate a 32-bit hash of the UTF-8 encoded bytes of <code>input</code>. The optional <code>seed</code> is a <code><a class="el" href="circom_8hpp.html#afaa62991928fb9fb18ff0db62a040aba">u32</a></code> and any number greater than the maximum (<code>0xffffffff</code>) is wrapped, which means that <code>0xffffffff + 1 = 0</code>.</p>
<p>Returns a <code><a class="el" href="circom_8hpp.html#afaa62991928fb9fb18ff0db62a040aba">u32</a></code> <code>number</code> containing the hash value.</p>
<div class="fragment"><div class="line">h32ToString(input: string, [seed: u32]): string</div>
</div><!-- fragment --><p>Same as <code>h32</code>, but returning a zero-padded hex string.</p>
<div class="fragment"><div class="line">h32Raw(input: Uint8Array, [seed: u32]): number</div>
</div><!-- fragment --><p>Same as <code>h32</code> but with a <code>Uint8Array</code> as input instead of a <code>string</code>.</p>
<h2><a class="anchor" id="autotoc_md35849"></a>
h64</h2>
<div class="fragment"><div class="line">h64(input: string, [seed: bigint]): bigint</div>
</div><!-- fragment --><p>Generate a 64-bit hash of the UTF-8 encoded bytes of <code>input</code>. The optional <code>seed</code> is a <code><a class="el" href="circom_8hpp.html#ad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></code> provided as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>.</p>
<p>Returns a <code><a class="el" href="circom_8hpp.html#ad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></code> <code>bigint</code> containing the hash value.</p>
<div class="fragment"><div class="line">h64ToString(input: string, [seed: bigint]): string</div>
</div><!-- fragment --><p>Same as <code>h64</code>, but returning a zero-padded hex string.</p>
<div class="fragment"><div class="line">h64Raw(input: Uint8Array, [seed: bigint]): bigint</div>
</div><!-- fragment --><p>Same as <code>h64</code> but with a <code>Uint8Array</code> as input instead of a <code>string</code>.</p>
<h2><a class="anchor" id="autotoc_md35850"></a>
Streaming</h2>
<div class="fragment"><div class="line">type XXHash&lt;T&gt; {</div>
<div class="line">  update(input: string | Uint8Array): XXHash&lt;T&gt;;</div>
<div class="line">  digest(): T</div>
<div class="line">}</div>
</div><!-- fragment --><p>The streaming API mirrors Node's built-in <code>crypto.createHash</code>, providing <code>update</code> and <code>digest</code> methods to add data to the hash and compute the final hash value, respectively.</p>
<div class="fragment"><div class="line">create32([seed: number]): XXHash&lt;number&gt;</div>
</div><!-- fragment --><p>Create a 32-bit hash for streaming applications.</p>
<div class="fragment"><div class="line">create64([seed: bigint]): XXHash&lt;bigint&gt;</div>
</div><!-- fragment --><p>Create a 64-bit hash for streaming applications.</p>
<h1><a class="anchor" id="autotoc_md35851"></a>
Comparison to <a href="https://github.com/pierrec/js-xxhash">xxhashjs</a></h1>
<p><a href="https://github.com/pierrec/js-xxhash"><code>xxhashjs</code></a> is implemented in pure JavaScript and because JavaScript is lacking support for 64-bit integers, it uses a workaround with <a href="https://github.com/pierrec/js-cuint"><code>cuint</code></a>. Not only is that a big performance hit, but it also increases the bundle size by quite a bit when it's used in the browser.</p>
<p>This library (<code>xxhash-wasm</code>) has the big advantage that WebAssembly supports <code><a class="el" href="circom_8hpp.html#ad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></code> and also some instructions (e.g. <code>rotl</code>), which would otherwise have to be emulated. However, The downside is that you have to initialise a WebAssembly instance, which takes a little over 2ms in Node and about 1ms in the browser. But once the instance is created, it can be used without any further overhead. For the benchmarks below, the instantiation is done before the benchmark and therefore it's excluded from the results, since it wouldn't make sense to always create a new WebAssembly instance.</p>
<h2><a class="anchor" id="autotoc_md35852"></a>
Benchmarks</h2>
<p>Benchmarks are using <a href="https://benchmarkjs.com/">Benchmark.js</a> with random strings of different lengths. <em>Higher is better</em></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">String length   </th><th class="markdownTableHeadNone">xxhashjs 32-bit   </th><th class="markdownTableHeadNone">xxhashjs 64-bit   </th><th class="markdownTableHeadNone">xxhash-wasm 32-bit   </th><th class="markdownTableHeadNone">xxhash-wasm 64-bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1 byte   </td><td class="markdownTableBodyNone">513,517 ops/sec   </td><td class="markdownTableBodyNone">11,896 ops/sec   </td><td class="markdownTableBodyNone"><em><b>5,752,446 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,438,501 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10 bytes   </td><td class="markdownTableBodyNone">552,133 ops/sec   </td><td class="markdownTableBodyNone">12,953 ops/sec   </td><td class="markdownTableBodyNone"><em><b>6,240,640 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,855,340 ops/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100 bytes   </td><td class="markdownTableBodyNone">425,277 ops/sec   </td><td class="markdownTableBodyNone">10,838 ops/sec   </td><td class="markdownTableBodyNone"><em><b>5,470,011 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,314,904 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">1,000 bytes   </td><td class="markdownTableBodyNone">102,165 ops/sec   </td><td class="markdownTableBodyNone">6,697 ops/sec   </td><td class="markdownTableBodyNone">3,283,526 ops/sec   </td><td class="markdownTableBodyNone"><em><b>3,332,556 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">10,000 bytes   </td><td class="markdownTableBodyNone">13,010 ops/sec   </td><td class="markdownTableBodyNone">1,452 ops/sec   </td><td class="markdownTableBodyNone">589,068 ops/sec   </td><td class="markdownTableBodyNone"><em><b>940,350 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">100,000 bytes   </td><td class="markdownTableBodyNone">477 ops/sec   </td><td class="markdownTableBodyNone">146 ops/sec   </td><td class="markdownTableBodyNone">61,824 ops/sec   </td><td class="markdownTableBodyNone"><em><b>98,959 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1,000,000 bytes   </td><td class="markdownTableBodyNone">36.40 ops/sec   </td><td class="markdownTableBodyNone">12.93 ops/sec   </td><td class="markdownTableBodyNone">5,122 ops/sec   </td><td class="markdownTableBodyNone"><em><b>8,632 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10,000,000 bytes   </td><td class="markdownTableBodyNone">3.12 ops/sec   </td><td class="markdownTableBodyNone">1.19 ops/sec   </td><td class="markdownTableBodyNone">326 ops/sec   </td><td class="markdownTableBodyNone"><em><b>444 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100,000,000 bytes   </td><td class="markdownTableBodyNone">0.31 ops/sec   </td><td class="markdownTableBodyNone">0.13 ops/sec   </td><td class="markdownTableBodyNone">27.84 ops/sec   </td><td class="markdownTableBodyNone"><em><b>34.56 ops/sec</b></em>   </td></tr>
</table>
<p><code>xxhash-wasm</code> outperforms <code>xxhashjs</code> significantly, the 32-bit is up to 90 times faster (generally increases as the size of the input grows), and the 64-bit is up to 350 times faster (generally increases as the size of the input grows).</p>
<p>The 64-bit version is the faster algorithm but there is a small degree of overhead involved in using BigInts, and so it retains a performance advantage over all lengths over xxhashjs and the 32-bit algorithm above ~1000 bytes.</p>
<p><code>xxhash-wasm</code> also significantly outperforms Node's built-in hash algorithms, making it suitable for use in a wide variety of situations, where non-cryptographic hashes are acceptable. Benchmarks from an x64 MacBook Pro running Node 17.3:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">String length   </th><th class="markdownTableHeadNone">Node <code>crypto</code> md5   </th><th class="markdownTableHeadNone">Node <code>crypto</code> sha1   </th><th class="markdownTableHeadNone">xxhash-wasm 64-bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1 byte   </td><td class="markdownTableBodyNone">342,924 ops/sec   </td><td class="markdownTableBodyNone">352,825 ops/sec   </td><td class="markdownTableBodyNone"><em><b>4,438,501 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10 bytes   </td><td class="markdownTableBodyNone">356,596 ops/sec   </td><td class="markdownTableBodyNone">352,209 ops/sec   </td><td class="markdownTableBodyNone"><em><b>4,855,340 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100 bytes   </td><td class="markdownTableBodyNone">354,898 ops/sec   </td><td class="markdownTableBodyNone">355,024 ops/sec   </td><td class="markdownTableBodyNone"><em><b>4,314,904 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">1,000 bytes   </td><td class="markdownTableBodyNone">249,242 ops/sec   </td><td class="markdownTableBodyNone">271,383 ops/sec   </td><td class="markdownTableBodyNone"><em><b>3,332,556 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">10,000 bytes   </td><td class="markdownTableBodyNone">62,896 ops/sec   </td><td class="markdownTableBodyNone">80,986 ops/sec   </td><td class="markdownTableBodyNone"><em><b>940,350 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">100,000 bytes   </td><td class="markdownTableBodyNone">7,316 ops/sec   </td><td class="markdownTableBodyNone">10,198 ops/sec   </td><td class="markdownTableBodyNone"><em><b>98,959 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1,000,000 bytes   </td><td class="markdownTableBodyNone">698 ops/sec   </td><td class="markdownTableBodyNone">966 ops/sec   </td><td class="markdownTableBodyNone"><em><b>8,632 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10,000,000 bytes   </td><td class="markdownTableBodyNone">58.98 ops/sec   </td><td class="markdownTableBodyNone">79.78 ops/sec   </td><td class="markdownTableBodyNone"><em><b>444 ops/sec</b></em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100,000,000 bytes   </td><td class="markdownTableBodyNone">6.30 ops/sec   </td><td class="markdownTableBodyNone">8.20 ops/sec   </td><td class="markdownTableBodyNone"><em><b>34.56 ops/sec</b></em>   </td></tr>
</table>
<p>If suitable for your use case, the <code>Raw</code> API offers significant throughput improvements over the string-hashing API, particularly for smaller inputs, assuming that you have access to the <code>Uint8Array</code> already (see also the Performance section):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">String length   </th><th class="markdownTableHeadNone">xxhash-wasm 64-bit Raw   </th><th class="markdownTableHeadNone">xxhash-wasm 64-bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1 byte   </td><td class="markdownTableBodyNone"><em><b>9,342,811 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,438,501 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10 bytes   </td><td class="markdownTableBodyNone"><em><b>9,668,989 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,855,340 ops/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100 bytes   </td><td class="markdownTableBodyNone"><em><b>8,775,845 ops/sec</b></em>   </td><td class="markdownTableBodyNone">4,314,904 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">1,000 bytes   </td><td class="markdownTableBodyNone"><em><b>5,541,403 ops/sec</b></em>   </td><td class="markdownTableBodyNone">3,332,556 ops/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">10,000 bytes   </td><td class="markdownTableBodyNone"><em><b>1,079,866 ops/sec</b></em>   </td><td class="markdownTableBodyNone">940,350 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">100,000 bytes   </td><td class="markdownTableBodyNone"><em><b>113,350 ops/sec</b></em>   </td><td class="markdownTableBodyNone">98,959 ops/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">1,000,000 bytes   </td><td class="markdownTableBodyNone"><em><b>9,779 ops/sec</b></em>   </td><td class="markdownTableBodyNone">8,632 ops/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">10,000,000 bytes   </td><td class="markdownTableBodyNone"><em><b>563 ops/sec</b></em>   </td><td class="markdownTableBodyNone">444 ops/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">100,000,000 bytes   </td><td class="markdownTableBodyNone"><em><b>43.77 ops/sec</b></em>   </td><td class="markdownTableBodyNone">34.56 ops/sec   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md35853"></a>
Bundle size</h2>
<p>Both libraries can be used in the browser and they provide a UMD bundle. The bundles are self-contained, that means they can be included and used without having to add any other dependencies. The table shows the bundle size of the minified versions. <em>Lower is better</em>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">xxhashjs   </th><th class="markdownTableHeadNone">xxhash-wasm    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bundle size   </td><td class="markdownTableBodyNone">41.5kB   </td><td class="markdownTableBodyNone"><em><b>11.4kB</b></em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Gzipped Size   </td><td class="markdownTableBodyNone">10.3kB   </td><td class="markdownTableBodyNone"><em><b>2.3kB</b></em>   </td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_e1fb642c3e0fc1a052d95b0295820cd9.html">xxhash-wasm</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
