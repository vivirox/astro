<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/before-after-hook Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_0abf3bd498cc6beb03f169e47c497599.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">before-after-hook Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<blockquote class="doxtable">
<p>asynchronous hooks for internal functionality </p>
</blockquote>
<p><a href="https://www.npmjs.com/package/before-after-hook"><img src="https://img.shields.io/npm/dw/before-after-hook.svg" alt="npm downloads" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/gr2m/before-after-hook/actions/workflows/test.yml"><img src="https://github.com/gr2m/before-after-hook/actions/workflows/test.yml/badge.svg" alt="Test" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md9211"></a>
Usage</h1>
<table class="doxtable">
<tr>
<th>Browsers </th><td width="100%"><p class="starttd">Load <code>before-after-hook</code> directly from <a href="https://cdn.skypack.dev">cdn.skypack.dev</a></p>
<div class="fragment"><div class="line">&lt;script type=&quot;module&quot;&gt;</div>
<div class="line">  import Hook from &quot;https://cdn.skypack.dev/before-after-hook&quot;;</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<th>Node </th><td><p class="starttd"></p>
<p class="intertd">Install with <code>npm install before-after-hook</code></p>
<div class="fragment"><div class="line">import Hook from &quot;before-after-hook&quot;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<h2><a class="anchor" id="autotoc_md9212"></a>
Singular hook</h2>
<div class="fragment"><div class="line">// instantiate singular hook API</div>
<div class="line">const hook = new Hook.Singular();</div>
<div class="line"> </div>
<div class="line">// Create a hook</div>
<div class="line">async function getData(options) {</div>
<div class="line">  try {</div>
<div class="line">    const result = await hook(fetchFromDatabase, options);</div>
<div class="line">    return handleData(result);</div>
<div class="line">  } catch (error) {</div>
<div class="line">    return handleGetError(error);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// register before/error/after hooks.</div>
<div class="line">// The methods can be async or return a promise</div>
<div class="line">hook.before(beforeHook);</div>
<div class="line">hook.error(errorHook);</div>
<div class="line">hook.after(afterHook);</div>
<div class="line"> </div>
<div class="line">getData({ id: 123 });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9213"></a>
Hook collection</h2>
<div class="fragment"><div class="line">// instantiate hook collection API</div>
<div class="line">const hookCollection = new Hook.Collection();</div>
<div class="line"> </div>
<div class="line">// Create a hook</div>
<div class="line">async function getData(options) {</div>
<div class="line">  try {</div>
<div class="line">    const result = await hookCollection(&quot;get&quot;, fetchFromDatabase, options);</div>
<div class="line">    return handleData(result);</div>
<div class="line">  } catch (error) {</div>
<div class="line">    return handleGetError(error);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// register before/error/after hooks.</div>
<div class="line">// The methods can be async or return a promise</div>
<div class="line">hookCollection.before(&quot;get&quot;, beforeHook);</div>
<div class="line">hookCollection.error(&quot;get&quot;, errorHook);</div>
<div class="line">hookCollection.after(&quot;get&quot;, afterHook);</div>
<div class="line"> </div>
<div class="line">getData({ id: 123 });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9214"></a>
Hook.Singular vs Hook.Collection</h2>
<p>There's no fundamental difference between the <code>Hook.Singular</code> and <code>Hook.Collection</code> hooks except for the fact that a hook from a collection requires you to pass along the name. Therefore the following explanation applies to both code snippets as described above.</p>
<p>The methods are executed in the following order</p>
<ol type="1">
<li><code>beforeHook</code></li>
<li><code>fetchFromDatabase</code></li>
<li><code>afterHook</code></li>
<li><code>handleData</code></li>
</ol>
<p><code>beforeHook</code> can mutate <code>options</code> before it’s passed to <code>fetchFromDatabase</code>.</p>
<p>If an error is thrown in <code>beforeHook</code> or <code>fetchFromDatabase</code> then <code>errorHook</code> is called next.</p>
<p>If <code>afterHook</code> throws an error then <code>handleGetError</code> is called instead of <code>handleData</code>.</p>
<p>If <code>errorHook</code> throws an error then <code>handleGetError</code> is called next, otherwise <code>afterHook</code> and <code>handleData</code>.</p>
<p>You can also use <code>hook.wrap</code> to achieve the same thing as shown above (collection example):</p>
<div class="fragment"><div class="line">hookCollection.wrap(&quot;get&quot;, async (getData, options) =&gt; {</div>
<div class="line">  await beforeHook(options);</div>
<div class="line"> </div>
<div class="line">  try {</div>
<div class="line">    const result = getData(options);</div>
<div class="line">  } catch (error) {</div>
<div class="line">    await errorHook(error, options);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  await afterHook(result, options);</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9215"></a>
API</h1>
<ul>
<li>Singular Hook Constructor</li>
<li>Hook Collection Constructor</li>
</ul>
<h1><a class="anchor" id="autotoc_md9216"></a>
Singular hook API</h1>
<ul>
<li>Singular constructor</li>
<li>hook.api</li>
<li>hook()</li>
<li>hook.before()</li>
<li>hook.error()</li>
<li>hook.after()</li>
<li>hook.wrap()</li>
<li>hook.remove()</li>
</ul>
<h2><a class="anchor" id="autotoc_md9217"></a>
Singular constructor</h2>
<p>The <code>Hook.Singular</code> constructor has no options and returns a <code>hook</code> instance with the methods below:</p>
<div class="fragment"><div class="line">const hook = new Hook.Singular();</div>
</div><!-- fragment --><p>Using the singular hook is recommended for TypeScript</p>
<h2><a class="anchor" id="autotoc_md9218"></a>
Singular API</h2>
<p>The singular hook is a reference to a single hook. This means that there's no need to pass along any identifier (such as a <code>name</code> as can be seen in the Hook.Collection API).</p>
<p>The API of a singular hook is exactly the same as a collection hook and we therefore suggest you read the Hook.Collection API and leave out any use of the <code>name</code> argument. Just skip it like described in this example:</p>
<div class="fragment"><div class="line">const hook = new Hook.Singular();</div>
<div class="line"> </div>
<div class="line">// good</div>
<div class="line">hook.before(beforeHook);</div>
<div class="line">hook.after(afterHook);</div>
<div class="line">hook(fetchFromDatabase, options);</div>
<div class="line"> </div>
<div class="line">// bad</div>
<div class="line">hook.before(&quot;get&quot;, beforeHook);</div>
<div class="line">hook.after(&quot;get&quot;, afterHook);</div>
<div class="line">hook(&quot;get&quot;, fetchFromDatabase, options);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9219"></a>
Hook collection API</h1>
<ul>
<li>Collection constructor</li>
<li>hookCollection.api</li>
<li>hookCollection()</li>
<li>hookCollection.before()</li>
<li>hookCollection.error()</li>
<li>hookCollection.after()</li>
<li>hookCollection.wrap()</li>
<li>hookCollection.remove()</li>
</ul>
<h2><a class="anchor" id="autotoc_md9220"></a>
Collection constructor</h2>
<p>The <code>Hook.Collection</code> constructor has no options and returns a <code>hookCollection</code> instance with the methods below</p>
<div class="fragment"><div class="line">const hookCollection = new Hook.Collection();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9221"></a>
hookCollection.api</h2>
<p>Use the <code>api</code> property to return the public API:</p>
<ul>
<li>hookCollection.before()</li>
<li>hookCollection.after()</li>
<li>hookCollection.error()</li>
<li>hookCollection.wrap()</li>
<li>hookCollection.remove()</li>
</ul>
<p>That way you don’t need to expose the hookCollection() method to consumers of your library</p>
<h2><a class="anchor" id="autotoc_md9222"></a>
hookCollection()</h2>
<p>Invoke before and after hooks. Returns a promise.</p>
<div class="fragment"><div class="line">hookCollection(nameOrNames, method /*, options */);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String or Array of Strings </td><td>Hook name, for example <code>'save'</code>. Or an array of names, see example below. </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>method</code> </th><td>Function </td><td>Callback to be executed after all before hooks finished execution successfully. <code>options</code> is passed as first argument </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>options</code> </th><td>Object </td><td>Will be passed to all before hooks as reference, so they can mutate it </td><td>No, defaults to empty object (<code>{}</code>)  </td></tr>
</table>
<p>Resolves with whatever <code>method</code> returns or resolves with. Rejects with error that is thrown or rejected with by</p>
<ol type="1">
<li>Any of the before hooks, whichever rejects / throws first</li>
<li><code>method</code></li>
<li>Any of the after hooks, whichever rejects / throws first</li>
</ol>
<p>Simple Example</p>
<div class="fragment"><div class="line">hookCollection(</div>
<div class="line">  &quot;save&quot;,</div>
<div class="line">  (record) =&gt; {</div>
<div class="line">    return store.save(record);</div>
<div class="line">  },</div>
<div class="line">  record</div>
<div class="line">);</div>
<div class="line">// shorter:  hookCollection(&#39;save&#39;, store.save, record)</div>
<div class="line"> </div>
<div class="line">hookCollection.before(&quot;save&quot;, function addTimestamps(record) {</div>
<div class="line">  const now = new Date().toISOString();</div>
<div class="line">  if (record.createdAt) {</div>
<div class="line">    record.updatedAt = now;</div>
<div class="line">  } else {</div>
<div class="line">    record.createdAt = now;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Example defining multiple hooks at once.</p>
<div class="fragment"><div class="line">hookCollection(</div>
<div class="line">  [&quot;add&quot;, &quot;save&quot;],</div>
<div class="line">  (record) =&gt; {</div>
<div class="line">    return store.save(record);</div>
<div class="line">  },</div>
<div class="line">  record</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">hookCollection.before(&quot;add&quot;, function addTimestamps(record) {</div>
<div class="line">  if (!record.type) {</div>
<div class="line">    throw new Error(&quot;type property is required&quot;);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">hookCollection.before(&quot;save&quot;, function addTimestamps(record) {</div>
<div class="line">  if (!record.type) {</div>
<div class="line">    throw new Error(&quot;type property is required&quot;);</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Defining multiple hooks is helpful if you have similar methods for which you want to define separate hooks, but also an additional hook that gets called for all at once. The example above is equal to this:</p>
<div class="fragment"><div class="line">hookCollection(</div>
<div class="line">  &quot;add&quot;,</div>
<div class="line">  (record) =&gt; {</div>
<div class="line">    return hookCollection(</div>
<div class="line">      &quot;save&quot;,</div>
<div class="line">      (record) =&gt; {</div>
<div class="line">        return store.save(record);</div>
<div class="line">      },</div>
<div class="line">      record</div>
<div class="line">    );</div>
<div class="line">  },</div>
<div class="line">  record</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9223"></a>
hookCollection.before()</h2>
<p>Add before hook for given name.</p>
<div class="fragment"><div class="line">hookCollection.before(name, method);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String </td><td>Hook name, for example <code>'save'</code> </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>method</code> </th><td>Function </td><td>Executed before the wrapped method. Called with the hook’s <code>options</code> argument. Before hooks can mutate the passed options before they are passed to the wrapped method.  </td><td>Yes  </td></tr>
</table>
<p>Example</p>
<div class="fragment"><div class="line">hookCollection.before(&quot;save&quot;, function validate(record) {</div>
<div class="line">  if (!record.name) {</div>
<div class="line">    throw new Error(&quot;name property is required&quot;);</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9224"></a>
hookCollection.error()</h2>
<p>Add error hook for given name.</p>
<div class="fragment"><div class="line">hookCollection.error(name, method);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String </td><td>Hook name, for example <code>'save'</code> </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>method</code> </th><td>Function </td><td>Executed when an error occurred in either the wrapped method or a <code>before</code> hook. Called with the thrown <code>error</code> and the hook’s <code>options</code> argument. The first <code>method</code> which does not throw an error will set the result that the after hook methods will receive.  </td><td>Yes  </td></tr>
</table>
<p>Example</p>
<div class="fragment"><div class="line">hookCollection.error(&quot;save&quot;, (error, options) =&gt; {</div>
<div class="line">  if (error.ignore) return;</div>
<div class="line">  throw error;</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9225"></a>
hookCollection.after()</h2>
<p>Add after hook for given name.</p>
<div class="fragment"><div class="line">hookCollection.after(name, method);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String </td><td>Hook name, for example <code>'save'</code> </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>method</code> </th><td>Function </td><td>Executed after wrapped method. Called with what the wrapped method resolves with the hook’s <code>options</code> argument.  </td><td>Yes  </td></tr>
</table>
<p>Example</p>
<div class="fragment"><div class="line">hookCollection.after(&quot;save&quot;, (result, options) =&gt; {</div>
<div class="line">  if (result.updatedAt) {</div>
<div class="line">    app.emit(&quot;update&quot;, result);</div>
<div class="line">  } else {</div>
<div class="line">    app.emit(&quot;create&quot;, result);</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9226"></a>
hookCollection.wrap()</h2>
<p>Add wrap hook for given name.</p>
<div class="fragment"><div class="line">hookCollection.wrap(name, method);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String </td><td>Hook name, for example <code>'save'</code> </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>method</code> </th><td>Function </td><td>Receives both the wrapped method and the passed options as arguments so it can add logic before and after the wrapped method, it can handle errors and even replace the wrapped method altogether  </td><td>Yes  </td></tr>
</table>
<p>Example</p>
<div class="fragment"><div class="line">hookCollection.wrap(&quot;save&quot;, async (saveInDatabase, options) =&gt; {</div>
<div class="line">  if (!record.name) {</div>
<div class="line">    throw new Error(&quot;name property is required&quot;);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  try {</div>
<div class="line">    const result = await saveInDatabase(options);</div>
<div class="line"> </div>
<div class="line">    if (result.updatedAt) {</div>
<div class="line">      app.emit(&quot;update&quot;, result);</div>
<div class="line">    } else {</div>
<div class="line">      app.emit(&quot;create&quot;, result);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return result;</div>
<div class="line">  } catch (error) {</div>
<div class="line">    if (error.ignore) return;</div>
<div class="line">    throw error;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>See also: Test mock example</p>
<h2><a class="anchor" id="autotoc_md9227"></a>
hookCollection.remove()</h2>
<p>Removes hook for given name.</p>
<div class="fragment"><div class="line">hookCollection.remove(name, hookMethod);</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Type </th><th>Description </th><th>Required   </th></tr>
<tr>
<th align="left"><code>name</code> </th><td>String </td><td>Hook name, for example <code>'save'</code> </td><td>Yes  </td></tr>
<tr>
<th align="left"><code>beforeHookMethod</code> </th><td>Function </td><td>Same function that was previously passed to <code>hookCollection.before()</code>, <code>hookCollection.error()</code>, <code>hookCollection.after()</code> or <code>hookCollection.wrap()</code>  </td><td>Yes  </td></tr>
</table>
<p>Example</p>
<div class="fragment"><div class="line">hookCollection.remove(&quot;save&quot;, validateRecord);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9228"></a>
TypeScript</h1>
<p>This library contains type definitions for TypeScript.</p>
<h2><a class="anchor" id="autotoc_md9229"></a>
Type support for <code>Singular</code>:</h2>
<div class="fragment"><div class="line">import Hook from &quot;before-after-hook&quot;;</div>
<div class="line"> </div>
<div class="line">type TOptions = { foo: string }; // type for options</div>
<div class="line">type TResult = { bar: number }; // type for result</div>
<div class="line">type TError = Error; // type for error</div>
<div class="line"> </div>
<div class="line">const hook = new Hook.Singular&lt;TOptions, TResult, TError&gt;();</div>
<div class="line"> </div>
<div class="line">hook.before((options) =&gt; {</div>
<div class="line">  // `options.foo` has `string` type</div>
<div class="line"> </div>
<div class="line">  // not allowed</div>
<div class="line">  options.foo = 42;</div>
<div class="line"> </div>
<div class="line">  // allowed</div>
<div class="line">  options.foo = &quot;Forty-Two&quot;;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const hookedMethod = hook(</div>
<div class="line">  (options) =&gt; {</div>
<div class="line">    // `options.foo` has `string` type</div>
<div class="line"> </div>
<div class="line">    // not allowed, because it does not satisfy the `R` type</div>
<div class="line">    return { foo: 42 };</div>
<div class="line"> </div>
<div class="line">    // allowed</div>
<div class="line">    return { bar: 42 };</div>
<div class="line">  },</div>
<div class="line">  { foo: &quot;Forty-Two&quot; }</div>
<div class="line">);</div>
</div><!-- fragment --><p>You can choose not to pass the types for options, result or error. So, these are completely valid:</p>
<div class="fragment"><div class="line">const hook = new Hook.Singular&lt;O, R&gt;();</div>
<div class="line">const hook = new Hook.Singular&lt;O&gt;();</div>
<div class="line">const hook = new Hook.Singular();</div>
</div><!-- fragment --><p>In these cases, the omitted types will implicitly be <code>any</code>.</p>
<h2><a class="anchor" id="autotoc_md9230"></a>
Type support for <code>Collection</code>:</h2>
<p><code>Collection</code> also has strict type support. You can use it like this:</p>
<div class="fragment"><div class="line">import { Hook } from &quot;before-after-hook&quot;;</div>
<div class="line"> </div>
<div class="line">type HooksType = {</div>
<div class="line">  add: {</div>
<div class="line">    Options: { type: string };</div>
<div class="line">    Result: { id: number };</div>
<div class="line">    Error: Error;</div>
<div class="line">  };</div>
<div class="line">  save: {</div>
<div class="line">    Options: { type: string };</div>
<div class="line">    Result: { id: number };</div>
<div class="line">  };</div>
<div class="line">  read: {</div>
<div class="line">    Options: { id: number; foo: number };</div>
<div class="line">  };</div>
<div class="line">  destroy: {</div>
<div class="line">    Options: { id: number; foo: string };</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const hooks = new Hook.Collection&lt;HooksType&gt;();</div>
<div class="line"> </div>
<div class="line">hooks.before(&quot;destroy&quot;, (options) =&gt; {</div>
<div class="line">  // `options.id` has `number` type</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">hooks.error(&quot;add&quot;, (err, options) =&gt; {</div>
<div class="line">  // `options.type` has `string` type</div>
<div class="line">  // `err` is `instanceof Error`</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">hooks.error(&quot;save&quot;, (err, options) =&gt; {</div>
<div class="line">  // `options.type` has `string` type</div>
<div class="line">  // `err` has type `any`</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">hooks.after(&quot;save&quot;, (result, options) =&gt; {</div>
<div class="line">  // `options.type` has `string` type</div>
<div class="line">  // `result.id` has `number` type</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can choose not to pass the types altogether. In that case, everything will implicitly be <code>any</code>:</p>
<div class="fragment"><div class="line">const hook = new Hook.Collection();</div>
</div><!-- fragment --><p>Alternative imports:</p>
<div class="fragment"><div class="line">import { Singular, Collection } from &quot;before-after-hook&quot;;</div>
<div class="line"> </div>
<div class="line">const hook = new Singular();</div>
<div class="line">const hooks = new Collection();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9231"></a>
Upgrading to 1.4</h1>
<p>Since version 1.4 the <code>Hook</code> constructor has been deprecated in favor of returning <code>Hook.Singular</code> in an upcoming breaking release.</p>
<p>Version 1.4 is still 100% backwards-compatible, but if you want to continue using hook collections, we recommend using the <code>Hook.Collection</code> constructor instead before the next release.</p>
<p>For even more details, check out <a href="https://github.com/gr2m/before-after-hook/pull/52">the PR</a>.</p>
<h1><a class="anchor" id="autotoc_md9232"></a>
See also</h1>
<p>If <code>before-after-hook</code> is not for you, have a look at one of these alternatives:</p>
<ul>
<li><a href="https://github.com/keystonejs/grappling-hook">https://github.com/keystonejs/grappling-hook</a></li>
<li><a href="https://github.com/sebelga/promised-hooks">https://github.com/sebelga/promised-hooks</a></li>
<li><a href="https://github.com/bnoguchi/hooks-js">https://github.com/bnoguchi/hooks-js</a></li>
<li><a href="https://github.com/cb1kenobi/hook-emitter">https://github.com/cb1kenobi/hook-emitter</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md9233"></a>
License</h1>
<p>[Apache 2.0](LICENSE) </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_0abf3bd498cc6beb03f169e47c497599.html">before-after-hook</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
