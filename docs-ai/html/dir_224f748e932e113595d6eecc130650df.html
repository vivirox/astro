<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/path-to-regexp-updated Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_224f748e932e113595d6eecc130650df.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">path-to-regexp-updated Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<blockquote class="doxtable">
<p>Turn a path string such as <code>/user/:name</code> into a regular expression. </p>
</blockquote>
<p><a href="https://npmjs.org/package/path-to-regexp"><img src="https://img.shields.io/npm/v/path-to-regexp" alt="NPM version" class="inline"/></a> <a href="https://npmjs.org/package/path-to-regexp"><img src="https://img.shields.io/npm/dm/path-to-regexp" alt="NPM downloads" class="inline"/></a> <a href="https://github.com/pillarjs/path-to-regexp/actions/workflows/ci.yml?query=branch%3Amaster"><img src="https://img.shields.io/github/actions/workflow/status/pillarjs/path-to-regexp/ci.yml?branch=master" alt="Build status" class="inline"/></a> <a href="https://codecov.io/gh/pillarjs/path-to-regexp"><img src="https://img.shields.io/codecov/c/gh/pillarjs/path-to-regexp" alt="Build coverage" class="inline"/></a> <a class="el" href="tests_2security_2node__modules_2_8pnpm_2chart_8js_0d4_84_88_2node__modules_2chart_8js_2_l_i_c_e_n_s_e_8md.html"><img src="http://img.shields.io/npm/l/path-to-regexp.svg?style=flat" alt="License" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md25767"></a>
Installation</h1>
<div class="fragment"><div class="line">npm install path-to-regexp --save</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25768"></a>
Usage</h1>
<div class="fragment"><div class="line">const { pathToRegexp, match, parse, compile } = require(&quot;path-to-regexp&quot;);</div>
<div class="line"> </div>
<div class="line">// pathToRegexp(path, keys?, options?)</div>
<div class="line">// match(path)</div>
<div class="line">// parse(path)</div>
<div class="line">// compile(path)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25769"></a>
Path to regexp</h2>
<p>The <code>pathToRegexp</code> function will return a regular expression object based on the provided <code>path</code> argument. It accepts the following arguments:</p>
<ul>
<li><b>path</b> A string, array of strings, or a regular expression.</li>
<li><b>keys</b> <em>(optional)</em> An array to populate with keys found in the path.</li>
<li><b>options</b> <em>(optional)</em><ul>
<li><b>sensitive</b> When <code>true</code> the regexp will be case sensitive. (default: <code>false</code>)</li>
<li><b>strict</b> When <code>true</code> the regexp won't allow an optional trailing delimiter to match. (default: <code>false</code>)</li>
<li><b>end</b> When <code>true</code> the regexp will match to the end of the string. (default: <code>true</code>)</li>
<li><b>start</b> When <code>true</code> the regexp will match from the beginning of the string. (default: <code>true</code>)</li>
<li><b>delimiter</b> The default delimiter for segments, e.g. <code>[^/#?]</code> for <code>:named</code> patterns. (default: &lsquo;&rsquo;/#?'<code>)</code></li>
<li><code>**endsWith** Optional character, or list of characters, to treat as "end" characters.</code></li>
<li><code>**encode** A function to encode strings before inserting into</code>RegExp<code>. (default:</code>x =&gt; x<code>)</code></li>
<li><code>**prefixes** List of characters to automatically consider prefixes when parsing. (default:</code>./`)</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">const keys = [];</div>
<div class="line">const regexp = pathToRegexp(&quot;/foo/:bar&quot;, keys);</div>
<div class="line">// regexp = /^\/foo(?:\/([^\/#\?]+?))[\/#\?]?$/i</div>
<div class="line">// keys = [{ name: &#39;bar&#39;, prefix: &#39;/&#39;, suffix: &#39;&#39;, pattern: &#39;[^\\/#\\?]+?&#39;, modifier: &#39;&#39; }]</div>
</div><!-- fragment --><p><b>Please note:</b> The <code>RegExp</code> returned by <code>path-to-regexp</code> is intended for ordered data (e.g. pathnames, hostnames). It can not handle arbitrarily ordered data (e.g. query strings, URL fragments, JSON, etc). When using paths that contain query strings, you need to escape the question mark (<code>?</code>) to ensure it does not flag the parameter as optional.</p>
<h2><a class="anchor" id="autotoc_md25770"></a>
Parameters</h2>
<p>The path argument is used to define parameters and populate keys.</p>
<h3><a class="anchor" id="autotoc_md25771"></a>
Named Parameters</h3>
<p>Named parameters are defined by prefixing a colon to the parameter name (<code>:foo</code>).</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:foo/:bar&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, prefix: &#39;/&#39;, ... }, { name: &#39;bar&#39;, prefix: &#39;/&#39;, ... }]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test/route&quot;);</div>
<div class="line">//=&gt; [ &#39;/test/route&#39;, &#39;test&#39;, &#39;route&#39;, index: 0, input: &#39;/test/route&#39;, groups: undefined ]</div>
</div><!-- fragment --><p><b>Please note:</b> Parameter names must use "word characters" (<code>[A-Za-z0-9_]</code>).</p>
<h4><a class="anchor" id="autotoc_md25772"></a>
Custom Matching Parameters</h4>
<p>Parameters can have a custom regexp, which overrides the default match (<code>[^/]+</code>). For example, you can match digits or names in a path:</p>
<div class="fragment"><div class="line">const regexpNumbers = pathToRegexp(&quot;/icon-:foo(\\d+).png&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, ... }]</div>
<div class="line"> </div>
<div class="line">regexpNumbers.exec(&quot;/icon-123.png&quot;);</div>
<div class="line">//=&gt; [&#39;/icon-123.png&#39;, &#39;123&#39;]</div>
<div class="line"> </div>
<div class="line">regexpNumbers.exec(&quot;/icon-abc.png&quot;);</div>
<div class="line">//=&gt; null</div>
<div class="line"> </div>
<div class="line">const regexpWord = pathToRegexp(&quot;/(user|u)&quot;);</div>
<div class="line">// keys = [{ name: 0, ... }]</div>
<div class="line"> </div>
<div class="line">regexpWord.exec(&quot;/u&quot;);</div>
<div class="line">//=&gt; [&#39;/u&#39;, &#39;u&#39;]</div>
<div class="line"> </div>
<div class="line">regexpWord.exec(&quot;/users&quot;);</div>
<div class="line">//=&gt; null</div>
</div><!-- fragment --><p><b>Tip:</b> Backslashes need to be escaped with another backslash in JavaScript strings.</p>
<h4><a class="anchor" id="autotoc_md25773"></a>
Custom Prefix and Suffix</h4>
<p>Parameters can be wrapped in <code>{}</code> to create custom prefixes or suffixes for your segment:</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:attr1?{-:attr2}?{-:attr3}?&quot;);</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test&quot;);</div>
<div class="line">// =&gt; [&#39;/test&#39;, &#39;test&#39;, undefined, undefined]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test-test&quot;);</div>
<div class="line">// =&gt; [&#39;/test&#39;, &#39;test&#39;, &#39;test&#39;, undefined]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25774"></a>
Unnamed Parameters</h3>
<p>It is possible to write an unnamed parameter that only consists of a regexp. It works the same the named parameter, except it will be numerically indexed:</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:foo/(.*)&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, ... }, { name: 0, ... }]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test/route&quot;);</div>
<div class="line">//=&gt; [ &#39;/test/route&#39;, &#39;test&#39;, &#39;route&#39;, index: 0, input: &#39;/test/route&#39;, groups: undefined ]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25775"></a>
Modifiers</h3>
<p>Modifiers must be placed after the parameter (e.g. <code>/:foo?</code>, <code>/(test)?</code>, <code>/:foo(test)?</code>, or <code>{-:foo(test)}?</code>).</p>
<h4><a class="anchor" id="autotoc_md25776"></a>
Optional</h4>
<p>Parameters can be suffixed with a question mark (<code>?</code>) to make the parameter optional.</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:foo/:bar?&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, ... }, { name: &#39;bar&#39;, prefix: &#39;/&#39;, modifier: &#39;?&#39; }]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test&quot;);</div>
<div class="line">//=&gt; [ &#39;/test&#39;, &#39;test&#39;, undefined, index: 0, input: &#39;/test&#39;, groups: undefined ]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/test/route&quot;);</div>
<div class="line">//=&gt; [ &#39;/test/route&#39;, &#39;test&#39;, &#39;route&#39;, index: 0, input: &#39;/test/route&#39;, groups: undefined ]</div>
</div><!-- fragment --><p><b>Tip:</b> The prefix is also optional, escape the prefix <code>\/</code> to make it required.</p>
<p>When dealing with query strings, escape the question mark (<code>?</code>) so it doesn't mark the parameter as optional. Handling unordered data is outside the scope of this library.</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/search/:tableName\\?useIndex=true&amp;term=amazing&quot;);</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/search/people?useIndex=true&amp;term=amazing&quot;);</div>
<div class="line">//=&gt; [ &#39;/search/people?useIndex=true&amp;term=amazing&#39;, &#39;people&#39;, index: 0, input: &#39;/search/people?useIndex=true&amp;term=amazing&#39;, groups: undefined ]</div>
<div class="line"> </div>
<div class="line">// This library does not handle query strings in different orders</div>
<div class="line">regexp.exec(&quot;/search/people?term=amazing&amp;useIndex=true&quot;);</div>
<div class="line">//=&gt; null</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md25777"></a>
Zero or more</h4>
<p>Parameters can be suffixed with an asterisk (<code>*</code>) to denote a zero or more parameter matches.</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:foo*&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, prefix: &#39;/&#39;, modifier: &#39;*&#39; }]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/&quot;);</div>
<div class="line">//=&gt; [ &#39;/&#39;, undefined, index: 0, input: &#39;/&#39;, groups: undefined ]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/bar/baz&quot;);</div>
<div class="line">//=&gt; [ &#39;/bar/baz&#39;, &#39;bar/baz&#39;, index: 0, input: &#39;/bar/baz&#39;, groups: undefined ]</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md25778"></a>
One or more</h4>
<p>Parameters can be suffixed with a plus sign (<code>+</code>) to denote a one or more parameter matches.</p>
<div class="fragment"><div class="line">const regexp = pathToRegexp(&quot;/:foo+&quot;);</div>
<div class="line">// keys = [{ name: &#39;foo&#39;, prefix: &#39;/&#39;, modifier: &#39;+&#39; }]</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/&quot;);</div>
<div class="line">//=&gt; null</div>
<div class="line"> </div>
<div class="line">regexp.exec(&quot;/bar/baz&quot;);</div>
<div class="line">//=&gt; [ &#39;/bar/baz&#39;,&#39;bar/baz&#39;, index: 0, input: &#39;/bar/baz&#39;, groups: undefined ]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25779"></a>
Match</h2>
<p>The <code>match</code> function will return a function for transforming paths into parameters:</p>
<div class="fragment"><div class="line">// Make sure you consistently `decode` segments.</div>
<div class="line">const fn = match(&quot;/user/:id&quot;, { decode: decodeURIComponent });</div>
<div class="line"> </div>
<div class="line">fn(&quot;/user/123&quot;); //=&gt; { path: &#39;/user/123&#39;, index: 0, params: { id: &#39;123&#39; } }</div>
<div class="line">fn(&quot;/invalid&quot;); //=&gt; false</div>
<div class="line">fn(&quot;/user/caf%C3%A9&quot;); //=&gt; { path: &#39;/user/caf%C3%A9&#39;, index: 0, params: { id: &#39;café&#39; } }</div>
</div><!-- fragment --><p>The <code>match</code> function can be used to custom match named parameters. For example, this can be used to whitelist a small number of valid paths:</p>
<div class="fragment"><div class="line">const urlMatch = match(&quot;/users/:id/:tab(home|photos|bio)&quot;, {</div>
<div class="line">  decode: decodeURIComponent,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">urlMatch(&quot;/users/1234/photos&quot;);</div>
<div class="line">//=&gt; { path: &#39;/users/1234/photos&#39;, index: 0, params: { id: &#39;1234&#39;, tab: &#39;photos&#39; } }</div>
<div class="line"> </div>
<div class="line">urlMatch(&quot;/users/1234/bio&quot;);</div>
<div class="line">//=&gt; { path: &#39;/users/1234/bio&#39;, index: 0, params: { id: &#39;1234&#39;, tab: &#39;bio&#39; } }</div>
<div class="line"> </div>
<div class="line">urlMatch(&quot;/users/1234/otherstuff&quot;);</div>
<div class="line">//=&gt; false</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25780"></a>
Process Pathname</h3>
<p>You should make sure variations of the same path match the expected <code>path</code>. Here's one possible solution using <code>encode</code>:</p>
<div class="fragment"><div class="line">const fn = match(&quot;/café&quot;, { encode: encodeURI });</div>
<div class="line"> </div>
<div class="line">fn(&quot;/caf%C3%A9&quot;); //=&gt; { path: &#39;/caf%C3%A9&#39;, index: 0, params: {} }</div>
</div><!-- fragment --><p><b>Note:</b> <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><code>URL</code></a> encodes paths, so <code>/café</code> would be normalized to <code>/cafC3A9</code> and match in the above example.</p>
<h4><a class="anchor" id="autotoc_md25781"></a>
Alternative Using Normalize</h4>
<p>Sometimes you won't have already normalized paths to use, so you could normalize it yourself before matching:</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * Normalize a pathname for matching, replaces multiple slashes with a single</div>
<div class="line"> * slash and normalizes unicode characters to &quot;NFC&quot;. When using this method,</div>
<div class="line"> * `decode` should be an identity function so you don&#39;t decode strings twice.</div>
<div class="line"> */</div>
<div class="line">function normalizePathname(pathname: string) {</div>
<div class="line">  return (</div>
<div class="line">    decodeURI(pathname)</div>
<div class="line">      // Replaces repeated slashes in the URL.</div>
<div class="line">      .replace(/\/+/g, &quot;/&quot;)</div>
<div class="line">      // Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize</div>
<div class="line">      // Note: Missing native IE support, may want to skip this step.</div>
<div class="line">      .normalize()</div>
<div class="line">  );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Two possible ways of writing `/café`:</div>
<div class="line">const re = pathToRegexp(&quot;/caf\u00E9&quot;);</div>
<div class="line">const input = encodeURI(&quot;/cafe\u0301&quot;);</div>
<div class="line"> </div>
<div class="line">re.test(input); //=&gt; false</div>
<div class="line">re.test(normalizePathname(input)); //=&gt; true</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25782"></a>
Parse</h2>
<p>The <code>parse</code> function will return a list of strings and keys from a path string:</p>
<div class="fragment"><div class="line">const tokens = parse(&quot;/route/:foo/(.*)&quot;);</div>
<div class="line"> </div>
<div class="line">console.log(tokens[0]);</div>
<div class="line">//=&gt; &quot;/route&quot;</div>
<div class="line"> </div>
<div class="line">console.log(tokens[1]);</div>
<div class="line">//=&gt; { name: &#39;foo&#39;, prefix: &#39;/&#39;, suffix: &#39;&#39;, pattern: &#39;[^\\/#\\?]+?&#39;, modifier: &#39;&#39; }</div>
<div class="line"> </div>
<div class="line">console.log(tokens[2]);</div>
<div class="line">//=&gt; { name: 0, prefix: &#39;/&#39;, suffix: &#39;&#39;, pattern: &#39;.*&#39;, modifier: &#39;&#39; }</div>
</div><!-- fragment --><p><b>Note:</b> This method only works with strings.</p>
<h2><a class="anchor" id="autotoc_md25783"></a>
Compile ("Reverse" Path-To-RegExp)</h2>
<p>The <code>compile</code> function will return a function for transforming parameters into a valid path:</p>
<div class="fragment"><div class="line">// Make sure you encode your path segments consistently.</div>
<div class="line">const toPath = compile(&quot;/user/:id&quot;, { encode: encodeURIComponent });</div>
<div class="line"> </div>
<div class="line">toPath({ id: 123 }); //=&gt; &quot;/user/123&quot;</div>
<div class="line">toPath({ id: &quot;café&quot; }); //=&gt; &quot;/user/caf%C3%A9&quot;</div>
<div class="line">toPath({ id: &quot;:/&quot; }); //=&gt; &quot;/user/%3A%2F&quot;</div>
<div class="line"> </div>
<div class="line">// Without `encode`, you need to make sure inputs are encoded correctly.</div>
<div class="line">// (Note: You can use `validate: false` to create an invalid paths.)</div>
<div class="line">const toPathRaw = compile(&quot;/user/:id&quot;, { validate: false });</div>
<div class="line"> </div>
<div class="line">toPathRaw({ id: &quot;%3A%2F&quot; }); //=&gt; &quot;/user/%3A%2F&quot;</div>
<div class="line">toPathRaw({ id: &quot;:/&quot; }); //=&gt; &quot;/user/:/&quot;</div>
<div class="line"> </div>
<div class="line">const toPathRepeated = compile(&quot;/:segment+&quot;);</div>
<div class="line"> </div>
<div class="line">toPathRepeated({ segment: &quot;foo&quot; }); //=&gt; &quot;/foo&quot;</div>
<div class="line">toPathRepeated({ segment: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] }); //=&gt; &quot;/a/b/c&quot;</div>
<div class="line"> </div>
<div class="line">const toPathRegexp = compile(&quot;/user/:id(\\d+)&quot;);</div>
<div class="line"> </div>
<div class="line">toPathRegexp({ id: 123 }); //=&gt; &quot;/user/123&quot;</div>
<div class="line">toPathRegexp({ id: &quot;123&quot; }); //=&gt; &quot;/user/123&quot;</div>
</div><!-- fragment --><p><b>Note:</b> The generated function will throw on invalid input.</p>
<h2><a class="anchor" id="autotoc_md25784"></a>
Working with Tokens</h2>
<p>Path-To-RegExp exposes the two functions used internally that accept an array of tokens:</p>
<ul>
<li><code>tokensToRegexp(tokens, keys?, options?)</code> Transform an array of tokens into a matching regular expression.</li>
<li><code>tokensToFunction(tokens)</code> Transform an array of tokens into a path generator function.</li>
</ul>
<h3><a class="anchor" id="autotoc_md25785"></a>
Token Information</h3>
<ul>
<li><code>name</code> The name of the token (<code>string</code> for named or <code>number</code> for unnamed index)</li>
<li><code>prefix</code> The prefix string for the segment (e.g. <code>"/"</code>)</li>
<li><code>suffix</code> The suffix string for the segment (e.g. <code>""</code>)</li>
<li><code>pattern</code> The RegExp used to match this token (<code>string</code>)</li>
<li><code>modifier</code> The modifier character used for the segment (e.g. <code>?</code>)</li>
</ul>
<h1><a class="anchor" id="autotoc_md25786"></a>
Compatibility with Express &lt;= 4.x</h1>
<p>Path-To-RegExp breaks compatibility with Express &lt;= <code>4.x</code>:</p>
<ul>
<li>RegExp special characters can only be used in a parameter<ul>
<li>Express.js 4.x supported <code>RegExp</code> special characters regardless of position - this is considered a bug</li>
</ul>
</li>
<li>Parameters have suffixes that augment meaning - <code>*</code>, <code>+</code> and <code>?</code>. E.g. <code>/:user*</code></li>
<li>No wildcard asterisk (<code>*</code>) - use parameters instead (<code>(.*)</code> or <code>:splat*</code>)</li>
</ul>
<h1><a class="anchor" id="autotoc_md25787"></a>
Live Demo</h1>
<p>You can see a live demo of this library in use at <a href="http://forbeslindesay.github.io/express-route-tester/">express-route-tester</a>.</p>
<h1><a class="anchor" id="autotoc_md25788"></a>
License</h1>
<p>MIT </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_224f748e932e113595d6eecc130650df.html">path-to-regexp-updated</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
