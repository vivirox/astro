<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/zustand Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_4a96c3be620b48ab0d763959b920d30d.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">zustand Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p align="center"></p>
<p><img src="bear.jpg" alt="" class="inline"/> </p>
<p><a href="https://github.com/pmndrs/zustand/actions?query=workflow%3ALint"><img src="https://img.shields.io/github/actions/workflow/status/pmndrs/zustand/lint-and-type.yml?branch=main&amp;style=flat&amp;colorA=000000&amp;colorB=000000" alt="Build Status" class="inline"/></a> <a href="https://bundlephobia.com/result?p=zustand"><img src="https://img.shields.io/bundlephobia/minzip/zustand?label=bundle%20size&amp;style=flat&amp;colorA=000000&amp;colorB=000000" alt="Build Size" class="inline"/></a> <a href="https://www.npmjs.com/package/zustand"><img src="https://img.shields.io/npm/v/zustand?style=flat&amp;colorA=000000&amp;colorB=000000" alt="Version" class="inline"/></a> <a href="https://www.npmjs.com/package/zustand"><img src="https://img.shields.io/npm/dt/zustand.svg?style=flat&amp;colorA=000000&amp;colorB=000000" alt="Downloads" style="pointer-events: none;" class="inline"/></a> <a href="https://discord.gg/poimandres"><img src="https://img.shields.io/discord/740090768164651008?style=flat&amp;colorA=000000&amp;colorB=000000&amp;label=discord&amp;logo=discord&amp;logoColor=ffffff" alt="Discord Shield" class="inline"/></a></p>
<p>A small, fast and scalable bearbones state-management solution using simplified flux principles. Has a comfy API based on hooks, isn't boilerplatey or opinionated.</p>
<p>Don't disregard it because it's cute. It has quite the claws, lots of time was spent dealing with common pitfalls, like the dreaded <a href="https://react-redux.js.org/api/hooks#stale-props-and-zombie-children">zombie child problem</a>, <a href="https://github.com/bvaughn/rfcs/blob/useMutableSource/text/0000-use-mutable-source.md">react concurrency</a>, and <a href="https://github.com/facebook/react/issues/13332">context loss</a> between mixed renderers. It may be the one state-manager in the React space that gets all of these right.</p>
<p>You can try a live demo <a href="https://githubbox.com/pmndrs/zustand/tree/main/examples/demo">here</a>.</p>
<div class="fragment"><div class="line">npm i zustand</div>
</div><!-- fragment --><p>:warning: This readme is written for JavaScript users. If you are a TypeScript user, be sure to check out our TypeScript Usage section.</p>
<h2><a class="anchor" id="autotoc_md36696"></a>
First create a store</h2>
<p>Your store is a hook! You can put anything in it: primitives, objects, functions. State has to be updated immutably and the <code>set</code> function merges state to help it.</p>
<div class="fragment"><div class="line">import { create } from &#39;zustand&#39;</div>
<div class="line"> </div>
<div class="line">const useBearStore = create((set) =&gt; ({</div>
<div class="line">  bears: 0,</div>
<div class="line">  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),</div>
<div class="line">  removeAllBears: () =&gt; set({ bears: 0 }),</div>
<div class="line">}))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36697"></a>
Then bind your components, and that's it!</h2>
<p>Use the hook anywhere, no providers are needed. Select your state and the component will re-render on changes.</p>
<div class="fragment"><div class="line">function BearCounter() {</div>
<div class="line">  const bears = useBearStore((state) =&gt; state.bears)</div>
<div class="line">  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function Controls() {</div>
<div class="line">  const increasePopulation = useBearStore((state) =&gt; state.increasePopulation)</div>
<div class="line">  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36698"></a>
Why zustand over redux?</h3>
<ul>
<li>Simple and un-opinionated</li>
<li>Makes hooks the primary means of consuming state</li>
<li>Doesn't wrap your app in context providers</li>
<li>Can inform components transiently (without causing render)</li>
</ul>
<h3><a class="anchor" id="autotoc_md36699"></a>
Why zustand over context?</h3>
<ul>
<li>Less boilerplate</li>
<li>Renders components only on changes</li>
<li>Centralized, action-based state management</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md36701"></a>
Recipes</h1>
<h2><a class="anchor" id="autotoc_md36702"></a>
Fetching everything</h2>
<p>You can, but bear in mind that it will cause the component to update on every state change!</p>
<div class="fragment"><div class="line">const state = useBearStore()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36703"></a>
Selecting multiple state slices</h2>
<p>It detects changes with strict-equality (old === new) by default, this is efficient for atomic state picks.</p>
<div class="fragment"><div class="line">const nuts = useBearStore((state) =&gt; state.nuts)</div>
<div class="line">const honey = useBearStore((state) =&gt; state.honey)</div>
</div><!-- fragment --><p>If you want to construct a single object with multiple state-picks inside, similar to redux's mapStateToProps, you can use useShallow to prevent unnecessary rerenders when the selector output does not change according to shallow equal.</p>
<div class="fragment"><div class="line">import { create } from &#39;zustand&#39;</div>
<div class="line">import { useShallow } from &#39;zustand/react/shallow&#39;</div>
<div class="line"> </div>
<div class="line">const useBearStore = create((set) =&gt; ({</div>
<div class="line">  bears: 0,</div>
<div class="line">  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),</div>
<div class="line">  removeAllBears: () =&gt; set({ bears: 0 }),</div>
<div class="line">}))</div>
<div class="line"> </div>
<div class="line">// Object pick, re-renders the component when either state.nuts or state.honey change</div>
<div class="line">const { nuts, honey } = useBearStore(</div>
<div class="line">  useShallow((state) =&gt; ({ nuts: state.nuts, honey: state.honey })),</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Array pick, re-renders the component when either state.nuts or state.honey change</div>
<div class="line">const [nuts, honey] = useBearStore(</div>
<div class="line">  useShallow((state) =&gt; [state.nuts, state.honey]),</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Mapped picks, re-renders the component when state.treats changes in order, count or keys</div>
<div class="line">const treats = useBearStore(useShallow((state) =&gt; Object.keys(state.treats)))</div>
</div><!-- fragment --><p>For more control over re-rendering, you may provide any custom equality function.</p>
<div class="fragment"><div class="line">const treats = useBearStore(</div>
<div class="line">  (state) =&gt; state.treats,</div>
<div class="line">  (oldTreats, newTreats) =&gt; compare(oldTreats, newTreats),</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36704"></a>
Overwriting state</h2>
<p>The <code>set</code> function has a second argument, <code>false</code> by default. Instead of merging, it will replace the state model. Be careful not to wipe out parts you rely on, like actions.</p>
<div class="fragment"><div class="line">import omit from &#39;lodash-es/omit&#39;</div>
<div class="line"> </div>
<div class="line">const useFishStore = create((set) =&gt; ({</div>
<div class="line">  salmon: 1,</div>
<div class="line">  tuna: 2,</div>
<div class="line">  deleteEverything: () =&gt; set({}, true), // clears the entire store, actions included</div>
<div class="line">  deleteTuna: () =&gt; set((state) =&gt; omit(state, [&#39;tuna&#39;]), true),</div>
<div class="line">}))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36705"></a>
Async actions</h2>
<p>Just call <code>set</code> when you're ready, zustand doesn't care if your actions are async or not.</p>
<div class="fragment"><div class="line">const useFishStore = create((set) =&gt; ({</div>
<div class="line">  fishies: {},</div>
<div class="line">  fetch: async (pond) =&gt; {</div>
<div class="line">    const response = await fetch(pond)</div>
<div class="line">    set({ fishies: await response.json() })</div>
<div class="line">  },</div>
<div class="line">}))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36706"></a>
Read from state in actions</h2>
<p><code>set</code> allows fn-updates <code>set(state =&gt; result)</code>, but you still have access to state outside of it through <code>get</code>.</p>
<div class="fragment"><div class="line">const useSoundStore = create((set, get) =&gt; ({</div>
<div class="line">  sound: &#39;grunt&#39;,</div>
<div class="line">  action: () =&gt; {</div>
<div class="line">    const sound = get().sound</div>
<div class="line">    ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36707"></a>
Reading/writing state and reacting to changes outside of components</h2>
<p>Sometimes you need to access state in a non-reactive way or act upon the store. For these cases, the resulting hook has utility functions attached to its prototype.</p>
<p>:warning: This technique is not recommended for adding state in <a href="https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md">React Server Components</a> (typically in Next.js 13 and above). It can lead to unexpected bugs and privacy issues for your users. For more details, see <a href="https://github.com/pmndrs/zustand/discussions/2200">#2200</a>.</p>
<div class="fragment"><div class="line">const useDogStore = create(() =&gt; ({ paw: true, snout: true, fur: true }))</div>
<div class="line"> </div>
<div class="line">// Getting non-reactive fresh state</div>
<div class="line">const paw = useDogStore.getState().paw</div>
<div class="line">// Listening to all changes, fires synchronously on every change</div>
<div class="line">const unsub1 = useDogStore.subscribe(console.log)</div>
<div class="line">// Updating state, will trigger listeners</div>
<div class="line">useDogStore.setState({ paw: false })</div>
<div class="line">// Unsubscribe listeners</div>
<div class="line">unsub1()</div>
<div class="line"> </div>
<div class="line">// You can of course use the hook as you always would</div>
<div class="line">function Component() {</div>
<div class="line">  const paw = useDogStore((state) =&gt; state.paw)</div>
<div class="line">  ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36708"></a>
Using subscribe with selector</h3>
<p>If you need to subscribe with a selector, <code>subscribeWithSelector</code> middleware will help.</p>
<p>With this middleware <code>subscribe</code> accepts an additional signature:</p>
<div class="fragment"><div class="line">subscribe(selector, callback, options?: { equalityFn, fireImmediately }): Unsubscribe</div>
</div><!-- fragment --><div class="fragment"><div class="line">import { subscribeWithSelector } from &#39;zustand/middleware&#39;</div>
<div class="line">const useDogStore = create(</div>
<div class="line">  subscribeWithSelector(() =&gt; ({ paw: true, snout: true, fur: true })),</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Listening to selected changes, in this case when &quot;paw&quot; changes</div>
<div class="line">const unsub2 = useDogStore.subscribe((state) =&gt; state.paw, console.log)</div>
<div class="line">// Subscribe also exposes the previous value</div>
<div class="line">const unsub3 = useDogStore.subscribe(</div>
<div class="line">  (state) =&gt; state.paw,</div>
<div class="line">  (paw, previousPaw) =&gt; console.log(paw, previousPaw),</div>
<div class="line">)</div>
<div class="line">// Subscribe also supports an optional equality function</div>
<div class="line">const unsub4 = useDogStore.subscribe(</div>
<div class="line">  (state) =&gt; [state.paw, state.fur],</div>
<div class="line">  console.log,</div>
<div class="line">  { equalityFn: shallow },</div>
<div class="line">)</div>
<div class="line">// Subscribe and fire immediately</div>
<div class="line">const unsub5 = useDogStore.subscribe((state) =&gt; state.paw, console.log, {</div>
<div class="line">  fireImmediately: true,</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36709"></a>
Using zustand without React</h2>
<p>Zustand core can be imported and used without the React dependency. The only difference is that the create function does not return a hook, but the API utilities.</p>
<div class="fragment"><div class="line">import { createStore } from &#39;zustand/vanilla&#39;</div>
<div class="line"> </div>
<div class="line">const store = createStore((set) =&gt; ...)</div>
<div class="line">const { getState, setState, subscribe, getInitialState } = store</div>
<div class="line"> </div>
<div class="line">export default store</div>
</div><!-- fragment --><p>You can use a vanilla store with <code>useStore</code> hook available since v4.</p>
<div class="fragment"><div class="line">import { useStore } from &#39;zustand&#39;</div>
<div class="line">import { vanillaStore } from &#39;./vanillaStore&#39;</div>
<div class="line"> </div>
<div class="line">const useBoundStore = (selector) =&gt; useStore(vanillaStore, selector)</div>
</div><!-- fragment --><p>:warning: Note that middlewares that modify <code>set</code> or <code>get</code> are not applied to <code>getState</code> and <code>setState</code>.</p>
<h2><a class="anchor" id="autotoc_md36710"></a>
Transient updates (for often occurring state-changes)</h2>
<p>The subscribe function allows components to bind to a state-portion without forcing re-render on changes. Best combine it with useEffect for automatic unsubscribe on unmount. This can make a <a href="https://codesandbox.io/s/peaceful-johnson-txtws">drastic</a> performance impact when you are allowed to mutate the view directly.</p>
<div class="fragment"><div class="line">const useScratchStore = create((set) =&gt; ({ scratches: 0, ... }))</div>
<div class="line"> </div>
<div class="line">const Component = () =&gt; {</div>
<div class="line">  // Fetch initial state</div>
<div class="line">  const scratchRef = useRef(useScratchStore.getState().scratches)</div>
<div class="line">  // Connect to the store on mount, disconnect on unmount, catch state-changes in a reference</div>
<div class="line">  useEffect(() =&gt; useScratchStore.subscribe(</div>
<div class="line">    state =&gt; (scratchRef.current = state.scratches)</div>
<div class="line">  ), [])</div>
<div class="line">  ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36711"></a>
Sick of reducers and changing nested states? Use Immer!</h2>
<p>Reducing nested structures is tiresome. Have you tried <a href="https://github.com/mweststrate/immer">immer</a>?</p>
<div class="fragment"><div class="line">import { produce } from &#39;immer&#39;</div>
<div class="line"> </div>
<div class="line">const useLushStore = create((set) =&gt; ({</div>
<div class="line">  lush: { forest: { contains: { a: &#39;bear&#39; } } },</div>
<div class="line">  clearForest: () =&gt;</div>
<div class="line">    set(</div>
<div class="line">      produce((state) =&gt; {</div>
<div class="line">        state.lush.forest.contains = null</div>
<div class="line">      }),</div>
<div class="line">    ),</div>
<div class="line">}))</div>
<div class="line"> </div>
<div class="line">const clearForest = useLushStore((state) =&gt; state.clearForest)</div>
<div class="line">clearForest()</div>
</div><!-- fragment --><p><a href="./docs/guides/updating-state.md#with-immer">Alternatively, there are some other solutions.</a></p>
<h2><a class="anchor" id="autotoc_md36712"></a>
Persist middleware</h2>
<p>You can persist your store's data using any kind of storage.</p>
<div class="fragment"><div class="line">import { create } from &#39;zustand&#39;</div>
<div class="line">import { persist, createJSONStorage } from &#39;zustand/middleware&#39;</div>
<div class="line"> </div>
<div class="line">const useFishStore = create(</div>
<div class="line">  persist(</div>
<div class="line">    (set, get) =&gt; ({</div>
<div class="line">      fishes: 0,</div>
<div class="line">      addAFish: () =&gt; set({ fishes: get().fishes + 1 }),</div>
<div class="line">    }),</div>
<div class="line">    {</div>
<div class="line">      name: &#39;food-storage&#39;, // name of the item in the storage (must be unique)</div>
<div class="line">      storage: createJSONStorage(() =&gt; sessionStorage), // (optional) by default, &#39;localStorage&#39; is used</div>
<div class="line">    },</div>
<div class="line">  ),</div>
<div class="line">)</div>
</div><!-- fragment --><p>See the full documentation for this middleware.</p>
<h2><a class="anchor" id="autotoc_md36713"></a>
Immer middleware</h2>
<p>Immer is available as middleware too.</p>
<div class="fragment"><div class="line">import { create } from &#39;zustand&#39;</div>
<div class="line">import { immer } from &#39;zustand/middleware/immer&#39;</div>
<div class="line"> </div>
<div class="line">const useBeeStore = create(</div>
<div class="line">  immer((set) =&gt; ({</div>
<div class="line">    bees: 0,</div>
<div class="line">    addBees: (by) =&gt;</div>
<div class="line">      set((state) =&gt; {</div>
<div class="line">        state.bees += by</div>
<div class="line">      }),</div>
<div class="line">  })),</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36714"></a>
Can't live without redux-like reducers and action types?</h2>
<div class="fragment"><div class="line">const types = { increase: &#39;INCREASE&#39;, decrease: &#39;DECREASE&#39; }</div>
<div class="line"> </div>
<div class="line">const reducer = (state, { type, by = 1 }) =&gt; {</div>
<div class="line">  switch (type) {</div>
<div class="line">    case types.increase:</div>
<div class="line">      return { grumpiness: state.grumpiness + by }</div>
<div class="line">    case types.decrease:</div>
<div class="line">      return { grumpiness: state.grumpiness - by }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const useGrumpyStore = create((set) =&gt; ({</div>
<div class="line">  grumpiness: 0,</div>
<div class="line">  dispatch: (args) =&gt; set((state) =&gt; reducer(state, args)),</div>
<div class="line">}))</div>
<div class="line"> </div>
<div class="line">const dispatch = useGrumpyStore((state) =&gt; state.dispatch)</div>
<div class="line">dispatch({ type: types.increase, by: 2 })</div>
</div><!-- fragment --><p>Or, just use our redux-middleware. It wires up your main-reducer, sets the initial state, and adds a dispatch function to the state itself and the vanilla API.</p>
<div class="fragment"><div class="line">import { redux } from &#39;zustand/middleware&#39;</div>
<div class="line"> </div>
<div class="line">const useGrumpyStore = create(redux(reducer, initialState))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36715"></a>
Redux devtools</h2>
<div class="fragment"><div class="line">import { devtools } from &#39;zustand/middleware&#39;</div>
<div class="line"> </div>
<div class="line">// Usage with a plain action store, it will log actions as &quot;setState&quot;</div>
<div class="line">const usePlainStore = create(devtools((set) =&gt; ...))</div>
<div class="line">// Usage with a redux store, it will log full action types</div>
<div class="line">const useReduxStore = create(devtools(redux(reducer, initialState)))</div>
</div><!-- fragment --><p>One redux devtools connection for multiple stores</p>
<div class="fragment"><div class="line">import { devtools } from &#39;zustand/middleware&#39;</div>
<div class="line"> </div>
<div class="line">// Usage with a plain action store, it will log actions as &quot;setState&quot;</div>
<div class="line">const usePlainStore1 = create(devtools((set) =&gt; ..., { name, store: storeName1 }))</div>
<div class="line">const usePlainStore2 = create(devtools((set) =&gt; ..., { name, store: storeName2 }))</div>
<div class="line">// Usage with a redux store, it will log full action types</div>
<div class="line">const useReduxStore = create(devtools(redux(reducer, initialState)), , { name, store: storeName3 })</div>
<div class="line">const useReduxStore = create(devtools(redux(reducer, initialState)), , { name, store: storeName4 })</div>
</div><!-- fragment --><p>Assigning different connection names will separate stores in redux devtools. This also helps group different stores into separate redux devtools connections.</p>
<p>devtools takes the store function as its first argument, optionally you can name the store or configure <a href="https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md#serialize">serialize</a> options with a second argument.</p>
<p>Name store: <code>devtools(..., {name: "MyStore"})</code>, which will create a separate instance named "MyStore" in the devtools.</p>
<p>Serialize options: <code>devtools(..., { serialize: { options: true } })</code>.</p>
<h4><a class="anchor" id="autotoc_md36716"></a>
Logging Actions</h4>
<p>devtools will only log actions from each separated store unlike in a typical <em>combined reducers</em> redux store. See an approach to combining stores <a href="https://github.com/pmndrs/zustand/issues/163">https://github.com/pmndrs/zustand/issues/163</a></p>
<p>You can log a specific action type for each <code>set</code> function by passing a third parameter:</p>
<div class="fragment"><div class="line">const useBearStore = create(devtools((set) =&gt; ({</div>
<div class="line">  ...</div>
<div class="line">  eatFish: () =&gt; set(</div>
<div class="line">    (prev) =&gt; ({ fishes: prev.fishes &gt; 1 ? prev.fishes - 1 : 0 }),</div>
<div class="line">    undefined,</div>
<div class="line">    &#39;bear/eatFish&#39;</div>
<div class="line">  ),</div>
<div class="line">  ...</div>
</div><!-- fragment --><p>You can also log the action's type along with its payload:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">addFishes: (count) =&gt; set(</div>
<div class="line">  (prev) =&gt; ({ fishes: prev.fishes + count }),</div>
<div class="line">  undefined,</div>
<div class="line">  { type: &#39;bear/addFishes&#39;, count, }</div>
<div class="line">),</div>
<div class="line">...</div>
</div><!-- fragment --><p>If an action type is not provided, it is defaulted to "anonymous". You can customize this default value by providing an <code>anonymousActionType</code> parameter:</p>
<div class="fragment"><div class="line">devtools(..., { anonymousActionType: &#39;unknown&#39;, ... })</div>
</div><!-- fragment --><p>If you wish to disable devtools (on production for instance). You can customize this setting by providing the <code>enabled</code> parameter:</p>
<div class="fragment"><div class="line">devtools(..., { enabled: false, ... })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36717"></a>
React context</h2>
<p>The store created with <code>create</code> doesn't require context providers. In some cases, you may want to use contexts for dependency injection or if you want to initialize your store with props from a component. Because the normal store is a hook, passing it as a normal context value may violate the rules of hooks.</p>
<p>The recommended method available since v4 is to use the vanilla store.</p>
<div class="fragment"><div class="line">import { createContext, useContext } from &#39;react&#39;</div>
<div class="line">import { createStore, useStore } from &#39;zustand&#39;</div>
<div class="line"> </div>
<div class="line">const store = createStore(...) // vanilla store without hooks</div>
<div class="line"> </div>
<div class="line">const StoreContext = createContext()</div>
<div class="line"> </div>
<div class="line">const App = () =&gt; (</div>
<div class="line">  &lt;StoreContext.Provider value={store}&gt;</div>
<div class="line">    ...</div>
<div class="line">  &lt;/StoreContext.Provider&gt;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const Component = () =&gt; {</div>
<div class="line">  const store = useContext(StoreContext)</div>
<div class="line">  const slice = useStore(store, selector)</div>
<div class="line">  ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36718"></a>
TypeScript Usage</h2>
<p>Basic typescript usage doesn't require anything special except for writing <code>create&lt;State&gt;()(...)</code> instead of <code>create(...)</code>...</p>
<div class="fragment"><div class="line">import { create } from &#39;zustand&#39;</div>
<div class="line">import { devtools, persist } from &#39;zustand/middleware&#39;</div>
<div class="line">import type {} from &#39;@redux-devtools/extension&#39; // required for devtools typing</div>
<div class="line"> </div>
<div class="line">interface BearState {</div>
<div class="line">  bears: number</div>
<div class="line">  increase: (by: number) =&gt; void</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const useBearStore = create&lt;BearState&gt;()(</div>
<div class="line">  devtools(</div>
<div class="line">    persist(</div>
<div class="line">      (set) =&gt; ({</div>
<div class="line">        bears: 0,</div>
<div class="line">        increase: (by) =&gt; set((state) =&gt; ({ bears: state.bears + by })),</div>
<div class="line">      }),</div>
<div class="line">      {</div>
<div class="line">        name: &#39;bear-storage&#39;,</div>
<div class="line">      },</div>
<div class="line">    ),</div>
<div class="line">  ),</div>
<div class="line">)</div>
</div><!-- fragment --><p>A more complete TypeScript guide is here.</p>
<h2><a class="anchor" id="autotoc_md36719"></a>
Best practices</h2>
<ul>
<li>You may wonder how to organize your code for better maintenance: Splitting the store into separate slices.</li>
<li>Recommended usage for this unopinionated library: Flux inspired practice.</li>
<li>Calling actions outside a React event handler in pre-React 18.</li>
<li>Testing</li>
<li>For more, have a look <a href="./docs/">in the docs folder</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md36720"></a>
Third-Party Libraries</h2>
<p>Some users may want to extend Zustand's feature set which can be done using third-party libraries made by the community. For information regarding third-party libraries with Zustand, visit the doc.</p>
<h2><a class="anchor" id="autotoc_md36721"></a>
Comparison with other libraries</h2>
<ul>
<li><a href="https://docs.pmnd.rs/zustand/getting-started/comparison">Difference between zustand and other state management libraries for React</a> </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_4a96c3be620b48ab0d763959b920d30d.html">zustand</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
