<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/swrv Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_3605d1a2ccf0461b8f53b44a5a7cafe5.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">swrv Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p align="center"></p>
<p><img src="logo.png" alt="" width="100px" class="inline"/> </p>
<h1 align="center">swrv</h1>
<p><a href="https://www.npmjs.com/package/swrv"><img src="https://img.shields.io/npm/v/swrv.svg" alt="" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/swrv"><img src="https://img.shields.io/npm/dm/swrv" alt="npm" class="inline"/></a> <img src="https://github.com/Kong/swrv/workflows/build/badge.svg" alt="build" style="pointer-events: none;" class="inline"/></p>
<p><code>swrv</code> (pronounced "swerve") is a library using the <a href="https://vuejs.org/guide/extras/composition-api-faq.html">Vue Composition API</a> for remote data fetching. It is largely a port of <a href="https://github.com/zeit/swr">swr</a>.</p>
<ul>
<li><a href="https://docs-swrv.netlify.app/">Documentation</a></li>
</ul>
<p>The name “SWR” is derived from stale-while-revalidate, a cache invalidation strategy popularized by HTTP <a href="https://tools.ietf.org/html/rfc5861">RFC 5861</a>. SWR first returns the data from cache (stale), then sends the fetch request (revalidate), and finally comes with the up-to-date data again.</p>
<p>Features:</p>
<ul>
<li>Transport and protocol agnostic data fetching</li>
<li>Fast page navigation</li>
<li>Interval polling</li>
<li><strike>SSR support</strike> (removed as of version <code>0.10.0</code> - <a href="https://github.com/Kong/swrv/pull/304">read more</a>)</li>
<li>Vue 3 Support</li>
<li>Revalidation on focus</li>
<li>Request deduplication</li>
<li>TypeScript ready</li>
<li>Minimal API</li>
<li>Stale-if-error</li>
<li>Customizable cache implementation</li>
<li>Error Retry</li>
</ul>
<p>With <code>swrv</code>, components will get a stream of data updates constantly and automatically. Thus, the UI will be always fast and reactive.</p>
<h2><a class="anchor" id="autotoc_md31781"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#installation">Installation</a><ul>
<li>Vue 3</li>
<li>Vue 2.7</li>
<li>Vue 2.6 and below</li>
</ul>
</li>
<li>Getting Started</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#api">Api</a><ul>
<li>Parameters</li>
<li>Return Values</li>
<li>Config options</li>
</ul>
</li>
<li>Prefetching</li>
<li>Dependent Fetching</li>
<li>Stale-if-error</li>
<li>State Management<ul>
<li>useSwrvState</li>
<li>Vuex</li>
</ul>
</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#cache">Cache</a><ul>
<li>localStorage</li>
<li>Serve from cache only</li>
</ul>
</li>
<li>Error Handling</li>
<li><a class="el" href="md_node__modules_2safer-buffer_2_porting-_buffer.html#faq">FAQ</a><ul>
<li>How is swrv different from the swr react library</li>
<li>Why does swrv make so many requests</li>
<li>How can I refetch swrv data to update it</li>
</ul>
</li>
<li>Contributors ✨</li>
</ul>
<h2><a class="anchor" id="autotoc_md31782"></a>
Installation</h2>
<p>The version of <code>swrv</code> you install depends on the Vue dependency in your project.</p>
<h3><a class="anchor" id="autotoc_md31783"></a>
Vue 3</h3>
<div class="fragment"><div class="line"># Install the latest version</div>
<div class="line">yarn add swrv</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31784"></a>
Vue 2.7</h3>
<p>This version removes the dependency of the external <code>@vue/composition-api</code> plugin and adds <code>vue</code> to the <code>peerDependencies</code>, requiring a version that matches the following pattern: <code>&gt;= 2.7.0 &lt; 3</code></p>
<div class="fragment"><div class="line"># Install the 0.10.x version for Vue 2.7</div>
<div class="line">yarn add swrv@v2-latest</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31785"></a>
Vue 2.6 and below</h3>
<p>If you're installing for Vue <code>2.6.x</code> and below, you may want to check out a <a href="https://github.com/Kong/swrv/blob/b621aac02b7780a4143c5743682070223e793b10/README.md">previous version of the README</a> to view how to initialize <code>swrv</code> utilizing the external <code>@vue/composition-api</code> plugin.</p>
<div class="fragment"><div class="line"># Install the 0.9.x version for Vue &lt; 2.7</div>
<div class="line">yarn add swrv@legacy</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31786"></a>
Getting Started</h2>
<div class="fragment"><div class="line">&lt;template&gt;</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;div v-if=&quot;error&quot;&gt;failed to load&lt;/div&gt;</div>
<div class="line">    &lt;div v-if=&quot;!data&quot;&gt;loading...&lt;/div&gt;</div>
<div class="line">    &lt;div v-else&gt;hello {{ data.name }}&lt;/div&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">&lt;/template&gt;</div>
<div class="line"> </div>
<div class="line">&lt;script&gt;</div>
<div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  name: &#39;Profile&#39;,</div>
<div class="line"> </div>
<div class="line">  setup() {</div>
<div class="line">    const { data, error } = useSWRV(&#39;/api/user&#39;, fetcher)</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      data,</div>
<div class="line">      error,</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">}</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>In this example, the Vue Hook <code>useSWRV</code> accepts a <code>key</code> and a <code>fetcher</code> function. <code>key</code> is a unique identifier of the request, normally the URL of the API. And the fetcher accepts key as its parameter and returns the data asynchronously.</p>
<p><code>useSWRV</code> also returns 2 values: <code>data</code> and <code>error</code>. When the request (fetcher) is not yet finished, data will be <code>undefined</code>. And when we get a response, it sets <code>data</code> and <code>error</code> based on the result of fetcher and rerenders the component. This is because <code>data</code> and <code>error</code> are Vue <a href="https://vuejs.org/api/reactivity-core.html#ref">Refs</a>, and their values will be set by the fetcher response.</p>
<p>Note that fetcher can be any asynchronous function, so you can use your favorite data-fetching library to handle that part. When omitted, swrv falls back to the browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p>
<h2><a class="anchor" id="autotoc_md31787"></a>
Api</h2>
<div class="fragment"><div class="line">const { data, error, isValidating, mutate } = useSWRV(key, fetcher, options)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31788"></a>
Parameters</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Param   </th><th class="markdownTableHeadNone">Required   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>key</code>   </td><td class="markdownTableBodyNone">yes   </td><td class="markdownTableBodyNone">a unique key string for the request (or a reactive reference / watcher function / null) (advanced usage)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fetcher</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">a Promise returning function to fetch your data. If <code>null</code>, swrv will fetch from cache only and not revalidate. If omitted (i.e. <code>undefined</code>) then the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a> api will be used.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>options</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">an object of configuration options   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md31789"></a>
Return Values</h3>
<ul>
<li><code>data</code>: data for the given key resolved by fetcher (or undefined if not loaded)</li>
<li><code>error</code>: error thrown by fetcher (or undefined)</li>
<li><code>isValidating</code>: if there's a request or revalidation loading</li>
<li><code>mutate</code>: function to trigger the validation manually</li>
</ul>
<h3><a class="anchor" id="autotoc_md31790"></a>
Config options</h3>
<p>See <a href="https://github.com/Kong/swrv/blob/1587416e59dad12f9261e289b8cf63da81aa2dd4/src/use-swrv.ts#L43">Config Defaults</a></p>
<ul>
<li><code>refreshInterval = 0</code> - polling interval in milliseconds. 0 means this is disabled.</li>
<li><code>dedupingInterval = 2000</code> - dedupe requests with the same key in this time span</li>
<li><code>ttl = 0</code> - time to live of response data in cache. 0 mean it stays around forever.</li>
<li><code>shouldRetryOnError = true</code> - retry when fetcher has an error</li>
<li><code>errorRetryInterval = 5000</code> - error retry interval</li>
<li><code>errorRetryCount: 5</code> - max error retry count</li>
<li><code>revalidateOnFocus = true</code> - auto revalidate when window gets focused</li>
<li><code>revalidateDebounce = 0</code> - debounce in milliseconds for revalidation. Useful for when a component is serving from the cache immediately, but then un-mounts soon thereafter (e.g. a user clicking "next" in pagination quickly) to avoid unnecessary fetches.</li>
<li><code>cache</code> - caching instance to store response data in. See <a href="src/lib/cache.ts">src/lib/cache</a>, and <a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#cache">Cache</a> below.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31791"></a>
Prefetching</h2>
<p>Prefetching can be useful for when you anticipate user actions, like hovering over a link. SWRV exposes the <code>mutate</code> function so that results can be stored in the SWRV cache at a predetermined time.</p>
<div class="fragment"><div class="line">import { mutate } from &#39;swrv&#39;</div>
<div class="line"> </div>
<div class="line">function prefetch() {</div>
<div class="line">  mutate(</div>
<div class="line">    &#39;/api/data&#39;,</div>
<div class="line">    fetch(&#39;/api/data&#39;).then((res) =&gt; res.json())</div>
<div class="line">  )</div>
<div class="line">  // the second parameter is a Promise</div>
<div class="line">  // SWRV will use the result when it resolves</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31792"></a>
Dependent Fetching</h2>
<p>swrv also allows you to fetch data that depends on other data. It ensures the maximum possible parallelism (avoiding waterfalls), as well as serial fetching when a piece of dynamic data is required for the next data fetch to happen.</p>
<div class="fragment"><div class="line">&lt;template&gt;</div>
<div class="line">  &lt;p v-if=&quot;!projects&quot;&gt;loading...&lt;/p&gt;</div>
<div class="line">  &lt;p v-else&gt;You have {{ projects.length }} projects&lt;/p&gt;</div>
<div class="line">&lt;/template&gt;</div>
<div class="line"> </div>
<div class="line">&lt;script&gt;</div>
<div class="line">import { ref } from &#39;vue&#39;</div>
<div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  name: &#39;Profile&#39;,</div>
<div class="line"> </div>
<div class="line">  setup() {</div>
<div class="line">    const { data: user } = useSWRV(&#39;/api/user&#39;, fetch)</div>
<div class="line">    const { data: projects } = useSWRV(() =&gt; user.value &amp;&amp; &#39;/api/projects?uid=&#39; + user.value.id, fetch)</div>
<div class="line">    // if the return value of the cache key function is falsy, the fetcher</div>
<div class="line">    // will not trigger, but since `user` is inside the cache key function,</div>
<div class="line">    // it is being watched so when it is available, then the projects will</div>
<div class="line">    // be fetched.</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      user,</div>
<div class="line">      projects</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">}</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31793"></a>
Stale-if-error</h2>
<p>One of the benefits of a stale content caching strategy is that the cache can be served when requests fail.<code>swrv</code> uses a <a href="https://tools.ietf.org/html/rfc5861#section-4">stale-if-error</a> strategy and will maintain <code>data</code> in the cache even if a <code>useSWRV</code> fetch returns an <code>error</code>.</p>
<div class="fragment"><div class="line">&lt;template&gt;</div>
<div class="line">  &lt;div v-if=&quot;error&quot;&gt;failed to load&lt;/div&gt;</div>
<div class="line">  &lt;div v-if=&quot;data === undefined &amp;&amp; !error&quot;&gt;loading...&lt;/div&gt;</div>
<div class="line">  &lt;p v-if=&quot;data&quot;&gt;</div>
<div class="line">    hello {{ data.name }} of {{ data.birthplace }}. This content will continue</div>
<div class="line">    to appear even if future requests to {{ endpoint }} fail!</div>
<div class="line">  &lt;/p&gt;</div>
<div class="line">&lt;/template&gt;</div>
<div class="line"> </div>
<div class="line">&lt;script&gt;</div>
<div class="line">import { ref } from &#39;vue&#39;</div>
<div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  name: &#39;Profile&#39;,</div>
<div class="line"> </div>
<div class="line">  setup() {</div>
<div class="line">    const endpoint = ref(&#39;/api/user/Geralt&#39;)</div>
<div class="line">    const { data, error } = useSWRV(endpoint.value, fetch)</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      endpoint,</div>
<div class="line">      data,</div>
<div class="line">      error,</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">}</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31794"></a>
State Management</h2>
<h3><a class="anchor" id="autotoc_md31795"></a>
useSwrvState</h3>
<p>Sometimes you might want to know the exact state where swrv is during stale-while-revalidate lifecyle. This is helpful when representing the UI as a function of state. Here is one way to detect state using a user-land composable <code>useSwrvState</code> function:</p>
<div class="fragment"><div class="line">import { ref, watchEffect } from &#39;vue&#39;</div>
<div class="line"> </div>
<div class="line">const STATES = {</div>
<div class="line">  VALIDATING: &#39;VALIDATING&#39;,</div>
<div class="line">  PENDING: &#39;PENDING&#39;,</div>
<div class="line">  SUCCESS: &#39;SUCCESS&#39;,</div>
<div class="line">  ERROR: &#39;ERROR&#39;,</div>
<div class="line">  STALE_IF_ERROR: &#39;STALE_IF_ERROR&#39;,</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export default function(data, error, isValidating) {</div>
<div class="line">  const state = ref(&#39;idle&#39;)</div>
<div class="line">  watchEffect(() =&gt; {</div>
<div class="line">    if (data.value &amp;&amp; isValidating.value) {</div>
<div class="line">      state.value = STATES.VALIDATING</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    if (data.value &amp;&amp; error.value) {</div>
<div class="line">      state.value = STATES.STALE_IF_ERROR</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    if (data.value === undefined &amp;&amp; !error.value) {</div>
<div class="line">      state.value = STATES.PENDING</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    if (data.value &amp;&amp; !error.value) {</div>
<div class="line">      state.value = STATES.SUCCESS</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    if (data.value === undefined &amp;&amp; error) {</div>
<div class="line">      state.value = STATES.ERROR</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  return {</div>
<div class="line">    state,</div>
<div class="line">    STATES,</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And then in your template you can use it like so:</p>
<div class="fragment"><div class="line">&lt;template&gt;</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;div v-if=&quot;[STATES.ERROR, STATES.STALE_IF_ERROR].includes(state)&quot;&gt;</div>
<div class="line">      {{ error }}</div>
<div class="line">    &lt;/div&gt;</div>
<div class="line">    &lt;div v-if=&quot;[STATES.PENDING].includes(state)&quot;&gt;Loading...&lt;/div&gt;</div>
<div class="line">    &lt;div v-if=&quot;[STATES.VALIDATING].includes(state)&quot;&gt;</div>
<div class="line">      &lt;!-- serve stale content without &quot;loading&quot; --&gt;</div>
<div class="line">    &lt;/div&gt;</div>
<div class="line">    &lt;div</div>
<div class="line">      v-if=&quot;</div>
<div class="line">        [STATES.SUCCESS, STATES.VALIDATING, STATES.STALE_IF_ERROR].includes(</div>
<div class="line">          state</div>
<div class="line">        )</div>
<div class="line">      &quot;</div>
<div class="line">    &gt;</div>
<div class="line">      {{ data }}</div>
<div class="line">    &lt;/div&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">&lt;/template&gt;</div>
<div class="line"> </div>
<div class="line">&lt;script&gt;</div>
<div class="line">import { computed } from &#39;vue&#39;</div>
<div class="line">import useSwrvState from &#39;@/composables/useSwrvState&#39;</div>
<div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  name: &#39;Repo&#39;,</div>
<div class="line">  setup(props, { root }) {</div>
<div class="line">    const page = computed(() =&gt; root.$route.params.id)</div>
<div class="line">    const { data, error, isValidating } = useSWRV(</div>
<div class="line">      () =&gt; `/api/${root.$route.params.id}`,</div>
<div class="line">      fetcher</div>
<div class="line">    )</div>
<div class="line">    const { state, STATES } = useSwrvState(data, error, isValidating)</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      state,</div>
<div class="line">      STATES,</div>
<div class="line">      data,</div>
<div class="line">      error,</div>
<div class="line">      page,</div>
<div class="line">      isValidating,</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">}</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31796"></a>
Vuex</h3>
<p>Most of the features of swrv handle the complex logic / ceremony that you'd have to implement yourself inside a vuex store. All swrv instances use the same global cache, so if you are using swrv alongside vuex, you can use global watchers on resolved swrv returned refs. It is encouraged to wrap useSWRV in a custom composable function so that you can do application level side effects if desired (e.g. dispatch a vuex action when data changes to log events or perform some logic).</p>
<p>Vue 3 example:</p>
<div class="fragment"><div class="line">&lt;script&gt;</div>
<div class="line">import { defineComponent, ref, computed, watch } from &#39;vue&#39;</div>
<div class="line">import { useStore } from &#39;vuex&#39;</div>
<div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line">import { getAllTasks } from &#39;./api&#39;</div>
<div class="line"> </div>
<div class="line">export default defineComponent({</div>
<div class="line">  setup() {</div>
<div class="line">    const store = useStore()</div>
<div class="line"> </div>
<div class="line">    const tasks = computed({</div>
<div class="line">      get: () =&gt; store.getters.allTasks,</div>
<div class="line">      set: (tasks) =&gt; {</div>
<div class="line">        store.dispatch(&#39;setTaskList&#39;, tasks)</div>
<div class="line">      },</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    const addTasks = (newTasks) =&gt; store.dispatch(&#39;addTasks&#39;, { tasks: newTasks })</div>
<div class="line"> </div>
<div class="line">    const { data } = useSWRV(&#39;tasks&#39;, getAllTasks)</div>
<div class="line"> </div>
<div class="line">    // Using a watcher, you can update the store with any changes coming from swrv</div>
<div class="line">    watch(data, newTasks =&gt; {</div>
<div class="line">      store.dispatch(&#39;addTasks&#39;, { source: &#39;Todoist&#39;, tasks: newTasks })</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      tasks</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">})</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31797"></a>
Cache</h2>
<p>By default, a custom cache implementation is used to store fetcher response data cache, in-flight promise cache, and ref cache. Response data cache can be customized via the <code>config.cache</code> property. Built in cache adapters:</p>
<h3><a class="anchor" id="autotoc_md31798"></a>
localStorage</h3>
<p>A common usage case to have a better <em>offline</em> experience is to read from <code>localStorage</code>. Checkout the <a href="https://github.com/Kong/swrv/tree/master/examples/pwa">PWA example</a> for more inspiration.</p>
<div class="fragment"><div class="line">import useSWRV from &#39;swrv&#39;</div>
<div class="line">import LocalStorageCache from &#39;swrv/dist/cache/adapters/localStorage&#39;</div>
<div class="line"> </div>
<div class="line">function useTodos () {</div>
<div class="line">  const { data, error } = useSWRV(&#39;/todos&#39;, undefined, {</div>
<div class="line">    cache: new LocalStorageCache(&#39;swrv&#39;),</div>
<div class="line">    shouldRetryOnError: false</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  return {</div>
<div class="line">    data,</div>
<div class="line">    error</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31799"></a>
Serve from cache only</h3>
<p>To only retrieve a swrv cache response without revalidating, you can set the fetcher function to <code>null</code> from the useSWRV call. This can be useful when there is some higher level swrv composable that is always sending data to other instances, so you can assume that composables with a <code>null</code> fetcher will have data available. This <a href="https://github.com/Kong/swrv/issues/148">isn't very intuitive</a>, so will be looking for ways to improve this api in the future.</p>
<div class="fragment"><div class="line">// Component A</div>
<div class="line">const { data } = useSWRV(&#39;/api/config&#39;, fetcher)</div>
<div class="line"> </div>
<div class="line">// Component B, only retrieve from cache</div>
<div class="line">const { data } = useSWRV(&#39;/api/config&#39;, null)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31800"></a>
Error Handling</h2>
<p>Since <code>error</code> is returned as a Vue Ref, you can use watchers to handle any onError callback functionality. Check out <a href="https://github.com/Kong/swrv/blob/a063c4aa142a5a13dbd39496cefab7aef54e610c/tests/use-swrv.spec.tsx#L481">the test</a>.</p>
<div class="fragment"><div class="line">export default {</div>
<div class="line">  setup() {</div>
<div class="line">    const { data, error } = useSWRV(key, fetch)</div>
<div class="line"> </div>
<div class="line">    function handleError(error) {</div>
<div class="line">      console.error(error &amp;&amp; error.message)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    watch(error, handleError)</div>
<div class="line"> </div>
<div class="line">    return {</div>
<div class="line">      data,</div>
<div class="line">      error,</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31801"></a>
FAQ</h2>
<h3><a class="anchor" id="autotoc_md31802"></a>
How is swrv different from the <a href="https://github.com/zeit/swr">swr</a> react library</h3>
<h4><a class="anchor" id="autotoc_md31803"></a>
Vue and Reactivity</h4>
<p>The <code>swrv</code> library is meant to be used with the Vue Composition API (and eventually Vue 3) so it utilizes Vue's reactivity system to track dependencies and returns vue <code>Ref</code>'s as it's return values. This allows you to watch <code>data</code> or build your own computed props. For example, the key function is implemented as Vue <code>watch</code>er, so any changes to the dependencies in this function will trigger a revalidation in <code>swrv</code>.</p>
<h4><a class="anchor" id="autotoc_md31804"></a>
Features</h4>
<p>Features were built as needed for <code>swrv</code>, and while the initial development of <code>swrv</code> was mostly a port of swr, the feature sets are not 1-1, and are subject to diverge as they already have.</p>
<h3><a class="anchor" id="autotoc_md31805"></a>
Why does swrv make so many requests</h3>
<p>The idea behind stale-while-revalidate is that you always get fresh data eventually. You can disable some of the eager fetching such as <code>config.revalidateOnFocus</code>, but it is preferred to serve a fast response from cache while also revalidating so users are always getting the most up to date data.</p>
<h3><a class="anchor" id="autotoc_md31806"></a>
How can I refetch swrv data to update it</h3>
<p>Swrv fetcher functions can be triggered on-demand by using the <code>mutate</code> <a href="https://github.com/Kong/swrv/#return-values">return value</a>. This is useful when there is some event that needs to trigger a revalidation such a PATCH request that updates the initial GET request response data.</p>
<h2><a class="anchor" id="autotoc_md31807"></a>
Contributors ✨</h2>
<p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p>
<table class="doxtable">
<tr>
<td align="center"><a href="https://guuu.io/"><img src="https://avatars2.githubusercontent.com/u/5770711?v=4" alt="" width="100px;" class="inline"/><br  />
<sub><b>Darren Jennings</b></sub></a><br  />
<a href="https://github.com/Kong/swrv/commits?author=darrenjennings" title="Code">💻</a> <a href="https://github.com/Kong/swrv/commits?author=darrenjennings" title="Documentation">📖</a> </td><td align="center"><a href="https://atinux.com"><img src="https://avatars2.githubusercontent.com/u/904724?v=4" alt="" width="100px;" class="inline"/><br  />
<sub><b>Sébastien Chopin</b></sub></a><br  />
<a href="https://github.com/Kong/swrv/commits?author=Atinux" title="Code">💻</a> <a href="#ideas-Atinux" title="Ideas, Planning, &amp; Feedback">🤔</a> </td><td align="center"><a href="https://github.com/chuca"><img src="https://avatars0.githubusercontent.com/u/864496?v=4" alt="" width="100px;" class="inline"/><br  />
<sub><b>Fernando Machuca</b></sub></a><br  />
<a href="#design-chuca" title="Design">🎨</a> </td><td align="center"><a href="https://zeit.co"><img src="https://avatars0.githubusercontent.com/u/14985020?v=4" alt="" width="100px;" class="inline"/><br  />
<sub><b>ZEIT</b></sub></a><br  />
<a href="#ideas-zeit" title="Ideas, Planning, &amp; Feedback">🤔</a> </td><td align="center"><a href="https://www.adamdehaven.com"><img src="https://avatars.githubusercontent.com/u/2229946?v=4" alt="" width="100px;" class="inline"/><br  />
<sub><b>Adam DeHaven</b></sub></a><br  />
<a href="https://github.com/Kong/swrv/commits?author=adamdehaven" title="Code">💻</a> <a href="https://github.com/Kong/swrv/commits?author=adamdehaven" title="Documentation">📖</a> <a href="#maintenance-adamdehaven" title="Maintenance">🚧</a>  </td></tr>
</table>
<p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome! </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_3605d1a2ccf0461b8f53b44a5a7cafe5.html">swrv</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
