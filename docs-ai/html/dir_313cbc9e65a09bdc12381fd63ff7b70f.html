<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/@inquirer/core Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_313cbc9e65a09bdc12381fd63ff7b70f.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">core Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_cde51b48995328da4e17ff3246237fc4.html">node_modules</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>@inquirer/core</code> package is the library enabling the creation of Inquirer prompts.</p>
<p>It aims to implements a lightweight API similar to React hooks - but without JSX.</p>
<h1><a class="anchor" id="autotoc_md3722"></a>
Installation</h1>
<table class="doxtable">
<tr>
<th>npm </th><th>yarn  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line">npm install @inquirer/core</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<div class="fragment"><div class="line">yarn add @inquirer/core</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="autotoc_md3723"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md3724"></a>
Basic concept</h2>
<p>Visual terminal apps are at their core strings rendered onto the terminal.</p>
<p>The most basic prompt is a function returning a string that'll be rendered in the terminal. This function will run every time the prompt state change, and the new returned string will replace the previously rendered one. The prompt cursor appears after the string.</p>
<p>Wrapping the rendering function with <code>createPrompt()</code> will setup the rendering layer, inject the state management utilities, and wait until the <code>done</code> callback is called.</p>
<div class="fragment"><div class="line">import { createPrompt } from &#39;@inquirer/core&#39;;</div>
<div class="line"> </div>
<div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  // Implement logic</div>
<div class="line"> </div>
<div class="line">  return &#39;? My question&#39;;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// And it is then called as</div>
<div class="line">const answer = await input({</div>
<div class="line">  /* config */</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3725"></a>
Hooks</h2>
<p>State management and user interactions are handled through hooks. Hooks are common <a href="https://react.dev/reference/react/hooks">within the React ecosystem</a>, and Inquirer reimplement the common ones.</p>
<h3><a class="anchor" id="autotoc_md3726"></a>
State hook</h3>
<p>State lets a component “remember” information like user input. For example, an input prompt can use state to store the input value, while a list prompt can use state to track the cursor index.</p>
<p><code>useState</code> declares a state variable that you can update directly.</p>
<div class="fragment"><div class="line">import { createPrompt, useState } from &#39;@inquirer/core&#39;;</div>
<div class="line"> </div>
<div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  const [index, setIndex] = useState(0);</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3727"></a>
Keypress hook</h3>
<p>Almost all prompts need to react to user actions. In a terminal, this is done through typing.</p>
<p><code>useKeypress</code> allows you to react to keypress events, and access the prompt line.</p>
<div class="fragment"><div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  useKeypress((key) =&gt; {</div>
<div class="line">    if (key.name === &#39;enter&#39;) {</div>
<div class="line">      done(answer);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><p>Behind the scenes, Inquirer prompts are wrappers around <a href="https://nodejs.org/api/readline.html">readlines</a>. Aside the keypress event object, the hook also pass the active readline instance to the event handler.</p>
<div class="fragment"><div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  useKeypress((key, readline) =&gt; {</div>
<div class="line">    setValue(readline.line);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3728"></a>
Ref hook</h3>
<p>Refs let a prompt hold some information that isn’t used for rendering, like a class instance or a timeout ID. Unlike with state, updating a ref does not re-render your prompt. Refs are an “escape hatch” from the rendering paradigm.</p>
<p><code>useRef</code> declares a ref. You can hold any value in it, but most often it’s used to hold a timeout ID.</p>
<div class="fragment"><div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  const timeout = useRef(null);</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3729"></a>
Effect Hook</h3>
<p>Effects let a prompt connect to and synchronize with external systems. This includes dealing with network or animations.</p>
<p><code>useEffect</code> connects a component to an external system.</p>
<div class="fragment"><div class="line">const chat = createPrompt((config, done) =&gt; {</div>
<div class="line">  useEffect(() =&gt; {</div>
<div class="line">    const connection = createConnection(roomId);</div>
<div class="line">    connection.connect();</div>
<div class="line">    return () =&gt; connection.disconnect();</div>
<div class="line">  }, [roomId]);</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3730"></a>
Performance hook</h3>
<p>A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell Inquirer to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.</p>
<p><code>useMemo</code> lets you cache the result of an expensive calculation.</p>
<div class="fragment"><div class="line">const todoSelect = createPrompt((config, done) =&gt; {</div>
<div class="line">  const visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);</div>
<div class="line"> </div>
<div class="line">  // ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3731"></a>
Rendering hooks</h3>
<h4><a class="anchor" id="autotoc_md3732"></a>
Prefix / loading</h4>
<p>All default prompts, and most custom ones, uses a prefix at the beginning of the prompt line. This helps visually delineate different questions, and provides a convenient area to render a loading spinner.</p>
<p><code>usePrefix</code> is a built-in hook to do this.</p>
<div class="fragment"><div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  const prefix = usePrefix({ status });</div>
<div class="line"> </div>
<div class="line">  return `${prefix} My question`;</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md3733"></a>
Pagination</h4>
<p>When looping through a long list of options (like in the <code>select</code> prompt), paginating the results appearing on the screen at once can be necessary. The <code>usePagination</code> hook is the utility used within the <code>select</code> and <code>checkbox</code> prompts to cycle through the list of options.</p>
<p>Pagination works by taking in the list of options and returning a subset of the rendered items that fit within the page. The hook takes in a few options. It needs a list of options (<code>items</code>), and a <code>pageSize</code> which is the number of lines to be rendered. The <code>active</code> index is the index of the currently selected/selectable item. The <code>loop</code> option is a boolean that indicates if the list should loop around when reaching the end: this is the default behavior. The pagination hook renders items only as necessary, so it takes a function that can render an item at an index, including an <code>active</code> state, called <code>renderItem</code>.</p>
<div class="fragment"><div class="line">export default createPrompt((config, done) =&gt; {</div>
<div class="line">  const [active, setActive] = useState(0);</div>
<div class="line"> </div>
<div class="line">  const allChoices = config.choices.map((choice) =&gt; choice.name);</div>
<div class="line"> </div>
<div class="line">  const page = usePagination({</div>
<div class="line">    items: allChoices,</div>
<div class="line">    active: active,</div>
<div class="line">    renderItem: ({ item, index, isActive }) =&gt; `${isActive ? &quot;&gt;&quot; : &quot; &quot;}${index}. ${item.toString()}`</div>
<div class="line">    pageSize: config.pageSize,</div>
<div class="line">    loop: config.loop,</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  return `... ${page}`;</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3734"></a>
<code>createPrompt()</code> API</h2>
<p>As we saw earlier, the rendering function should return a string, and eventually call <code>done</code> to close the prompt and return the answer.</p>
<div class="fragment"><div class="line">const input = createPrompt((config, done) =&gt; {</div>
<div class="line">  const [value, setValue] = useState();</div>
<div class="line"> </div>
<div class="line">  useKeypress((key, readline) =&gt; {</div>
<div class="line">    if (key.name === &#39;enter&#39;) {</div>
<div class="line">      done(answer);</div>
<div class="line">    } else {</div>
<div class="line">      setValue(readline.line);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  return `? ${config.message} ${value}`;</div>
<div class="line">});</div>
</div><!-- fragment --><p>The rendering function can also return a tuple of 2 string (<code>[string, string]</code>.) The first string represents the prompt. The second one is content to render under the prompt, like an error message. The text input cursor will appear after the first string.</p>
<div class="fragment"><div class="line">const number = createPrompt((config, done) =&gt; {</div>
<div class="line">  // Add some logic here</div>
<div class="line"> </div>
<div class="line">  return [`? My question ${input}`, `! The input must be a number`];</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3735"></a>
Typescript</h3>
<p>If using typescript, <code>createPrompt</code> takes 2 generic arguments.</p>
<div class="fragment"><div class="line">// createPrompt&lt;Value, Config&gt;</div>
<div class="line">const input = createPrompt&lt;string, { message: string }&gt;(// ...</div>
</div><!-- fragment --><p>The first one is the type of the resolved value</p>
<div class="fragment"><div class="line">const answer: string = await input();</div>
</div><!-- fragment --><p>The second one is the type of the prompt config; in other words the interface the created prompt will provide to users.</p>
<div class="fragment"><div class="line">const answer = await input({</div>
<div class="line">  message: &#39;My question&#39;,</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3736"></a>
Key utilities</h2>
<p>Listening for keypress events inside an inquirer prompt is a very common pattern. To ease this, we export a few utility functions taking in the keypress event object and return a boolean:</p>
<ul>
<li><code>isEnterKey()</code></li>
<li><code>isBackspaceKey()</code></li>
<li><code>isSpaceKey()</code></li>
<li><code>isUpKey()</code> - Note: this utility will handle vim and emacs keybindings (up, <code>k</code>, and <code>ctrl+p</code>)</li>
<li><code>isDownKey()</code> - Note: this utility will handle vim and emacs keybindings (down, <code>j</code>, and <code>ctrl+n</code>)</li>
<li><code>isNumberKey()</code> one of 1, 2, 3, 4, 5, 6, 7, 8, 9, 0</li>
</ul>
<h2><a class="anchor" id="autotoc_md3737"></a>
Theming</h2>
<p>Theming utilities will allow you to expose customization of the prompt style. Inquirer also has a few standard theme values shared across all the official prompts.</p>
<p>To allow standard customization:</p>
<div class="fragment"><div class="line">import { createPrompt, usePrefix, makeTheme, type Theme } from &#39;@inquirer/core&#39;;</div>
<div class="line">import type { PartialDeep } from &#39;@inquirer/type&#39;;</div>
<div class="line"> </div>
<div class="line">type PromptConfig = {</div>
<div class="line">  theme?: PartialDeep&lt;Theme&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">export default createPrompt&lt;string, PromptConfig&gt;((config, done) =&gt; {</div>
<div class="line">  const theme = makeTheme(config.theme);</div>
<div class="line"> </div>
<div class="line">  const prefix = usePrefix({ status, theme });</div>
<div class="line"> </div>
<div class="line">  return `${prefix} ${theme.style.highlight(&#39;hello&#39;)}`;</div>
<div class="line">});</div>
</div><!-- fragment --><p>To setup a custom theme:</p>
<div class="fragment"><div class="line">import { createPrompt, makeTheme, type Theme } from &#39;@inquirer/core&#39;;</div>
<div class="line">import type { PartialDeep } from &#39;@inquirer/type&#39;;</div>
<div class="line"> </div>
<div class="line">type PromptTheme = {};</div>
<div class="line"> </div>
<div class="line">const promptTheme: PromptTheme = {</div>
<div class="line">  icon: &#39;!&#39;,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">type PromptConfig = {</div>
<div class="line">  theme?: PartialDeep&lt;Theme&lt;PromptTheme&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">export default createPrompt&lt;string, PromptConfig&gt;((config, done) =&gt; {</div>
<div class="line">  const theme = makeTheme(promptTheme, config.theme);</div>
<div class="line"> </div>
<div class="line">  const prefix = usePrefix({ status, theme });</div>
<div class="line"> </div>
<div class="line">  return `${prefix} ${theme.icon}`;</div>
<div class="line">});</div>
</div><!-- fragment --><p>The <a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/core/src/lib/theme.ts">default theme keys cover</a>:</p>
<div class="fragment"><div class="line">type DefaultTheme = {</div>
<div class="line">  prefix: string | { idle: string; done: string };</div>
<div class="line">  spinner: {</div>
<div class="line">    interval: number;</div>
<div class="line">    frames: string[];</div>
<div class="line">  };</div>
<div class="line">  style: {</div>
<div class="line">    answer: (text: string) =&gt; string;</div>
<div class="line">    message: (text: string, status: &#39;idle&#39; | &#39;done&#39; | &#39;loading&#39;) =&gt; string;</div>
<div class="line">    error: (text: string) =&gt; string;</div>
<div class="line">    defaultAnswer: (text: string) =&gt; string;</div>
<div class="line">    help: (text: string) =&gt; string;</div>
<div class="line">    highlight: (text: string) =&gt; string;</div>
<div class="line">    key: (text: string) =&gt; string;</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3738"></a>
Examples</h1>
<p>You can refer to any <code>@inquirer/prompts</code> prompts for real examples:</p>
<ul>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/confirm/src/index.ts">Confirm Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/input/src/index.ts">Input Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/password/src/index.ts">Password Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/editor/src/index.ts">Editor Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/select/src/index.ts">Select Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/checkbox/src/index.ts">Checkbox Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/rawlist/src/index.ts">Rawlist Prompt</a></li>
<li><a href="https://github.com/SBoudrias/Inquirer.js/blob/main/packages/expand/src/index.ts">Expand Prompt</a></li>
</ul>
<div class="fragment"><div class="line">import colors from &#39;yoctocolors&#39;;</div>
<div class="line">import {</div>
<div class="line">  createPrompt,</div>
<div class="line">  useState,</div>
<div class="line">  useKeypress,</div>
<div class="line">  isEnterKey,</div>
<div class="line">  usePrefix,</div>
<div class="line">  type Status,</div>
<div class="line">} from &#39;@inquirer/core&#39;;</div>
<div class="line"> </div>
<div class="line">const confirm = createPrompt&lt;boolean, { message: string; default?: boolean }&gt;(</div>
<div class="line">  (config, done) =&gt; {</div>
<div class="line">    const [status, setStatus] = useState&lt;Status&gt;(&#39;idle&#39;);</div>
<div class="line">    const [value, setValue] = useState(&#39;&#39;);</div>
<div class="line">    const prefix = usePrefix({});</div>
<div class="line"> </div>
<div class="line">    useKeypress((key, rl) =&gt; {</div>
<div class="line">      if (isEnterKey(key)) {</div>
<div class="line">        const answer = value ? /^y(es)?/i.test(value) : config.default !== false;</div>
<div class="line">        setValue(answer ? &#39;yes&#39; : &#39;no&#39;);</div>
<div class="line">        setStatus(&#39;done&#39;);</div>
<div class="line">        done(answer);</div>
<div class="line">      } else {</div>
<div class="line">        setValue(rl.line);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    let formattedValue = value;</div>
<div class="line">    let defaultValue = &#39;&#39;;</div>
<div class="line">    if (status === &#39;done&#39;) {</div>
<div class="line">      formattedValue = colors.cyan(value);</div>
<div class="line">    } else {</div>
<div class="line">      defaultValue = colors.dim(config.default === false ? &#39; (y/N)&#39; : &#39; (Y/n)&#39;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    const message = colors.bold(config.message);</div>
<div class="line">    return `${prefix} ${message}${defaultValue} ${formattedValue}`;</div>
<div class="line">  },</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> *  Which then can be used like this:</div>
<div class="line"> */</div>
<div class="line">const answer = await confirm({ message: &#39;Do you want to continue?&#39; });</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3739"></a>
License</h1>
<p>Copyright (c) 2023 Simon Boudrias (twitter: <a href="https://twitter.com/Vaxilart">@vaxilart</a>)<br  />
 Licensed under the MIT license. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_eb5c29b4a86e8c620f7f7bb2a33759ae.html">@inquirer</a></li><li class="navelem"><a class="el" href="dir_313cbc9e65a09bdc12381fd63ff7b70f.html">core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
