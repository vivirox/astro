<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/regexp-tree Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_b3e7c26d34651291291696f82097f19f.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">regexp-tree Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://travis-ci.org/DmitrySoshnikov/regexp-tree"><img src="https://travis-ci.org/DmitrySoshnikov/regexp-tree.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://badge.fury.io/js/regexp-tree"><img src="https://badge.fury.io/js/regexp-tree.svg" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/regexp-tree"><img src="https://img.shields.io/npm/dt/regexp-tree.svg" alt="npm downloads" style="pointer-events: none;" class="inline"/></a></p>
<p>Regular expressions processor in JavaScript</p>
<p>TL;DR: <b>RegExp Tree</b> is a <em>regular expressions processor</em>, which includes <em>parser</em>, <em>traversal</em>, <em>transformer</em>, <em>optimizer</em>, and <em>interpreter</em> APIs.</p>
<p>You can get an overview of the tool in <a href="https://medium.com/@DmitrySoshnikov/regexp-tree-a-regular-expressions-parser-with-a-simple-ast-format-bcd4d5580df6">this article</a>.</p>
<h2><a class="anchor" id="autotoc_md28568"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="/Users/vivi/astro/node_modules/flexsearch/README.md#installation">Installation</a></li>
<li>Development</li>
<li>Usage as a CLI</li>
<li>Usage from Node</li>
<li>Capturing locations</li>
<li>Parsing options</li>
<li>Using traversal API</li>
<li>Using transform API<ul>
<li>Transform plugins</li>
</ul>
</li>
<li>Using generator API</li>
<li>Using optimizer API<ul>
<li>Optimizer ESLint plugin</li>
</ul>
</li>
<li>Using compat-transpiler API<ul>
<li>Compat-transpiler Babel plugin</li>
</ul>
</li>
<li>RegExp extensions<ul>
<li>RegExp extensions Babel plugin</li>
</ul>
</li>
<li>Creating RegExp objects</li>
<li>Executing regexes</li>
<li>Using interpreter API<ul>
<li>Printing NFA/DFA tables</li>
</ul>
</li>
<li>AST nodes specification</li>
</ul>
<h2><a class="anchor" id="autotoc_md28569"></a>
Installation</h2>
<p>The parser can be installed as an <a href="https://www.npmjs.com/package/regexp-tree">npm module</a>:</p>
<div class="fragment"><div class="line">npm install -g regexp-tree</div>
</div><!-- fragment --><p>You can also <a href="https://astexplorer.net/#/gist/4ea2b52f0e546af6fb14f9b2f5671c1c/39b55944da3e5782396ffa1fea3ba68d126cd394">try it online</a> using <em>AST Explorer</em>.</p>
<h2><a class="anchor" id="autotoc_md28570"></a>
Development</h2>
<ol type="1">
<li>Fork <a href="https://github.com/DmitrySoshnikov/regexp-tree">https://github.com/DmitrySoshnikov/regexp-tree</a> repo</li>
<li>If there is an actual issue from the <a href="https://github.com/DmitrySoshnikov/regexp-tree/issues">issues</a> list you'd like to work on, feel free to assign it yourself, or comment on it to avoid collisions (open a new issue if needed)</li>
<li>Make your changes</li>
<li>Make sure <code>npm test</code> still passes (add new tests if needed)</li>
<li>Submit a PR</li>
</ol>
<p>The <em>regexp-tree</em> parser is implemented as an automatic LR parser using <a href="https://www.npmjs.com/package/syntax-cli">Syntax</a> tool. The parser module is generated from the <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/parser/regexp.bnf">regexp grammar</a>, which is based on the regular expressions grammar used in ECMAScript.</p>
<p>For development from the github repository, run <code>build</code> command to generate the parser module, and transpile JS code:</p>
<div class="fragment"><div class="line">git clone https://github.com/&lt;your-github-account&gt;/regexp-tree.git</div>
<div class="line">cd regexp-tree</div>
<div class="line">npm install</div>
<div class="line">npm run build</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: JS code transpilation is used to support older versions of Node. For faster development cycle you can use <code>npm run watch</code> command, which continuously transpiles JS code. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md28571"></a>
Usage as a CLI</h2>
<p><b>Note:</b> the CLI is exposed as its own <a href="https://www.npmjs.com/package/regexp-tree-cli">regexp-tree-cli</a> module.</p>
<p>Check the options available from CLI:</p>
<div class="fragment"><div class="line">regexp-tree-cli --help</div>
</div><!-- fragment --><div class="fragment"><div class="line">Usage: regexp-tree-cli [options]</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">   -e, --expression   A regular expression to be parsed</div>
<div class="line">   -l, --loc          Whether to capture AST node locations</div>
<div class="line">   -o, --optimize     Applies optimizer on the passed expression</div>
<div class="line">   -c, --compat       Applies compat-transpiler on the passed expression</div>
<div class="line">   -t, --table        Print NFA/DFA transition tables (nfa/dfa/all)</div>
</div><!-- fragment --><p>To parse a regular expression, pass <code>-e</code> option:</p>
<div class="fragment"><div class="line">regexp-tree-cli -e &#39;/a|b/i&#39;</div>
</div><!-- fragment --><p>Which produces an AST node corresponding to this regular expression:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;RegExp&#39;,</div>
<div class="line">  body: {</div>
<div class="line">    type: &#39;Disjunction&#39;,</div>
<div class="line">    left: {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    right: {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;b&#39;,</div>
<div class="line">      symbol: &#39;b&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 98</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  flags: &#39;i&#39;,</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: the format of a regexp is <code>/ Body / OptionalFlags</code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md28572"></a>
Usage from Node</h2>
<p>The parser can also be used as a Node module:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">console.log(regexpTree.parse(/a|b/i)); // RegExp AST</div>
</div><!-- fragment --><p>Note, <em>regexp-tree</em> supports parsing regexes from strings, and also from actual <code>RegExp</code> objects (in general &ndash; from any object which can be coerced to a string). If some feature is not implemented yet in an actual JavaScript RegExp, it should be passed as a string:</p>
<div class="fragment"><div class="line">// Pass an actual JS RegExp object.</div>
<div class="line">regexpTree.parse(/a|b/i);</div>
<div class="line"> </div>
<div class="line">// Pass a string, since `s` flag may not be supported in older versions.</div>
<div class="line">regexpTree.parse(&#39;/./s&#39;);</div>
</div><!-- fragment --><p>Also note, that in string-mode, escaping is done using two slashes <code>\\</code> per JavaScript:</p>
<div class="fragment"><div class="line">// As an actual regexp.</div>
<div class="line">regexpTree.parse(/\n/);</div>
<div class="line"> </div>
<div class="line">// As a string.</div>
<div class="line">regexpTree.parse(&#39;/\\n/&#39;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28573"></a>
Capturing locations</h2>
<p>For source code transformation tools it might be useful also to capture <em>locations</em> of the AST nodes. From the command line it's controlled via the <code>-l</code> option:</p>
<div class="fragment"><div class="line">regexp-tree-cli -e &#39;/ab/&#39; -l</div>
</div><!-- fragment --><p>This attaches <code>loc</code> object to each AST node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;RegExp&#39;,</div>
<div class="line">  body: {</div>
<div class="line">    type: &#39;Alternative&#39;,</div>
<div class="line">    expressions: [</div>
<div class="line">      {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;a&#39;,</div>
<div class="line">        symbol: &#39;a&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 97,</div>
<div class="line">        loc: {</div>
<div class="line">          start: {</div>
<div class="line">            line: 1,</div>
<div class="line">            column: 1,</div>
<div class="line">            offset: 1,</div>
<div class="line">          },</div>
<div class="line">          end: {</div>
<div class="line">            line: 1,</div>
<div class="line">            column: 2,</div>
<div class="line">            offset: 2,</div>
<div class="line">          },</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;b&#39;,</div>
<div class="line">        symbol: &#39;b&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 98,</div>
<div class="line">        loc: {</div>
<div class="line">          start: {</div>
<div class="line">            line: 1,</div>
<div class="line">            column: 2,</div>
<div class="line">            offset: 2,</div>
<div class="line">          },</div>
<div class="line">          end: {</div>
<div class="line">            line: 1,</div>
<div class="line">            column: 3,</div>
<div class="line">            offset: 3,</div>
<div class="line">          },</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    ],</div>
<div class="line">    loc: {</div>
<div class="line">      start: {</div>
<div class="line">        line: 1,</div>
<div class="line">        column: 1,</div>
<div class="line">        offset: 1,</div>
<div class="line">      },</div>
<div class="line">      end: {</div>
<div class="line">        line: 1,</div>
<div class="line">        column: 3,</div>
<div class="line">        offset: 3,</div>
<div class="line">      },</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  flags: &#39;&#39;,</div>
<div class="line">  loc: {</div>
<div class="line">    start: {</div>
<div class="line">      line: 1,</div>
<div class="line">      column: 0,</div>
<div class="line">      offset: 0,</div>
<div class="line">    },</div>
<div class="line">    end: {</div>
<div class="line">      line: 1,</div>
<div class="line">      column: 4,</div>
<div class="line">      offset: 4,</div>
<div class="line">    },</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>From Node it's controlled via <code>setOptions</code> method exposed on the parser:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const parsed = regexpTree</div>
<div class="line">  .parser</div>
<div class="line">  .setOptions({captureLocations: true})</div>
<div class="line">  .parse(/a|b/);</div>
</div><!-- fragment --><p>The <code>setOptions</code> method sets global options, which are preserved between calls. It is also possible to provide options per a single <code>parse</code> call, which might be more preferred:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const parsed = regexpTree.parse(/a|b/, {</div>
<div class="line">  captureLocations: true,</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28574"></a>
Parsing options</h2>
<p>The parser supports several options which can be set globally via the <code>setOptions</code> method on the parser, or by passing them with each <code>parse</code> method invocation.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const parsed = regexpTree.parse(/a|b/, {</div>
<div class="line">  allowGroupNameDuplicates: true,</div>
<div class="line">});</div>
</div><!-- fragment --><p>The following options are supported:</p>
<ul>
<li><code>captureLocations: boolean</code> &ndash; whether to capture AST node locations (<code>false</code> by default)</li>
<li><code>allowGroupNameDuplicates: boolean</code> &ndash; whether to skip duplicates check of the named capturing groups</li>
</ul>
<p>Set <code>allowGroupNameDuplicates</code> would make the following expression possible:</p>
<div class="fragment"><div class="line">/</div>
<div class="line">  # YYY-MM-DD date format:</div>
<div class="line"> </div>
<div class="line">  (?&lt;year&gt;  \d{4}) -</div>
<div class="line">  (?&lt;month&gt; \d{2}) -</div>
<div class="line">  (?&lt;day&gt;   \d{2})</div>
<div class="line"> </div>
<div class="line">  |</div>
<div class="line"> </div>
<div class="line">  # DD.MM.YYY date format</div>
<div class="line"> </div>
<div class="line">  (?&lt;day&gt;   \d{2}) .</div>
<div class="line">  (?&lt;month&gt; \d{2}) .</div>
<div class="line">  (?&lt;year&gt;  \d{4})</div>
<div class="line"> </div>
<div class="line">/x</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28575"></a>
Using traversal API</h2>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/traverse">traverse</a> module allows handling needed AST nodes using the <em>visitor</em> pattern. In Node the module is exposed as the <code>regexpTree.traverse</code> method. Handlers receive an instance of the <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class">NodePath</a> class, which encapsulates <code>node</code> itself, its <code>parent</code> node, <code>property</code>, and <code>index</code> (in case the node is part of a collection).</p>
<p>Visiting a node follows this algorithm:</p><ul>
<li>call <code>pre</code> handler.</li>
<li>recurse into node's children.</li>
<li>call <code>post</code> handler.</li>
</ul>
<p>For each node type of interest, you can provide either:</p><ul>
<li>a function (<code>pre</code>).</li>
<li>an object with members <code>pre</code> and <code>post</code>.</li>
</ul>
<p>You can also provide a <code>*</code> handler which will be executed on every node.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">// Get AST.</div>
<div class="line">const ast = regexpTree.parse(&#39;/[a-z]{1,}/&#39;);</div>
<div class="line"> </div>
<div class="line">// Traverse AST nodes.</div>
<div class="line">regexpTree.traverse(ast, {</div>
<div class="line"> </div>
<div class="line">  // Visit every node before any type-specific handlers.</div>
<div class="line">  &#39;*&#39;: function({node}) {</div>
<div class="line">    ...</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  // Handle &quot;Quantifier&quot; node type.</div>
<div class="line">  Quantifier({node}) {</div>
<div class="line">    ...</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  // Handle &quot;Char&quot; node type, before and after.</div>
<div class="line">  Char: {</div>
<div class="line">    pre({node}) {</div>
<div class="line">      ...</div>
<div class="line">    },</div>
<div class="line">    post({node}) {</div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Generate the regexp.</div>
<div class="line">const re = regexpTree.generate(ast);</div>
<div class="line"> </div>
<div class="line">console.log(re); // &#39;/[a-z]+/&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28576"></a>
Using transform API</h2>
<blockquote class="doxtable">
<p>NOTE: you can play with transformation APIs, and write actual transforms for quick tests in AST Explorer. See <a href="http://astexplorer.net/#/gist/d293d22742b42cd1f7ee7b7e5dc6f697/39b0aabc42fb6fb106b9e368341d3300098f08c0">this example</a>. </p>
</blockquote>
<p>While traverse module provides basic traversal API, which can be used for any purposes of AST handling, <em>transform</em> module focuses mainly on <em>transformation</em> of regular expressions.</p>
<p>It accepts a regular expressions in different formats (string, an actual <code>RegExp</code> object, or an AST), applies a set of transformations, and retuns an instance of <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/transform/README.md#transformresult">TransformResult</a>. Handles receive as a parameter the same <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class">NodePath</a> object used in traverse.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">// Handle nodes.</div>
<div class="line">const re = regexpTree.transform(&#39;/[a-z]{1,}/i&#39;, {</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Handle &quot;Quantifier&quot; node type,</div>
<div class="line">   * transforming `{1,}` quantifier to `+`.</div>
<div class="line">   */</div>
<div class="line">  Quantifier(path) {</div>
<div class="line">    const {node} = path;</div>
<div class="line"> </div>
<div class="line">    // {1,} -&gt; +</div>
<div class="line">    if (</div>
<div class="line">      node.kind === &#39;Range&#39; &amp;&amp;</div>
<div class="line">      node.from === 1 &amp;&amp;</div>
<div class="line">      !node.to</div>
<div class="line">    ) {</div>
<div class="line">      path.replace({</div>
<div class="line">        type: &#39;Quantifier&#39;,</div>
<div class="line">        kind: &#39;+&#39;,</div>
<div class="line">        greedy: node.greedy,</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">console.log(re.toString()); // &#39;/[a-z]+/i&#39;</div>
<div class="line">console.log(re.toRegExp()); // /[a-z]+/i</div>
<div class="line">console.log(re.getAST()); // AST for /[a-z]+/i</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28577"></a>
Transform plugins</h3>
<p>A <em>transformation plugin</em> is a module which exports a <em>transformation handler</em>. We have seen above how we can pass a handler object directly to the <code>regexpTree.transform</code> method, here we extract it into a separate module, so it can be implemented and shared independently:</p>
<p>Example of a plugin:</p>
<div class="fragment"><div class="line">// file: ./regexp-tree-a-to-b-transform.js</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This plugin replaces chars &#39;a&#39; with chars &#39;b&#39;.</div>
<div class="line"> */</div>
<div class="line">module.exports = {</div>
<div class="line">  Char({node}) {</div>
<div class="line">    if (node.kind === &#39;simple&#39; &amp;&amp; node.value === &#39;a&#39;) {</div>
<div class="line">      node.value = &#39;b&#39;;</div>
<div class="line">      node.symbol = &#39;b&#39;;</div>
<div class="line">      node.codePoint = 98;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><p>Once we have this plugin ready, we can require it, and pass to the <code>transform</code> function:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line">const plugin = require(&#39;./regexp-tree-a-to-b-transform&#39;);</div>
<div class="line"> </div>
<div class="line">const re = regexpTree.transform(/(a|c)a+[a-z]/, plugin);</div>
<div class="line"> </div>
<div class="line">console.log(re.toRegExp()); // /(b|c)b+[b-z]/</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: we can also pass a <em>list of plugins</em> to the <code>regexpTree.transform</code>. In this case the plugins are applied in one pass in order. Another approach is to run several sequential calls to <code>transform</code>, setting up a pipeline, when a transformed AST is passed further to another plugin, etc. </p>
</blockquote>
<p>You can see other examples of transform plugins in the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer/transforms">optimizer/transforms</a> or in the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler/transforms">compat-transpiler/transforms</a> directories.</p>
<h2><a class="anchor" id="autotoc_md28578"></a>
Using generator API</h2>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/generator">generator</a> module generates regular expressions from corresponding AST nodes. In Node the module is exposed as <code>regexpTree.generate</code> method.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const re = regexpTree.generate({</div>
<div class="line">  type: &#39;RegExp&#39;,</div>
<div class="line">  body: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  flags: &#39;i&#39;,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">console.log(re); // &#39;/a/i&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28579"></a>
Using optimizer API</h2>
<p><a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">Optimizer</a> transforms your regexp into an <em>optimized</em> version, replacing some sub-expressions with their idiomatic patterns. This might be good for different kinds of minifiers, as well as for regexp machines.</p>
<blockquote class="doxtable">
<p>NOTE: the Optimizer is implemented as a set of <em>regexp-tree</em> plugins. </p>
</blockquote>
<p>Example:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const originalRe = /[a-zA-Z_0-9][A-Z_\da-z]*\e{1,}/;</div>
<div class="line"> </div>
<div class="line">const optimizedRe = regexpTree</div>
<div class="line">  .optimize(originalRe)</div>
<div class="line">  .toRegExp();</div>
<div class="line"> </div>
<div class="line">console.log(optimizedRe); // /\w+e+/</div>
</div><!-- fragment --><p>From CLI the optimizer is available via <code>--optimize</code> (<code>-o</code>) option:</p>
<div class="fragment"><div class="line">regexp-tree-cli -e &#39;/[a-zA-Z_0-9][A-Z_\da-z]*\e{1,}/&#39; -o</div>
</div><!-- fragment --><p>Result:</p>
<div class="fragment"><div class="line">Optimized: /\w+e+/</div>
</div><!-- fragment --><p>See the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">optimizer README</a> for more details.</p>
<h3><a class="anchor" id="autotoc_md28580"></a>
Optimizer ESLint plugin</h3>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">optimizer</a> module is also available as an <em>ESLint plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/eslint-plugin-optimize-regex">eslint-plugin-optimize-regex</a>.</p>
<h2><a class="anchor" id="autotoc_md28581"></a>
Using compat-transpiler API</h2>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler">compat-transpiler</a> module translates your regexp in new format or in new syntax, into an equivalent regexp in a legacy representation, so it can be used in engines which don't yet implement the new syntax.</p>
<blockquote class="doxtable">
<p>NOTE: the compat-transpiler is implemented as a set of <em>regexp-tree</em> plugins. </p>
</blockquote>
<p>Example, "dotAll" <code>s</code> flag:</p>
<div class="fragment"><div class="line">/./s</div>
</div><!-- fragment --><p>Is translated into:</p>
<div class="fragment"><div class="line">/[\0-\uFFFF]/</div>
</div><!-- fragment --><p>Or named capturing groups:</p>
<div class="fragment"><div class="line">/(?&lt;value&gt;a)\k&lt;value&gt;\1/</div>
</div><!-- fragment --><p>Becomes:</p>
<div class="fragment"><div class="line">/(a)\1\1/</div>
</div><!-- fragment --><p>To use the API from Node:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">// Using new syntax.</div>
<div class="line">const originalRe = &#39;/(?&lt;all&gt;.)\\k&lt;all&gt;/s&#39;;</div>
<div class="line"> </div>
<div class="line">// For legacy engines.</div>
<div class="line">const compatTranspiledRe = regexpTree</div>
<div class="line">  .compatTranspile(originalRe)</div>
<div class="line">  .toRegExp();</div>
<div class="line"> </div>
<div class="line">console.log(compatTranspiledRe); // /([\0-\uFFFF])\1/</div>
</div><!-- fragment --><p>From CLI the compat-transpiler is available via <code>--compat</code> (<code>-c</code>) option:</p>
<div class="fragment"><div class="line">regexp-tree-cli -e &#39;/(?&lt;all&gt;.)\k&lt;all&gt;/s&#39; -c</div>
</div><!-- fragment --><p>Result:</p>
<div class="fragment"><div class="line">Compat: /([\0-\uFFFF])\1/</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28582"></a>
Compat-transpiler Babel plugin</h3>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler">compat-transpiler</a> module is also available as a <em>Babel plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/babel-plugin-transform-modern-regexp">babel-plugin-transform-modern-regexp</a>.</p>
<p>Note, the plugin also includes extended regexp features.</p>
<h2><a class="anchor" id="autotoc_md28583"></a>
RegExp extensions</h2>
<p>Some of the <em>non-standard</em> feature are also supported by <em>regexp-tree</em>.</p>
<blockquote class="doxtable">
<p>NOTE: <em>"non-standard"</em> means specifically ECMAScript standard, since in other regexp egnines, e.g. PCRE, Python, etc. these features are standard. </p>
</blockquote>
<p>One of such features is the <code>x</code> flag, which enables <em>extended</em> mode of regular expressions. In this mode most of whitespaces are ignored, and expressions can use #-comments.</p>
<p>Example:</p>
<div class="fragment"><div class="line">/</div>
<div class="line">  # A regular expression for date.</div>
<div class="line"> </div>
<div class="line">  (?&lt;year&gt;\d{4})-    # year part of a date</div>
<div class="line">  (?&lt;month&gt;\d{2})-   # month part of a date</div>
<div class="line">  (?&lt;day&gt;\d{2})      # day part of a date</div>
<div class="line"> </div>
<div class="line">/x</div>
</div><!-- fragment --><p>This is normally parsed by the <em>regexp-tree</em> parser, and compat-transpiler has full support for it; it's translated into:</p>
<div class="fragment"><div class="line">/(\d{4})-(\d{2})-(\d{2})/</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28584"></a>
RegExp extensions Babel plugin</h3>
<p>The regexp extensions are also available as a <em>Babel plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/babel-plugin-transform-modern-regexp">babel-plugin-transform-modern-regexp</a>.</p>
<p>Note, the plugin also includes compat-transpiler features.</p>
<h2><a class="anchor" id="autotoc_md28585"></a>
Creating RegExp objects</h2>
<p>To create an actual <code>RegExp</code> JavaScript object, we can use <code>regexpTree.toRegExp</code> method:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const re = regexpTree.toRegExp(&#39;/[a-z]/i&#39;);</div>
<div class="line"> </div>
<div class="line">console.log(</div>
<div class="line">  re.test(&#39;a&#39;), // true</div>
<div class="line">  re.test(&#39;Z&#39;), // true</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28586"></a>
Executing regexes</h2>
<p>It is also possible to execute regular expressions using <code>exec</code> API method, which has support for new syntax, and features, such as named capturing group, etc:</p>
<div class="fragment"><div class="line">const regexpTree = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const re = `/</div>
<div class="line"> </div>
<div class="line">  # A regular expression for date.</div>
<div class="line"> </div>
<div class="line">  (?&lt;year&gt;\\d{4})-    # year part of a date</div>
<div class="line">  (?&lt;month&gt;\\d{2})-   # month part of a date</div>
<div class="line">  (?&lt;day&gt;\\d{2})      # day part of a date</div>
<div class="line"> </div>
<div class="line">/x`;</div>
<div class="line"> </div>
<div class="line">const string = &#39;2017-04-14&#39;;</div>
<div class="line"> </div>
<div class="line">const result = regexpTree.exec(re, string);</div>
<div class="line"> </div>
<div class="line">console.log(result.groups); // {year: &#39;2017&#39;, month: &#39;04&#39;, day: &#39;14&#39;}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28587"></a>
Using interpreter API</h2>
<blockquote class="doxtable">
<p>NOTE: you can read more about implementation details of the interpreter in <a href="https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-1-regular-grammars-d4986b585d7e">this series of articles</a>. </p>
</blockquote>
<p>In addition to executing regular expressions using JavaScript built-in RegExp engine, RegExp Tree also implements own <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/interpreter/finite-automaton">interpreter</a> based on classic NFA/DFA finite automaton engine.</p>
<p>Currently it aims educational purposes &ndash; to trace the regexp matching process, transitioning in NFA/DFA states. It also allows building state transitioning table, which can be used for custom implementation. In API the module is exposed as <code>fa</code> (finite-automaton) object.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const {fa} = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const re = /ab|c*/;</div>
<div class="line"> </div>
<div class="line">console.log(fa.test(re, &#39;ab&#39;)); // true</div>
<div class="line">console.log(fa.test(re, &#39;&#39;)); // true</div>
<div class="line">console.log(fa.test(re, &#39;c&#39;)); // true</div>
<div class="line"> </div>
<div class="line">// NFA, and its transition table.</div>
<div class="line">const nfa = fa.toNFA(re);</div>
<div class="line">console.log(nfa.getTransitionTable());</div>
<div class="line"> </div>
<div class="line">// DFA, and its transition table.</div>
<div class="line">const dfa = fa.toDFA(re);</div>
<div class="line">console.log(dfa.getTransitionTable());</div>
</div><!-- fragment --><p>For more granular work with NFA and DFA, <code>fa</code> module also exposes convenient builders, so you can build NFA fragments directly:</p>
<div class="fragment"><div class="line">const {fa} = require(&#39;regexp-tree&#39;);</div>
<div class="line"> </div>
<div class="line">const {</div>
<div class="line">  alt,</div>
<div class="line">  char,</div>
<div class="line">  or,</div>
<div class="line">  rep,</div>
<div class="line">} = fa.builders;</div>
<div class="line"> </div>
<div class="line">// ab|c*</div>
<div class="line">const re = or(</div>
<div class="line">  alt(char(&#39;a&#39;), char(&#39;b&#39;)),</div>
<div class="line">  rep(char(&#39;c&#39;))</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">console.log(re.matches(&#39;ab&#39;)); // true</div>
<div class="line">console.log(re.matches(&#39;&#39;)); // true</div>
<div class="line">console.log(re.matches(&#39;c&#39;)); // true</div>
<div class="line"> </div>
<div class="line">// Build DFA from NFA</div>
<div class="line">const {DFA} = fa;</div>
<div class="line"> </div>
<div class="line">const reDFA = new DFA(re);</div>
<div class="line"> </div>
<div class="line">console.log(reDFA.matches(&#39;ab&#39;)); // true</div>
<div class="line">console.log(reDFA.matches(&#39;&#39;)); // true</div>
<div class="line">console.log(reDFA.matches(&#39;c&#39;)); // true</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28588"></a>
Printing NFA/DFA tables</h3>
<p>The <code>--table</code> option allows displaying NFA/DFA transition tables. RegExp Tree also applies <em>DFA minimization</em> (using <em>N-equivalence</em> algorithm), and produces the minimal transition table as its final result.</p>
<p>In the example below for the <code>/a|b|c/</code> regexp, we first obtain the NFA transition table, which is further converted to the original DFA transition table (down from the 10 non-deterministic states to 4 deterministic states), and eventually minimized to the final DFA table (from 4 to only 2 states).</p>
<div class="fragment"><div class="line">./bin/regexp-tree-cli -e &#39;/a|b|c/&#39; --table all</div>
</div><!-- fragment --><p>Result:</p>
<div class="fragment"><div class="line">&gt; - starting</div>
<div class="line">✓ - accepting</div>
<div class="line"> </div>
<div class="line">NFA transition table:</div>
<div class="line"> </div>
<div class="line">┌─────┬───┬───┬────┬─────────────┐</div>
<div class="line">│     │ a │ b │ c  │ ε*          │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 1 &gt; │   │   │    │ {1,2,3,7,9} │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 2   │   │   │    │ {2,3,7}     │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 3   │ 4 │   │    │ 3           │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 4   │   │   │    │ {4,5,6}     │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 5   │   │   │    │ {5,6}       │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 6 ✓ │   │   │    │ 6           │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 7   │   │ 8 │    │ 7           │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 8   │   │   │    │ {8,5,6}     │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 9   │   │   │ 10 │ 9           │</div>
<div class="line">├─────┼───┼───┼────┼─────────────┤</div>
<div class="line">│ 10  │   │   │    │ {10,6}      │</div>
<div class="line">└─────┴───┴───┴────┴─────────────┘</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">DFA: Original transition table:</div>
<div class="line"> </div>
<div class="line">┌─────┬───┬───┬───┐</div>
<div class="line">│     │ a │ b │ c │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 1 &gt; │ 4 │ 3 │ 2 │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 2 ✓ │   │   │   │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 3 ✓ │   │   │   │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 4 ✓ │   │   │   │</div>
<div class="line">└─────┴───┴───┴───┘</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">DFA: Minimized transition table:</div>
<div class="line"> </div>
<div class="line">┌─────┬───┬───┬───┐</div>
<div class="line">│     │ a │ b │ c │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 1 &gt; │ 2 │ 2 │ 2 │</div>
<div class="line">├─────┼───┼───┼───┤</div>
<div class="line">│ 2 ✓ │   │   │   │</div>
<div class="line">└─────┴───┴───┴───┘</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28589"></a>
AST nodes specification</h2>
<p>Below are the AST node types for different regular expressions patterns:</p>
<ul>
<li>Char<ul>
<li>Simple char</li>
<li>Escaped char</li>
<li>Meta char</li>
<li>Control char</li>
<li>Hex char-code</li>
<li>Decimal char-code</li>
<li>Octal char-code</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/@shikijs/engine-javascript/node_modules/oniguruma-to-es/README.md#unicode">Unicode</a></li>
</ul>
</li>
<li>Character class<ul>
<li>Positive character class</li>
<li>Negative character class</li>
<li>Character class ranges</li>
</ul>
</li>
<li>Unicode properties</li>
<li>Alternative</li>
<li>Disjunction</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/d3-array/README.md#groups">Groups</a><ul>
<li>Capturing group</li>
<li>Named capturing group</li>
<li>Non-capturing group</li>
<li>Backreferences</li>
</ul>
</li>
<li>Quantifiers<ul>
<li>? zero-or-one</li>
<li>* zero-or-more</li>
<li>+ one-or-more</li>
<li>Range-based quantifiers<ul>
<li>Exact number of matches</li>
<li>Open range</li>
<li>Closed range</li>
</ul>
</li>
<li>Non-greedy</li>
</ul>
</li>
<li>Assertions<ul>
<li>^ begin marker</li>
<li>$ end marker</li>
<li>Boundary assertions</li>
<li>Lookahead assertions<ul>
<li>Positive lookahead assertion</li>
<li>Negative lookahead assertion</li>
</ul>
</li>
<li>Lookbehind assertions<ul>
<li>Positive lookbehind assertion</li>
<li>Negative lookbehind assertion</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md28590"></a>
Char</h3>
<p>A basic building block, single character. Can be <em>escaped</em>, and be of different <em>kinds</em>.</p>
<h4><a class="anchor" id="autotoc_md28591"></a>
Simple char</h4>
<p>Basic <em>non-escaped</em> char in a regexp:</p>
<div class="fragment"><div class="line">z</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;z&#39;,</div>
<div class="line">  symbol: &#39;z&#39;,</div>
<div class="line">  kind: &#39;simple&#39;,</div>
<div class="line">  codePoint: 122</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: to test this from CLI, the char should be in an actual regexp &ndash; <code>/z/</code>. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md28592"></a>
Escaped char</h4>
<div class="fragment"><div class="line">\z</div>
</div><!-- fragment --><p>The same value, <code>escaped</code> flag is added:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;z&#39;,</div>
<div class="line">  symbol: &#39;z&#39;,</div>
<div class="line">  kind: &#39;simple&#39;,</div>
<div class="line">  codePoint: 122,</div>
<div class="line">  escaped: true</div>
<div class="line">}</div>
</div><!-- fragment --><p>Escaping is mostly used with meta symbols:</p>
<div class="fragment"><div class="line">// Syntax error</div>
<div class="line">*</div>
</div><!-- fragment --><div class="fragment"><div class="line">\*</div>
</div><!-- fragment --><p>OK, node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;*&#39;,</div>
<div class="line">  symbol: &#39;*&#39;,</div>
<div class="line">  kind: &#39;simple&#39;,</div>
<div class="line">  codePoint: 42,</div>
<div class="line">  escaped: true</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28593"></a>
Meta char</h4>
<p>A <em>meta character</em> should not be confused with an escaped char.</p>
<p>Example:</p>
<div class="fragment"><div class="line">\n</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\n&#39;,</div>
<div class="line">  symbol: &#39;\n&#39;,</div>
<div class="line">  kind: &#39;meta&#39;,</div>
<div class="line">  codePoint: 10</div>
<div class="line">}</div>
</div><!-- fragment --><p>Among other meta character are: <code>.</code>, <code>\f</code>, <code>\r</code>, <code>\n</code>, <code>\t</code>, <code>\v</code>, <code>\0</code>, <code>[\b]</code> (backspace char), <code>\s</code>, <code>\S</code>, <code>\w</code>, <code>\W</code>, <code>\d</code>, <code>\D</code>.</p>
<blockquote class="doxtable">
<p>NOTE: Meta characters representing ranges (like <code>.</code>, <code>\s</code>, etc.) have <code>undefined</code> value for <code>symbol</code> and <code>NaN</code> for <code>codePoint</code>. </p>
</blockquote>
<blockquote class="doxtable">
<p>NOTE: <code>\b</code> and <code>\B</code> are parsed as <code>Assertion</code> node type, not <code>Char</code>. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md28594"></a>
Control char</h4>
<p>A char preceded with <code>\c</code>, e.g. <code>\cx</code>, which stands for <code>CTRL+x</code>:</p>
<div class="fragment"><div class="line">\cx</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\cx&#39;,</div>
<div class="line">  symbol: undefined,</div>
<div class="line">  kind: &#39;control&#39;,</div>
<div class="line">  codePoint: NaN</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28595"></a>
HEX char-code</h4>
<p>A char preceded with <code>\x</code>, followed by a HEX-code, e.g. <code>\x3B</code> (symbol <code>;</code>):</p>
<div class="fragment"><div class="line">\x3B</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\x3B&#39;,</div>
<div class="line">  symbol: &#39;;&#39;,</div>
<div class="line">  kind: &#39;hex&#39;,</div>
<div class="line">  codePoint: 59</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28596"></a>
Decimal char-code</h4>
<p>Char-code:</p>
<div class="fragment"><div class="line">\42</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\42&#39;,</div>
<div class="line">  symbol: &#39;*&#39;,</div>
<div class="line">  kind: &#39;decimal&#39;,</div>
<div class="line">  codePoint: 42</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28597"></a>
Octal char-code</h4>
<p>Char-code started with <code>\0</code>, followed by an octal number:</p>
<div class="fragment"><div class="line">\073</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\073&#39;,</div>
<div class="line">  symbol: &#39;;&#39;,</div>
<div class="line">  kind: &#39;oct&#39;,</div>
<div class="line">  codePoint: 59</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28598"></a>
Unicode</h4>
<p>Unicode char started with <code>\u</code>, followed by a hex number:</p>
<div class="fragment"><div class="line">\u003B</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\u003B&#39;,</div>
<div class="line">  symbol: &#39;;&#39;,</div>
<div class="line">  kind: &#39;unicode&#39;,</div>
<div class="line">  codePoint: 59</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using the <code>u</code> flag, unicode chars can also be represented using <code>\u</code> followed by a hex number between curly braces:</p>
<div class="fragment"><div class="line">\u{1F680}</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\u{1F680}&#39;,</div>
<div class="line">  symbol: &#39;🚀&#39;,</div>
<div class="line">  kind: &#39;unicode&#39;,</div>
<div class="line">  codePoint: 128640</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using the <code>u</code> flag, unicode chars can also be represented using a surrogate pair:</p>
<div class="fragment"><div class="line">\ud83d\ude80</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Char&#39;,</div>
<div class="line">  value: &#39;\\ud83d\\ude80&#39;,</div>
<div class="line">  symbol: &#39;🚀&#39;,</div>
<div class="line">  kind: &#39;unicode&#39;,</div>
<div class="line">  codePoint: 128640,</div>
<div class="line">  isSurrogatePair: true</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28599"></a>
Character class</h3>
<p>Character classes define a <em>set</em> of characters. A set may include as simple characters, as well as <em>character ranges</em>. A class can be <em>positive</em> (any from the characters in the class match), or <em>negative</em> (any <em>but</em> the characters from the class match).</p>
<h4><a class="anchor" id="autotoc_md28600"></a>
Positive character class</h4>
<p>A positive character class is defined between <code>[</code> and <code>]</code> brackets:</p>
<div class="fragment"><div class="line">[a*]</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;CharacterClass&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;*&#39;,</div>
<div class="line">      symbol: &#39;*&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 42</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: some meta symbols are treated as normal characters in a character class. E.g. <code>*</code> is not a repetition quantifier, but a simple char. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md28601"></a>
Negative character class</h4>
<p>A negative character class is defined between <code>[^</code> and <code>]</code> brackets:</p>
<div class="fragment"><div class="line">[^ab]</div>
</div><!-- fragment --><p>An AST node is the same, just <code>negative</code> property is added:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;CharacterClass&#39;,</div>
<div class="line">  negative: true,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;b&#39;,</div>
<div class="line">      symbol: &#39;b&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 98</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28602"></a>
Character class ranges</h4>
<p>As mentioned, a character class may also contain <em>ranges</em> of symbols:</p>
<div class="fragment"><div class="line">[a-z]</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;CharacterClass&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;ClassRange&#39;,</div>
<div class="line">      from: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;a&#39;,</div>
<div class="line">        symbol: &#39;a&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 97</div>
<div class="line">      },</div>
<div class="line">      to: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;z&#39;,</div>
<div class="line">        symbol: &#39;z&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 122</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: it is a <em>syntax error</em> if <code>to</code> value is less than <code>from</code> value: <code>/[z-a]/</code>. </p>
</blockquote>
<p>The range value can be the same for <code>from</code> and <code>to</code>, and the special range <code>-</code> character is treated as a simple character when it stands in a char position:</p>
<div class="fragment"><div class="line">// from: &#39;a&#39;, to: &#39;a&#39;</div>
<div class="line">[a-a]</div>
<div class="line"> </div>
<div class="line">// from: &#39;-&#39;, to: &#39;-&#39;</div>
<div class="line">[---]</div>
<div class="line"> </div>
<div class="line">// simple &#39;-&#39; char:</div>
<div class="line">[-]</div>
<div class="line"> </div>
<div class="line">// 3 ranges:</div>
<div class="line">[a-zA-Z0-9]+</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28603"></a>
Unicode properties</h3>
<p>Unicode property escapes are a new type of escape sequence available in regular expressions that have the <code>u</code> flag set. With this feature it is possible to write Unicode expressions as:</p>
<div class="fragment"><div class="line">const greekSymbolRe = /\p{Script=Greek}/u;</div>
<div class="line"> </div>
<div class="line">greekSymbolRe.test(&#39;π&#39;); // true</div>
</div><!-- fragment --><p>The AST node for this expression is:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;UnicodeProperty&#39;,</div>
<div class="line">  name: &#39;Script&#39;,</div>
<div class="line">  value: &#39;Greek&#39;,</div>
<div class="line">  negative: false,</div>
<div class="line">  shorthand: false,</div>
<div class="line">  binary: false,</div>
<div class="line">  canonicalName: &#39;Script&#39;,</div>
<div class="line">  canonicalValue: &#39;Greek&#39;</div>
<div class="line">}</div>
</div><!-- fragment --><p>All possible property names, values, and their aliases can be found at the <a href="https://tc39.github.io/ecma262/#sec-runtime-semantics-unicodematchproperty-p">specification</a>.</p>
<p>For <code>General_Category</code> it is possible to use a shorthand:</p>
<div class="fragment"><div class="line">/\p{Letter}/u;   // Shorthand</div>
<div class="line"> </div>
<div class="line">/\p{General_Category=Letter}/u; // Full notation</div>
</div><!-- fragment --><p>Binary names use the single value as well:</p>
<div class="fragment"><div class="line">/\p{ASCII_Hex_Digit}/u; // Same as: /[0-9A-Fa-f]/</div>
</div><!-- fragment --><p>The capitalized <code>P</code> defines the negation of the expression:</p>
<div class="fragment"><div class="line">/\P{ASCII_Hex_Digit}/u; // NOT a ASCII Hex digit</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28604"></a>
Alternative</h3>
<p>An <em>alternative</em> (or <em>concatenation</em>) defines a chain of patterns followed one after another:</p>
<div class="fragment"><div class="line">abc</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;b&#39;,</div>
<div class="line">      symbol: &#39;b&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 98</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;c&#39;,</div>
<div class="line">      symbol: &#39;c&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 99</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another examples:</p>
<div class="fragment"><div class="line">// &#39;a&#39; with a quantifier, followed by &#39;b&#39;</div>
<div class="line">a?b</div>
<div class="line"> </div>
<div class="line">// A group followed by a class:</div>
<div class="line">(ab)[a-z]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28605"></a>
Disjunction</h3>
<p>The <em>disjunction</em> defines "OR" operation for regexp patterns. It's a <em>binary</em> operation, having <code>left</code>, and <code>right</code> nodes.</p>
<p>Matches <code>a</code> or <code>b</code>:</p>
<div class="fragment"><div class="line">a|b</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Disjunction&#39;,</div>
<div class="line">  left: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  right: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;b&#39;,</div>
<div class="line">    symbol: &#39;b&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 98</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28606"></a>
Groups</h3>
<p>The groups play two roles: they define <em>grouping precedence</em>, and allow to <em>capture</em> needed sub-expressions in case of a capturing group.</p>
<h4><a class="anchor" id="autotoc_md28607"></a>
Capturing group</h4>
<p><em>"Capturing"</em> means the matched string can be referred later by a user, including in the pattern itself &ndash; by using backreferences.</p>
<p>Char <code>a</code>, and <code>b</code> are grouped, followed by the <code>c</code> char:</p>
<div class="fragment"><div class="line">(ab)c</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Group&#39;,</div>
<div class="line">      capturing: true,</div>
<div class="line">      number: 1,</div>
<div class="line">      expression: {</div>
<div class="line">        type: &#39;Alternative&#39;,</div>
<div class="line">        expressions: [</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;a&#39;,</div>
<div class="line">            symbol: &#39;a&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 97</div>
<div class="line">          },</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;b&#39;,</div>
<div class="line">            symbol: &#39;b&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 98</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;c&#39;,</div>
<div class="line">      symbol: &#39;c&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 99</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>As we can see, it also tracks the number of the group.</p>
<p>Another example:</p>
<div class="fragment"><div class="line">// A grouped disjunction of a symbol, and a character class:</div>
<div class="line">(5|[a-z])</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28608"></a>
Named capturing group</h4>
<p>A capturing group can be given a name using the <code>(?&lt;name&gt;...)</code> syntax, for any identifier <code>name</code>.</p>
<p>For example, a regular expressions for a date:</p>
<div class="fragment"><div class="line">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u</div>
</div><!-- fragment --><p>For the group:</p>
<div class="fragment"><div class="line">(?&lt;foo&gt;x)</div>
</div><!-- fragment --><p>We have the following node (the <code>name</code> property with value <code>foo</code> is added):</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Group&#39;,</div>
<div class="line">  capturing: true,</div>
<div class="line">  name: &#39;foo&#39;,</div>
<div class="line">  nameRaw: &#39;foo&#39;,</div>
<div class="line">  number: 1,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;x&#39;,</div>
<div class="line">    symbol: &#39;x&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 120</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: The <code>nameRaw</code> property represents the name <em>as parsed from the original source</em>, including escape sequences. The <code>name</code> property represents the canonical decoded form of the name.</p>
<p>For example, given the <code>/u</code> flag and the following group:</p>
<div class="fragment"><div class="line">(?&lt;\u{03C0}&gt;x)</div>
</div><!-- fragment --><p>We would have the following node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Group&#39;,</div>
<div class="line">  capturing: true,</div>
<div class="line">  name: &#39;π&#39;,</div>
<div class="line">  nameRaw: &#39;\\u{03C0}&#39;,</div>
<div class="line">  number: 1,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;x&#39;,</div>
<div class="line">    symbol: &#39;x&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 120</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28609"></a>
Non-capturing group</h4>
<p>Sometimes we don't need to actually capture the matched string from a group. In this case we can use a <em>non-capturing</em> group:</p>
<p>Char <code>a</code>, and <code>b</code> are grouped, <em>but not captured</em>, followed by the <code>c</code> char:</p>
<div class="fragment"><div class="line">(?:ab)c</div>
</div><!-- fragment --><p>The same node, the <code>capturing</code> flag is <code>false</code>:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Group&#39;,</div>
<div class="line">      capturing: false,</div>
<div class="line">      expression: {</div>
<div class="line">        type: &#39;Alternative&#39;,</div>
<div class="line">        expressions: [</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;a&#39;,</div>
<div class="line">            symbol: &#39;a&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 97</div>
<div class="line">          },</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;b&#39;,</div>
<div class="line">            symbol: &#39;b&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 98</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;c&#39;,</div>
<div class="line">      symbol: &#39;c&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 99</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28610"></a>
Backreferences</h4>
<p>A capturing group can be referenced in the pattern using notation of an escaped group number.</p>
<p>Matches <code>abab</code> string:</p>
<div class="fragment"><div class="line">(ab)\1</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Group&#39;,</div>
<div class="line">      capturing: true,</div>
<div class="line">      number: 1,</div>
<div class="line">      expression: {</div>
<div class="line">        type: &#39;Alternative&#39;,</div>
<div class="line">        expressions: [</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;a&#39;,</div>
<div class="line">            symbol: &#39;a&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 97</div>
<div class="line">          },</div>
<div class="line">          {</div>
<div class="line">            type: &#39;Char&#39;,</div>
<div class="line">            value: &#39;b&#39;,</div>
<div class="line">            symbol: &#39;b&#39;,</div>
<div class="line">            kind: &#39;simple&#39;,</div>
<div class="line">            codePoint: 98</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Backreference&#39;,</div>
<div class="line">      kind: &#39;number&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      reference: 1,</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>A named capturing group can be accessed using <code>\k&lt;name&gt;</code> pattern, and also using a numbered reference.</p>
<p>Matches <code>www</code>:</p>
<div class="fragment"><div class="line">(?&lt;foo&gt;w)\k&lt;foo&gt;\1</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Group&#39;,</div>
<div class="line">      capturing: true,</div>
<div class="line">      name: &#39;foo&#39;,</div>
<div class="line">      nameRaw: &#39;foo&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      expression: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;w&#39;,</div>
<div class="line">        symbol: &#39;w&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 119</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Backreference&#39;,</div>
<div class="line">      kind: &#39;name&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      reference: &#39;foo&#39;,</div>
<div class="line">      referenceRaw: &#39;foo&#39;</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Backreference&#39;,</div>
<div class="line">      kind: &#39;number&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      reference: 1</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: The <code>referenceRaw</code> property represents the reference <em>as parsed from the original source</em>, including escape sequences. The <code>reference</code> property represents the canonical decoded form of the reference.</p>
<p>For example, given the <code>/u</code> flag and the following pattern (matches <code>www</code>):</p>
<div class="fragment"><div class="line">(?&lt;π&gt;w)\k&lt;\u{03C0}&gt;\1</div>
</div><!-- fragment --><p>We would have the following node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Group&#39;,</div>
<div class="line">      capturing: true,</div>
<div class="line">      name: &#39;π&#39;,</div>
<div class="line">      nameRaw: &#39;π&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      expression: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;w&#39;,</div>
<div class="line">        symbol: &#39;w&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 119</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Backreference&#39;,</div>
<div class="line">      kind: &#39;name&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      reference: &#39;π&#39;,</div>
<div class="line">      referenceRaw: &#39;\\u{03C0}&#39;</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Backreference&#39;,</div>
<div class="line">      kind: &#39;number&#39;,</div>
<div class="line">      number: 1,</div>
<div class="line">      reference: 1</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28611"></a>
Quantifiers</h3>
<p>Quantifiers specify <em>repetition</em> of a regular expression (or of its part). Below are the quantifiers which <em>wrap</em> a parsed expression into a <code>Repetition</code> node. The quantifier itself can be of different <em>kinds</em>, and has <code>Quantifier</code> node type.</p>
<h4><a class="anchor" id="autotoc_md28612"></a>
? zero-or-one</h4>
<p>The <code>?</code> quantifier is short for <code>{0,1}</code>.</p>
<div class="fragment"><div class="line">a?</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;?&#39;,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28613"></a>
* zero-or-more</h4>
<p>The <code>*</code> quantifier is short for <code>{0,}</code>.</p>
<div class="fragment"><div class="line">a*</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;*&#39;,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28614"></a>
+ one-or-more</h4>
<p>The <code>+</code> quantifier is short for <code>{1,}</code>.</p>
<div class="fragment"><div class="line">// Same as `aa*`, or `a{1,}`</div>
<div class="line">a+</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;+&#39;,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28615"></a>
Range-based quantifiers</h4>
<p>Explicit <em>range-based</em> quantifiers are parsed as follows:</p>
<h5><a class="anchor" id="autotoc_md28616"></a>
Exact number of matches</h5>
<div class="fragment"><div class="line">a{3}</div>
</div><!-- fragment --><p>The type of the quantifier is <code>Range</code>, and <code>from</code>, and <code>to</code> properties have the same value:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;Range&#39;,</div>
<div class="line">    from: 3,</div>
<div class="line">    to: 3,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md28617"></a>
Open range</h5>
<p>An open range doesn't have max value (assuming semantic "more", or Infinity value):</p>
<div class="fragment"><div class="line">a{3,}</div>
</div><!-- fragment --><p>An AST node for such range doesn't contain <code>to</code> property:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;Range&#39;,</div>
<div class="line">    from: 3,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md28618"></a>
Closed range</h5>
<p>A closed range has explicit max value: (which syntactically can be the same as min value):</p>
<div class="fragment"><div class="line">a{3,5}</div>
<div class="line"> </div>
<div class="line">// Same as a{3}</div>
<div class="line">a{3,3}</div>
</div><!-- fragment --><p>An AST node for a closed range:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;Range&#39;,</div>
<div class="line">    from: 3,</div>
<div class="line">    to: 5,</div>
<div class="line">    greedy: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: it is a <em>syntax error</em> if the max value is less than min value: <code>/a{3,2}/</code> </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md28619"></a>
Non-greedy</h4>
<p>If any quantifier is followed by the <code>?</code>, the quantifier becomes <em>non-greedy</em>.</p>
<p>Example:</p>
<div class="fragment"><div class="line">a+?</div>
</div><!-- fragment --><p>Node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Repetition&#39;,</div>
<div class="line">  expression: {</div>
<div class="line">    type: &#39;Char&#39;,</div>
<div class="line">    value: &#39;a&#39;,</div>
<div class="line">    symbol: &#39;a&#39;,</div>
<div class="line">    kind: &#39;simple&#39;,</div>
<div class="line">    codePoint: 97</div>
<div class="line">  },</div>
<div class="line">  quantifier: {</div>
<div class="line">    type: &#39;Quantifier&#39;,</div>
<div class="line">    kind: &#39;+&#39;,</div>
<div class="line">    greedy: false</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Other examples:</p>
<div class="fragment"><div class="line">a??</div>
<div class="line">a*?</div>
<div class="line">a{1}?</div>
<div class="line">a{1,}?</div>
<div class="line">a{1,3}?</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28620"></a>
Assertions</h3>
<p>Assertions appear as separate AST nodes, however instread of manipulating on the characters themselves, they <em>assert</em> certain conditions of a matching string. Examples: <code>^</code> &ndash; beginning of a string (or a line in multiline mode), <code>$</code> &ndash; end of a string, etc.</p>
<h4><a class="anchor" id="autotoc_md28621"></a>
^ begin marker</h4>
<p>The <code>^</code> assertion checks whether a scanner is at the beginning of a string (or a line in multiline mode).</p>
<p>In the example below <code>^</code> is not a property of the <code>a</code> symbol, but a separate AST node for the assertion. The parsed node is actually an <code>Alternative</code> with two nodes:</p>
<div class="fragment"><div class="line">^a</div>
</div><!-- fragment --><p>The node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;^&#39;</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since assertion is a separate node, it may appear anywhere in the matching string. The following regexp is completely valid, and asserts beginning of the string; it'll match an empty string:</p>
<div class="fragment"><div class="line">^^^^^</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28622"></a>
$ end marker</h4>
<p>The <code>$</code> assertion is similar to <code>^</code>, but asserts the end of a string (or a line in a multiline mode):</p>
<div class="fragment"><div class="line">a$</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;$&#39;</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>And again, this is a completely valid regexp, and matches an empty string:</p>
<div class="fragment"><div class="line">^^^^$$$$$</div>
<div class="line"> </div>
<div class="line">// valid too:</div>
<div class="line">$^</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28623"></a>
Boundary assertions</h4>
<p>The <code>\b</code> assertion check for <em>word boundary</em>, i.e. the position between a word and a space.</p>
<p>Matches <code>x</code> in <code>x y</code>, but not in <code>xy</code>:</p>
<div class="fragment"><div class="line">x\b</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;x&#39;,</div>
<div class="line">      symbol: &#39;x&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 120</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;\\b&#39;</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>\B</code> is vice-versa checks for <em>non-word</em> boundary. The following example matches <code>x</code> in <code>xy</code>, but not in <code>x y</code>:</p>
<div class="fragment"><div class="line">x\B</div>
</div><!-- fragment --><p>A node is the same:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;x&#39;,</div>
<div class="line">      symbol: &#39;x&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 120</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;\\B&#39;</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28624"></a>
Lookahead assertions</h4>
<p>These assertions check whether a pattern is <em>followed</em> (or not followed for the negative assertion) by another pattern.</p>
<h5><a class="anchor" id="autotoc_md28625"></a>
Positive lookahead assertion</h5>
<p>Matches <code>a</code> only if it's followed by <code>b</code>:</p>
<div class="fragment"><div class="line">a(?=b)</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;Lookahead&#39;,</div>
<div class="line">      assertion: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;b&#39;,</div>
<div class="line">        symbol: &#39;b&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 98</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md28626"></a>
Negative lookahead assertion</h5>
<p>Matches <code>a</code> only if it's <em>not</em> followed by <code>b</code>:</p>
<div class="fragment"><div class="line">a(?!b)</div>
</div><!-- fragment --><p>A node is similar, just <code>negative</code> flag is added:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;a&#39;,</div>
<div class="line">      symbol: &#39;a&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 97</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;Lookahead&#39;,</div>
<div class="line">      negative: true,</div>
<div class="line">      assertion: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;b&#39;,</div>
<div class="line">        symbol: &#39;b&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 98</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md28627"></a>
Lookbehind assertions</h4>
<blockquote class="doxtable">
<p>NOTE: <em>Lookbehind assertions</em> are not yet supported by JavaScript RegExp. It is an ECMAScript <a href="https://tc39.github.io/proposal-regexp-lookbehind/">proposal</a> which is at stage 3 at the moment. </p>
</blockquote>
<p>These assertions check whether a pattern is <em>preceded</em> (or not preceded for the negative assertion) by another pattern.</p>
<h5><a class="anchor" id="autotoc_md28628"></a>
Positive lookbehind assertion</h5>
<p>Matches <code>b</code> only if it's preceded by <code>a</code>:</p>
<div class="fragment"><div class="line">(?&lt;=a)b</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;Lookbehind&#39;,</div>
<div class="line">      assertion: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;a&#39;,</div>
<div class="line">        symbol: &#39;a&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 97</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;b&#39;,</div>
<div class="line">      symbol: &#39;b&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 98</div>
<div class="line">    },</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md28629"></a>
Negative lookbehind assertion</h5>
<p>Matches <code>b</code> only if it's <em>not</em> preceded by <code>a</code>:</p>
<div class="fragment"><div class="line">(?&lt;!a)b</div>
</div><!-- fragment --><p>A node:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;Alternative&#39;,</div>
<div class="line">  expressions: [</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Assertion&#39;,</div>
<div class="line">      kind: &#39;Lookbehind&#39;,</div>
<div class="line">      negative: true,</div>
<div class="line">      assertion: {</div>
<div class="line">        type: &#39;Char&#39;,</div>
<div class="line">        value: &#39;a&#39;,</div>
<div class="line">        symbol: &#39;a&#39;,</div>
<div class="line">        kind: &#39;simple&#39;,</div>
<div class="line">        codePoint: 97</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type: &#39;Char&#39;,</div>
<div class="line">      value: &#39;b&#39;,</div>
<div class="line">      symbol: &#39;b&#39;,</div>
<div class="line">      kind: &#39;simple&#39;,</div>
<div class="line">      codePoint: 98</div>
<div class="line">    },</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_b3e7c26d34651291291696f82097f19f.html">regexp-tree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
