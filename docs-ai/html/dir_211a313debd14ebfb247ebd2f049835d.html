<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/regex-recursion Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_211a313debd14ebfb247ebd2f049835d.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">regex-recursion Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://npmjs.com/package/regex-recursion"><img src="https://img.shields.io/npm/v/regex-recursion?color=78C372" alt="npm version" class="inline"/></a> <a href="https://npmjs.com/package/regex-recursion"><img src="https://img.shields.io/npm/dm/regex-recursion?color=78C372" alt="npm downloads" class="inline"/></a> <a href="https://bundlejs.com/?q=regex-recursion&amp;treeshake=[*]"><img src="https://img.shields.io/bundlejs/size/regex-recursion?color=78C372&amp;label=minzip" alt="bundle" class="inline"/></a></p>
<p>This is an official plugin for <a href="https://github.com/slevithan/regex">Regex+</a> that adds support for recursive matching up to a specified max depth <em>N</em>, where <em>N</em> can be between 2 and 100. Generated regexes are native JavaScript <code>RegExp</code> instances.</p>
<dl class="section note"><dt>Note</dt><dd>Regex flavors vary on whether they offer infinite or fixed-depth recursion. For example, recursion in Oniguruma uses a depth limit of 20, and doesn't allow changing this.</dd></dl>
<p>Recursive matching is added to a regex via one of the following (the recursion depth limit is provided in place of <em><code>N</code></em>):</p>
<ul>
<li><code>(?R=N)</code> — Recursively match the entire regex at this position.</li>
<li><code>\g&lt;name&amp;R=N&gt;</code> or <code>\g&lt;number&amp;R=N&gt;</code> — Recursively match the contents of the group referenced by name or number at this position.<ul>
<li>The <code>\g</code> subroutine must be <em>within</em> the referenced group.</li>
</ul>
</li>
</ul>
<p>Multiple uses of recursion within the same pattern are allowed if they are non-overlapping. Named captures and backreferences are supported within recursion, and are independent per depth level. So e.g. <code>groups.name</code> on a match object is the value captured by group <code>name</code> at the top level of the recursion stack.</p>
<h1><a class="anchor" id="autotoc_md28519"></a>
Install and use</h1>
<div class="fragment"><div class="line">npm install regex regex-recursion</div>
</div><!-- fragment --><div class="fragment"><div class="line">import {regex} from &#39;regex&#39;;</div>
<div class="line">import {recursion} from &#39;regex-recursion&#39;;</div>
<div class="line"> </div>
<div class="line">const re = regex({plugins: [recursion]})`…`;</div>
</div><!-- fragment --><details >
<summary >
Using a global name (no import)</summary>
<p></p>
<div class="fragment"><div class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/regex@6.0.1/dist/regex.min.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/regex-recursion@6.0.2/dist/regex-recursion.min.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script&gt;</div>
<div class="line">  const {regex} = Regex;</div>
<div class="line">  const {recursion} = Regex.plugins;</div>
<div class="line"> </div>
<div class="line">  const re = regex({plugins: [recursion]})`…`;</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="autotoc_md28520"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md28521"></a>
Match an equal number of two different subpatterns</h2>
<h3><a class="anchor" id="autotoc_md28522"></a>
Anywhere within a string</h3>
<div class="fragment"><div class="line">// Matches sequences of up to 20 &#39;a&#39; chars followed by the same number of &#39;b&#39;</div>
<div class="line">const re = regex({plugins: [recursion]})`a(?R=20)?b`;</div>
<div class="line">re.exec(&#39;test aaaaaabbb&#39;)[0];</div>
<div class="line">// → &#39;aaabbb&#39;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28523"></a>
As the entire string</h3>
<p>Use <code>\g&lt;name&amp;R=N&gt;</code> to recursively match just the specified group.</p>
<div class="fragment"><div class="line">const re = regex({plugins: [recursion]})`</div>
<div class="line">  ^ (?&lt;r&gt; a \g&lt;r&amp;R=20&gt;? b) $</div>
<div class="line">`;</div>
<div class="line">re.test(&#39;aaabbb&#39;); // → true</div>
<div class="line">re.test(&#39;aaabb&#39;); // → false</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28524"></a>
Match balanced parentheses</h2>
<div class="fragment"><div class="line">// Matches all balanced parentheses up to depth 20</div>
<div class="line">const parens = regex({flags: &#39;g&#39;, plugins: [recursion]})`</div>
<div class="line">  \&zwj;( ([^\&zwj;(\&zwj;)] | (?R=20))* \&zwj;)</div>
<div class="line">`;</div>
<div class="line"> </div>
<div class="line">&#39;test ) (balanced ((parens))) () ((a)) ( (b)&#39;.match(parens);</div>
<div class="line">/* → [</div>
<div class="line">  &#39;(balanced ((parens)))&#39;,</div>
<div class="line">  &#39;()&#39;,</div>
<div class="line">  &#39;((a))&#39;,</div>
<div class="line">  &#39;(b)&#39;</div>
<div class="line">] */</div>
</div><!-- fragment --><p>Following is an alternative that matches the same strings, but adds a nested quantifier. It then uses an atomic group to prevent this nested quantifier from creating the potential for <a href="https://www.regular-expressions.info/catastrophic.html">catastrophic backtracking</a>. Since the example above doesn't need a nested quantifier, this is not an improvement but merely an alternative that shows how to deal with the general problem of nested quantifiers with multiple ways to divide matches of the same strings.</p>
<div class="fragment"><div class="line">const parens = regex({flags: &#39;g&#39;, plugins: [recursion]})`</div>
<div class="line">  \&zwj;( ((?&gt; [^\&zwj;(\&zwj;)]+) | (?R=20))* \&zwj;)</div>
<div class="line">`;</div>
<div class="line"> </div>
<div class="line">// Or with a possessive quantifier</div>
<div class="line">const parens = regex({flags: &#39;g&#39;, plugins: [recursion]})`</div>
<div class="line">  \&zwj;( ([^\&zwj;(\&zwj;)]++ | (?R=20))* \&zwj;)</div>
<div class="line">`;</div>
</div><!-- fragment --><p>The first example above matches sequences of non-parentheses in one step with the nested <code>+</code> quantifier, and avoids backtracking into these sequences by wrapping it with an atomic group <code>(?&gt;…)</code>. Given that what the nested quantifier <code>+</code> matches overlaps with what the outer group can match with its <code>*</code> quantifier, the atomic group is important here. It avoids exponential backtracking when matching long strings with unbalanced parentheses.</p>
<p>In cases where you're you're repeating a single token within an atomic group, possessive quantifiers provide syntax sugar.</p>
<p>Atomic groups and possessive quantifiers are provided by the base Regex+ library.</p>
<h2><a class="anchor" id="autotoc_md28525"></a>
Match palindromes</h2>
<h3><a class="anchor" id="autotoc_md28526"></a>
Match palindromes anywhere within a string</h3>
<div class="fragment"><div class="line">const palindromes = regex({flags: &#39;gi&#39;, plugins: [recursion]})`</div>
<div class="line">  (?&lt;char&gt; \w)</div>
<div class="line">  # Recurse, or match a lone unbalanced char in the middle</div>
<div class="line">  ((?R=15) | \w?)</div>
<div class="line">  \k&lt;char&gt;</div>
<div class="line">`;</div>
<div class="line"> </div>
<div class="line">&#39;Racecar, ABBA, and redivided&#39;.match(palindromes);</div>
<div class="line">// → [&#39;Racecar&#39;, &#39;ABBA&#39;, &#39;edivide&#39;]</div>
</div><!-- fragment --><p>Palindromes are sequences that read the same backwards as forwards. In the example above, the max length of matched palindromes is 31. That's because it sets the max recursion depth to 15 with <code>(?R=15)</code>. So, depth 15 × 2 chars (left + right) for each depth level + 1 optional unbalanced char in the middle = 31. To match longer palindromes, the max recursion depth can be increased to a max of 100, which would enable matching palindromes up to 201 characters long.</p>
<h3><a class="anchor" id="autotoc_md28527"></a>
Match palindromes as complete words</h3>
<div class="fragment"><div class="line">const palindromeWords = regex({flags: &#39;gi&#39;, plugins: [recursion]})`</div>
<div class="line">  \b</div>
<div class="line">  (?&lt;palindrome&gt;</div>
<div class="line">    (?&lt;char&gt; \w)</div>
<div class="line">    (\g&lt;palindrome&amp;R=15&gt; | \w?)</div>
<div class="line">    \k&lt;char&gt;</div>
<div class="line">  )</div>
<div class="line">  \b</div>
<div class="line">`;</div>
<div class="line"> </div>
<div class="line">&#39;Racecar, ABBA, and redivided&#39;.match(palindromeWords);</div>
<div class="line">// → [&#39;Racecar&#39;, &#39;ABBA&#39;]</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_211a313debd14ebfb247ebd2f049835d.html">regex-recursion</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
