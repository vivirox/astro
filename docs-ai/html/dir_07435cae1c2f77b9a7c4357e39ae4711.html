<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/styled-jsx Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_07435cae1c2f77b9a7c4357e39ae4711.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">styled-jsx Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://github.com/vercel/styled-jsx/actions?query=branch%3Amain"><img src="https://github.com/vercel/styled-jsx/actions/workflows/main.yml/badge.svg?branch=main" alt="build status" style="pointer-events: none;" class="inline"/></a></p>
<p>Full, scoped and component-friendly CSS support for JSX (rendered on the server or the client).</p>
<p>Code and docs are for v3 which we highly recommend you to try. Looking for styled-jsx v2? Switch to the <a href="https://github.com/vercel/styled-jsx/tree/v2">v2 branch</a>.</p>
<ul>
<li>Getting started</li>
<li>Configuration options<ul>
<li>`optimizeForSpeed`</li>
<li>`sourceMaps`</li>
<li>`styleModule`</li>
<li>`vendorPrefixes`</li>
</ul>
</li>
<li><a class="el" href="md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g.html#features">Features</a></li>
<li>How It Works<ul>
<li>Why It Works Like This</li>
</ul>
</li>
<li>Targeting The Root</li>
<li>Global styles<ul>
<li>One-off global selectors</li>
</ul>
</li>
<li>Dynamic styles<ul>
<li>Via interpolated dynamic props</li>
<li>Via `className` toggling</li>
<li>Via inline `style`</li>
</ul>
</li>
<li>Constants</li>
<li>Server-Side Rendering</li>
<li>External CSS and styles outside of the component<ul>
<li>External styles</li>
<li>Styles outside of components</li>
<li>The `resolve` tag</li>
<li>Styles in regular CSS files</li>
</ul>
</li>
<li>CSS Preprocessing via Plugins<ul>
<li>Plugin options</li>
<li>Example plugins</li>
</ul>
</li>
<li>Rendering in tests</li>
<li><a class="el" href="md_node__modules_2safer-buffer_2_porting-_buffer.html#faq">FAQ</a><ul>
<li>Warning: unknown `jsx` prop on &lt;style&gt; tag</li>
<li>Can I return an array of components when using React 16?</li>
<li>Styling third parties / child components from the parent</li>
<li><a href="https://github.com/vercel/styled-jsx/issues/319#issuecomment-349239326">Some styles are missing in production</a></li>
<li>Build a component library with styled-jsx</li>
</ul>
</li>
<li>Syntax Highlighting</li>
<li>ESLint</li>
<li>TypeScript</li>
<li>Credits</li>
</ul>
<h1><a class="anchor" id="autotoc_md31555"></a>
Getting started</h1>
<p>Firstly, install the package:</p>
<div class="fragment"><div class="line">npm install --save styled-jsx</div>
</div><!-- fragment --><p>Next, add <code>styled-jsx/babel</code> to <code>plugins</code> in your babel configuration:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [&quot;styled-jsx/babel&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now add <code>&lt;style jsx&gt;</code> to your code and fill it with CSS:</p>
<div class="fragment"><div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;p&gt;only this paragraph will get the style :)&lt;/p&gt;</div>
<div class="line"> </div>
<div class="line">    {/* you can include &lt;Component /&gt;s here that include</div>
<div class="line">         other &lt;p&gt;s that don&#39;t get unexpected styles! */}</div>
<div class="line"> </div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      p {</div>
<div class="line">        color: red;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31556"></a>
Configuration options</h1>
<p>The following are optional settings for the babel plugin.</p>
<h3><a class="anchor" id="autotoc_md31557"></a>
<code>optimizeForSpeed</code></h3>
<p>Blazing fast and optimized CSS rules injection system based on the CSSOM APIs.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [[&quot;styled-jsx/babel&quot;, { &quot;optimizeForSpeed&quot;: true }]]</div>
<div class="line">}</div>
</div><!-- fragment --><p>When in production* this mode is automatically enabled.<br  />
 Beware that when using this option source maps cannot be generated and styles cannot be edited via the devtools.</p>
<ul>
<li>&lsquo;process.env.NODE_ENV === 'production&rsquo;`</li>
</ul>
<h3><a class="anchor" id="autotoc_md31558"></a>
<code>sourceMaps</code></h3>
<p>Generates source maps (default: <code>false</code>)</p>
<h3><a class="anchor" id="autotoc_md31559"></a>
<code>styleModule</code></h3>
<p>Module that the transpiled files should import (default: <code>styled-jsx/style</code>)</p>
<h3><a class="anchor" id="autotoc_md31560"></a>
<code>vendorPrefixes</code></h3>
<p>Turn on/off automatic vendor prefixing (default: <code>true</code>)</p>
<h1><a class="anchor" id="autotoc_md31561"></a>
Features</h1>
<ul>
<li>Full CSS support, no tradeoffs in power</li>
<li>Runtime size of just <b>3kb</b> (gzipped, from 12kb)</li>
<li>Complete isolation: Selectors, animations, keyframes</li>
<li>Built-in CSS vendor prefixing</li>
<li>Very fast, minimal and efficient transpilation (see below)</li>
<li>High-performance runtime-CSS-injection when not server-rendering</li>
<li>Future-proof: Equivalent to server-renderable "Shadow CSS"</li>
<li>Source maps support</li>
<li>Dynamic styles and themes support</li>
<li>CSS Preprocessing via Plugins</li>
</ul>
<h1><a class="anchor" id="autotoc_md31562"></a>
Using in Next.js</h1>
<p>Next.js automatically configures <code>styled-jsx</code> with babel or swc, you don't have to configure it manually.</p>
<h1><a class="anchor" id="autotoc_md31563"></a>
How It Works</h1>
<p>The example above transpiles to the following:</p>
<div class="fragment"><div class="line">import _JSXStyle from &#39;styled-jsx/style&#39;</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div className=&quot;jsx-123&quot;&gt;</div>
<div class="line">    &lt;p className=&quot;jsx-123&quot;&gt;only this paragraph will get the style :)&lt;/p&gt;</div>
<div class="line">    &lt;_JSXStyle id=&quot;123&quot;&gt;{`p.jsx-123 {color: red;}`}&lt;/_JSXStyle&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31564"></a>
Why It Works Like This</h2>
<p>Unique classnames give us style encapsulation and <code>_JSXStyle</code> is heavily optimized for:</p>
<ul>
<li>Injecting styles upon render</li>
<li>Only injecting a certain component's style once (even if the component is included multiple times)</li>
<li>Removing unused styles</li>
<li>Keeping track of styles for server-side rendering</li>
</ul>
<h2><a class="anchor" id="autotoc_md31565"></a>
Targeting The Root</h2>
<p>Notice that the outer <code>&lt;div&gt;</code> from the example above also gets a <code>jsx-123</code> classname. We do this so that you can target the "root" element, in the same manner that <a href="https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-host"><code>:host</code></a> works with Shadow DOM.</p>
<p>If you want to target <em>only</em> the host, we suggest you use a class:</p>
<div class="fragment"><div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div className=&quot;root&quot;&gt;</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      .root {</div>
<div class="line">        color: green;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31566"></a>
Global styles</h2>
<p>To skip scoping entirely, you can make the global-ness of your styles explicit by adding <em>global</em>.</p>
<div class="fragment"><div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;style jsx global&gt;{`</div>
<div class="line">      body {</div>
<div class="line">        background: red;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>The advantage of using this over <code>&lt;style&gt;</code> is twofold: no need to use <code>dangerouslySetInnerHTML</code> to avoid escaping issues with CSS and take advantage of <code>styled-jsx</code>'s de-duping system to avoid the global styles being inserted multiple times.</p>
<h2><a class="anchor" id="autotoc_md31567"></a>
One-off global selectors</h2>
<p>Sometimes it's useful to skip selectors scoping. In order to get a one-off global selector we support <code>:global()</code>, inspired by <a href="https://github.com/css-modules/css-modules">css-modules</a>.</p>
<p>This is very useful in order to, for example, generate a <em>global class</em> that you can pass to 3rd-party components. For example, to style <code>react-select</code> which supports passing a custom class via <code>optionClassName</code>:</p>
<div class="fragment"><div class="line">import Select from &#39;react-select&#39;</div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;Select optionClassName=&quot;react-select&quot; /&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      /* &quot;div&quot; will be prefixed, but &quot;.react-select&quot; won&#39;t */</div>
<div class="line"> </div>
<div class="line">      div :global(.react-select) {</div>
<div class="line">        color: red;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31568"></a>
Dynamic styles</h2>
<p>To make a component's visual representation customizable from the outside world there are three options.</p>
<h3><a class="anchor" id="autotoc_md31569"></a>
Via interpolated dynamic props</h3>
<p>Any value that comes from the component's <code>render</code> method scope is treated as dynamic. This makes it possible to use <code>props</code> and <code>state</code> for example.</p>
<div class="fragment"><div class="line">const Button = props =&gt; (</div>
<div class="line">  &lt;button&gt;</div>
<div class="line">    {props.children}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: ${&#39;large&#39; in props ? &#39;50&#39; : &#39;20&#39;}px;</div>
<div class="line">        background: ${props.theme.background};</div>
<div class="line">        color: #999;</div>
<div class="line">        display: inline-block;</div>
<div class="line">        font-size: 1em;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>New styles' injection is optimized to perform well at runtime.</p>
<p>That said when your CSS is mostly static we recommend to split it up in static and dynamic styles and use two separate <code>style</code> tags so that, when changing, only the dynamic parts are recomputed/rendered.</p>
<div class="fragment"><div class="line">const Button = props =&gt; (</div>
<div class="line">  &lt;button&gt;</div>
<div class="line">    {props.children}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        color: #999;</div>
<div class="line">        display: inline-block;</div>
<div class="line">        font-size: 2em;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: ${&#39;large&#39; in props ? &#39;50&#39; : &#39;20&#39;}px;</div>
<div class="line">        background: ${props.theme.background};</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31570"></a>
Via <code>className</code> toggling</h3>
<p>The second option is to pass properties that toggle class names.</p>
<div class="fragment"><div class="line">const Button = props =&gt; (</div>
<div class="line">  &lt;button className={&#39;large&#39; in props &amp;&amp; &#39;large&#39;}&gt;</div>
<div class="line">    {props.children}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: 20px;</div>
<div class="line">        background: #eee;</div>
<div class="line">        color: #999;</div>
<div class="line">      }</div>
<div class="line">      .large {</div>
<div class="line">        padding: 50px;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then you would use this component as either <code>&lt;Button&gt;Hi&lt;/Button&gt;</code> or <code>&lt;Button large&gt;Big&lt;/Button&gt;</code>.</p>
<h3><a class="anchor" id="autotoc_md31571"></a>
Via inline <code>style</code></h3>
<p>***best for animations**</p>
<p>Imagine that you wanted to make the padding in the button above completely customizable. You can override the CSS you configure via inline-styles:</p>
<div class="fragment"><div class="line">const Button = ({ padding, children }) =&gt; (</div>
<div class="line">  &lt;button style={{ padding }}&gt;</div>
<div class="line">    {children}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: 20px;</div>
<div class="line">        background: #eee;</div>
<div class="line">        color: #999;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>In this example, the padding defaults to the one set in <code>&lt;style&gt;</code> (<code>20</code>), but the user can pass a custom one via <code>&lt;Button padding={30}&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md31572"></a>
Constants</h2>
<p>It is possible to use constants like so:</p>
<div class="fragment"><div class="line">import { colors, spacing } from &#39;../theme&#39;</div>
<div class="line">import { invertColor } from &#39;../theme/utils&#39;</div>
<div class="line"> </div>
<div class="line">const Button = ({ children }) =&gt; (</div>
<div class="line">  &lt;button&gt;</div>
<div class="line">    {children}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: ${spacing.medium};</div>
<div class="line">        background: ${colors.primary};</div>
<div class="line">        color: ${invertColor(colors.primary)};</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>Please keep in mind that constants defined outside of the component scope are treated as static styles.</p>
<h1><a class="anchor" id="autotoc_md31573"></a>
Server-Side Rendering</h1>
<p><code>styled-jsx</code> v5 introduced <code>StyledRegistry</code> component and <code>useStyleRegistry</code> hook to let you scope styles rendering in each SSR render to keep concurrent-safe.</p>
<ul>
<li><code>registry.styles()</code> will return the array of react components for style tags.</li>
<li><code>registry.flush()</code> can clean the existing styles in the registry, it's optional for SSR when you have a standalone registry for each SSR render.</li>
</ul>
<blockquote class="doxtable">
<p>Next.js 12 integrates with <code>styled-jsx</code> v5 and manages the registry for you. </p>
</blockquote>
<div class="fragment"><div class="line">import React from &#39;react&#39;</div>
<div class="line">import ReactDOM from &#39;react-dom/server&#39;</div>
<div class="line">import { StyleRegistry, useStyleRegistry } from &#39;styled-jsx&#39;</div>
<div class="line">import App from &#39;./app&#39;</div>
<div class="line"> </div>
<div class="line">function Styles() {</div>
<div class="line">  const registry = useStyleRegistry()</div>
<div class="line">  const styles = registry.styles()</div>
<div class="line">  return &lt;&gt;{styles}&lt;/&gt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export default (req, res) =&gt; {</div>
<div class="line">  const app = ReactDOM.renderToString(&lt;App /&gt;)</div>
<div class="line">  const html = ReactDOM.renderToStaticMarkup(</div>
<div class="line">    &lt;StyleRegistry&gt;</div>
<div class="line">      &lt;html&gt;</div>
<div class="line">        &lt;head&gt;</div>
<div class="line">          &lt;Styles /&gt;</div>
<div class="line">        &lt;/head&gt;</div>
<div class="line">        &lt;body&gt;</div>
<div class="line">          &lt;div id=&quot;root&quot; dangerouslySetInnerHTML={{ __html: app }} /&gt;</div>
<div class="line">        &lt;/body&gt;</div>
<div class="line">      &lt;/html&gt;</div>
<div class="line">    &lt;/StyleRegistry&gt;</div>
<div class="line">  )</div>
<div class="line">  res.end(&#39;&lt;!doctype html&gt;&#39; + html)</div>
<div class="line">}</div>
</div><!-- fragment --><p>There's also a new API <code>createStyleRegistry</code> that is introduced when you have to create a registry manually. In this way you can operate the registry yourself to extract the rendered styles (<code>registry.styles()</code>) or flush them out (<code>registry.flush()</code>).</p>
<div class="fragment"><div class="line">const registry = createStyleRegistry()</div>
<div class="line">const styles = registry.styles() // access styles</div>
<div class="line"> </div>
<div class="line">function Page() {</div>
<div class="line">  return (</div>
<div class="line">    &lt;StyleRegistry registry={registry}&gt;</div>
<div class="line">      &lt;App /&gt;</div>
<div class="line">    &lt;/StyleRegistry&gt;</div>
<div class="line">  )</div>
<div class="line">}</div>
</div><!-- fragment --><p>By default <code>&lt;StyleRegistry /&gt;</code> will use the <code>registry</code> from root top <code>StyleRegistry</code>, which means there's only one <code>registry</code> in the react tree.</p>
<p>It's <b>paramount</b> that you use one of these two functions so that the generated styles can be diffed when the client loads and duplicate styles are avoided.</p>
<h2><a class="anchor" id="autotoc_md31574"></a>
Content Security Policy</h2>
<p>Strict <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">CSP</a> is supported.</p>
<p>You should generate a nonce <b>per request</b>.</p>
<div class="fragment"><div class="line">import nanoid from &#39;nanoid&#39;</div>
<div class="line"> </div>
<div class="line">const nonce = Buffer.from(nanoid()).toString(&#39;base64&#39;) //ex: N2M0MDhkN2EtMmRkYi00MTExLWFhM2YtNDhkNTc4NGJhMjA3</div>
</div><!-- fragment --><p>You must then pass a nonce to <code>registry.styles({ nonce })</code> <b>and</b> set a <code>&lt;meta property="csp-nonce" content={nonce} /&gt;</code> tag.</p>
<p>Your CSP policy must share the same nonce as well (the header nonce needs to match the html nonce and remain unpredictable). &lsquo;Content-Security-Policy: default-src 'self&rsquo;; style-src 'self' 'nonce-N2M0MDhkN2EtMmRkYi00MTExLWFhM2YtNDhkNTc4NGJhMjA3';`</p>
<h2><a class="anchor" id="autotoc_md31575"></a>
External CSS and styles outside of the component</h2>
<p>In styled-jsx styles can be defined outside of the component's render method or in separate JavaScript modules using the <code>styled-jsx/css</code> library. <code>styled-jsx/css</code> exports three tags that can be used to tag your styles:</p>
<ul>
<li><code>css</code>, the default export, to define scoped styles.</li>
<li><code>css.global</code> to define global styles.</li>
<li><code>css.resolve</code> to define scoped styles that resolve to the scoped <code>className</code> and a <code>styles</code> element.</li>
</ul>
<h3><a class="anchor" id="autotoc_md31576"></a>
External styles</h3>
<p>In an external file:</p>
<div class="fragment"><div class="line">/* styles.js */</div>
<div class="line">import css from &#39;styled-jsx/css&#39;</div>
<div class="line"> </div>
<div class="line">// Scoped styles</div>
<div class="line">export const button = css`</div>
<div class="line">  button {</div>
<div class="line">    color: hotpink;</div>
<div class="line">  }</div>
<div class="line">`</div>
<div class="line"> </div>
<div class="line">// Global styles</div>
<div class="line">export const body = css.global`body { margin: 0; }`</div>
<div class="line"> </div>
<div class="line">// Resolved styles</div>
<div class="line">export const link = css.resolve`a { color: green; }`</div>
<div class="line">// link.className -&gt; scoped className to apply to `a` elements e.g. jsx-123</div>
<div class="line">// link.styles -&gt; styles element to render inside of your component</div>
<div class="line"> </div>
<div class="line">// Works also with default exports</div>
<div class="line">export default css`</div>
<div class="line">  div {</div>
<div class="line">    color: green;</div>
<div class="line">  }</div>
<div class="line">`</div>
</div><!-- fragment --><p>You can then import and use those styles:</p>
<div class="fragment"><div class="line">import styles, { button, body } from &#39;./styles&#39;</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;button&gt;styled-jsx&lt;/button&gt;</div>
<div class="line">    &lt;style jsx&gt;{styles}&lt;/style&gt;</div>
<div class="line">    &lt;style jsx&gt;{button}&lt;/style&gt;</div>
<div class="line">    &lt;style jsx global&gt;</div>
<div class="line">      {body}</div>
<div class="line">    &lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>N.B. All the tags except for `resolve` don't support dynamic styles.</p>
<p><code>resolve</code> and <code>global</code> can also be imported individually:</p>
<div class="fragment"><div class="line">import { resolve } from &#39;styled-jsx/css&#39;</div>
<div class="line">import { global } from &#39;styled-jsx/css&#39;</div>
</div><!-- fragment --><p>If you use Prettier we recommend you to use the default <code>css</code> export syntax since the tool doesn't support named imports.</p>
<h3><a class="anchor" id="autotoc_md31577"></a>
Styles outside of components</h3>
<p>The <code>css</code> tag from <code>styled-jsx/css</code> can be also used to define styles in your components files but outside of the component itself. This might help with keeping <code>render</code> methods smaller.</p>
<div class="fragment"><div class="line">import css from &#39;styled-jsx/css&#39;</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;button&gt;styled-jsx&lt;/button&gt;</div>
<div class="line">    &lt;style jsx&gt;{button}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const button = css`</div>
<div class="line">  button {</div>
<div class="line">    color: hotpink;</div>
<div class="line">  }</div>
<div class="line">`</div>
</div><!-- fragment --><p>Like in externals styles <code>css</code> doesn't work with dynamic styles. If you have dynamic parts you might want to place them inline inside of your component using a regular <code>&lt;style jsx&gt;</code> element.</p>
<h3><a class="anchor" id="autotoc_md31578"></a>
The <code>resolve</code> tag</h3>
<p>The <code>resolve</code> tag from <code>styled-jsx/css</code> can be used when you need to scope some CSS - for example, if you need to style nested components from the parent, such as the <code>Link</code> component in the example below.</p>
<p>It works by returning the generated scoped <code>className</code> and related <code>styles</code>.</p>
<div class="fragment"><div class="line">import React from &#39;react&#39;</div>
<div class="line">import Link from &#39;some-library&#39;</div>
<div class="line"> </div>
<div class="line">import css from &#39;styled-jsx/css&#39;</div>
<div class="line"> </div>
<div class="line">const { className, styles } = css.resolve`</div>
<div class="line">  a { color: green }</div>
<div class="line">`</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    {/* use the className */}</div>
<div class="line">    &lt;Link className={className}&gt;About&lt;/Link&gt;</div>
<div class="line"> </div>
<div class="line">    {/* render the styles for it */}</div>
<div class="line">    {styles}</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>The <code>resolve</code> tag also supports dynamic styles, via template string interpolation:</p>
<div class="fragment"><div class="line">import React from &#39;react&#39;</div>
<div class="line">import css from &#39;styled-jsx/css&#39;</div>
<div class="line"> </div>
<div class="line">function getLinkStyles(color) {</div>
<div class="line">  return css.resolve`</div>
<div class="line">    a { color: ${color} }</div>
<div class="line">  `</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export default props =&gt; {</div>
<div class="line">  const { className, styles } = getLinkStyles(props.theme.color)</div>
<div class="line"> </div>
<div class="line">  return (</div>
<div class="line">    &lt;div&gt;</div>
<div class="line">      &lt;Link className={className}&gt;About&lt;/Link&gt;</div>
<div class="line">      {styles}</div>
<div class="line">    &lt;/div&gt;</div>
<div class="line">  )</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31579"></a>
Using <code>resolve</code> as a Babel macro</h3>
<p>If you can't (or would rather not) make changes to your <code>.babelrc</code>, the <code>resolve</code> tag can be used as a Babel macro, thanks to the <a href="https://github.com/kentcdodds/babel-plugin-macros"><code>babel-plugin-macros</code></a> system.</p>
<p>To set this up, first of all, install <code>styled-jsx</code> and <code>babel-plugin-macros</code>:</p>
<div class="fragment"><div class="line">npm i --save styled-jsx</div>
<div class="line">npm i --save-dev babel-plugin-macros</div>
</div><!-- fragment --><p>Next, add <code>babel-plugin-macros</code> to your Babel configuration:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [&quot;babel-plugin-macros&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can then use <code>resolve</code> by importing it from <code>styled-jsx/macro</code>.</p>
<div class="fragment"><div class="line">import css from &#39;styled-jsx/macro&#39;</div>
<div class="line"> </div>
<div class="line">const { className, styles } = css.resolve`</div>
<div class="line">  a { color: green }</div>
<div class="line">`</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;Link className={className}&gt;About&lt;/Link&gt;</div>
<div class="line">    {styles}</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md31580"></a>
Usage with <a href="https://create-react-app.dev"><code>create-react-app</code></a></h4>
<p><a href="https://create-react-app.dev">Create React App</a> comes with <code>babel-plugin-macros</code> already installed, so the only thing that needs to be done is to install <code>styled-jsx</code>:</p>
<div class="fragment"><div class="line">npm i --save styled-jsx</div>
</div><!-- fragment --><p>Then <code>resolve</code> can be imported from <code>styled-jsx/macro</code> and used the same way as in the example in the <a href="https://github.com/vercel/styled-jsx/blob/main/readme.md#using-resolve-as-a-babel-macro">Using <code>resolve</code> as a Babel macro</a> section above.</p>
<h3><a class="anchor" id="autotoc_md31581"></a>
Styles in regular CSS files</h3>
<p>styled-jsx v3 comes with a webpack loader that lets you write styles in regular <code>css</code> files and consume them in React.</p>
<div class="fragment"><div class="line">import styles from &#39;../components/button/styles.css&#39;</div>
<div class="line"> </div>
<div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;button&gt;styled-jsx&lt;/button&gt;</div>
<div class="line">    &lt;style jsx&gt;{styles}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>To consume the styles in your component you can import them from your CSS file and render them using a <code>&lt;style jsx&gt;</code> tag. Remember to add the <code>global</code> prop if you want your styles to be global.</p>
<p>To use this feature you need to register the loader in your webpack config file, before <code>babel-loader</code> which will then transpile the styles via <code>styled-jsx/babel</code></p>
<div class="fragment"><div class="line">config: {</div>
<div class="line">  module: {</div>
<div class="line">    rules: [</div>
<div class="line">      {</div>
<div class="line">        test: /\.css$/,</div>
<div class="line">        use: [</div>
<div class="line">          {</div>
<div class="line">            loader: require(&#39;styled-jsx/webpack&#39;).loader,</div>
<div class="line">            options: {</div>
<div class="line">              type: &#39;scoped&#39;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The plugin accepts a <code>type</code> option to configure whether the styles should be <code>scoped</code>, <code>global</code> or <code>resolve</code> (see above). By default its values is set to <code>scoped</code>. <code>type</code> can also be a <code>function</code> which takes the <code>fileName</code> and the <code>fileNameQuery</code> that is being transpiled and must return a valid type.</p>
<div class="fragment"><div class="line">type validTypes = &#39;scoped&#39; | &#39;global&#39; | &#39;resolve&#39;</div>
<div class="line">type fileName = string</div>
<div class="line">type Options = {|</div>
<div class="line">  type: validTypes | ((fileName, options) =&gt; validTypes)</div>
<div class="line">|}</div>
</div><!-- fragment --><div class="fragment"><div class="line">import styles from &#39;./styles.css?type=global&#39;</div>
<div class="line"> </div>
<div class="line">// webpack</div>
<div class="line">config: {</div>
<div class="line">  module: {</div>
<div class="line">    rules: [</div>
<div class="line">      {</div>
<div class="line">        test: /\.css$/,</div>
<div class="line">        use: [</div>
<div class="line">          {</div>
<div class="line">            loader: require(&#39;styled-jsx/webpack&#39;).loader,</div>
<div class="line">            options: {</div>
<div class="line">              type: (fileName, options) =&gt; options.query.type || &#39;scoped&#39;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The type can also be set per individual CSS file via CSS comment:</p>
<div class="fragment"><div class="line">/* @styled-jsx=scoped */</div>
<div class="line"> </div>
<div class="line">button {</div>
<div class="line">  color: red;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The CSS comment option will override the one in the webpack configuration only for this specific file.</p>
<h4><a class="anchor" id="autotoc_md31582"></a>
Next.js</h4>
<p>Example of <code>next.config.js</code> to integrate <code>styled-jsx/webpack</code>:</p>
<div class="fragment"><div class="line">module.exports = {</div>
<div class="line">  webpack: (config, { defaultLoaders }) =&gt; {</div>
<div class="line">    config.module.rules.push({</div>
<div class="line">      test: /\.css$/,</div>
<div class="line">      use: [</div>
<div class="line">        defaultLoaders.babel,</div>
<div class="line">        {</div>
<div class="line">          loader: require(&#39;styled-jsx/webpack&#39;).loader,</div>
<div class="line">          options: {</div>
<div class="line">            type: &#39;scoped&#39;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      ]</div>
<div class="line">    })</div>
<div class="line"> </div>
<div class="line">    return config</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31583"></a>
CSS Preprocessing via Plugins</h1>
<p>Styles can be preprocessed via plugins.</p>
<p>Plugins are regular JavaScript modules that export a simple function with the following signature:</p>
<div class="fragment"><div class="line">function plugin(css: string, options: Object): string</div>
</div><!-- fragment --><p>Basically they accept a CSS string in input, optionally modify it and finally return it.</p>
<p>Plugins make it possible to use popular preprocessors like SASS, Less, Stylus, PostCSS or apply custom transformations to the styles at <b>compile time</b>.</p>
<p>To register a plugin add an option <code>plugins</code> for <code>styled-jsx/babel</code> to your <code>.babelrc</code>. <code>plugins</code> must be an array of module names or <em>full</em> paths for local plugins.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [</div>
<div class="line">    [</div>
<div class="line">      &quot;styled-jsx/babel&quot;,</div>
<div class="line">      {</div>
<div class="line">        &quot;plugins&quot;: [</div>
<div class="line">          &quot;my-styled-jsx-plugin-package&quot;,</div>
<div class="line">          &quot;/full/path/to/local/plugin&quot;</div>
<div class="line">        ]</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><details >
<summary >
Instructions to integrate with Next.js</summary>
<p>In order to register styled-jsx plugins in a Next.js app you need to create a custom .babelrc file:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;presets&quot;: [</div>
<div class="line">    [</div>
<div class="line">      &quot;next/babel&quot;,</div>
<div class="line">      {</div>
<div class="line">        &quot;styled-jsx&quot;: {</div>
<div class="line">          &quot;plugins&quot;: [&quot;styled-jsx-plugin-postcss&quot;]</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is a fairly new feature so make sure that you using a version of Next.js that supports passing options to <code>styled-jsx</code>.</p>
<p></p>
</details>
<p><br  />
</p>
<p>Plugins are applied in definition order left to right before styles are scoped.</p>
<p>In order to resolve local plugins paths you can use NodeJS' <a href="https://nodejs.org/api/globals.html#globals_require_resolve">require.resolve</a>.</p>
<p>N.B. when applying the plugins styled-jsx replaces template literals expressions with placeholders because otherwise CSS parsers would get invalid CSS E.g.</p>
<div class="fragment"><div class="line">/* `ExprNumber` is a number */</div>
<div class="line">%%styled-jsx-placeholder-ExprNumber%%</div>
</div><!-- fragment --><p><b>Plugins won't transform expressions</b> (eg. dynamic styles).</p>
<p>When publishing a plugin you may want to add the keywords: <code>styled-jsx</code> and <code>styled-jsx-plugin</code>. We also encourage you to use the following naming convention for your plugins:</p>
<div class="fragment"><div class="line">styled-jsx-plugin-&lt;your-plugin-name&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31584"></a>
Plugin options</h3>
<p>Users can set plugin options by registering a plugin as an array that contains the plugin path and an options object.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [</div>
<div class="line">    [</div>
<div class="line">      &quot;styled-jsx/babel&quot;,</div>
<div class="line">      {</div>
<div class="line">        &quot;plugins&quot;: [</div>
<div class="line">          [&quot;my-styled-jsx-plugin-package&quot;, { &quot;exampleOption&quot;: true }]</div>
<div class="line">        ],</div>
<div class="line">        &quot;sourceMaps&quot;: true</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each plugin receives a <code>options</code> object as second argument which contains the babel and user options:</p>
<div class="fragment"><div class="line">;(css, options) =&gt; {</div>
<div class="line">  /* ... */</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>options</code> object has the following shape:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  // user options go here</div>
<div class="line">  // eg. exampleOption: true</div>
<div class="line"> </div>
<div class="line">  // babel options</div>
<div class="line">  babel: {</div>
<div class="line">    sourceMaps: boolean,</div>
<div class="line">    vendorPrefixes: boolean,</div>
<div class="line">    isGlobal: boolean,</div>
<div class="line">    filename: ?string, // defined only when the filename option is passed to Babel, such as when using Babel CLI or Webpack</div>
<div class="line">    location: { // the original location of the CSS block in the JavaScript file</div>
<div class="line">      start: {</div>
<div class="line">        line: number,</div>
<div class="line">        column: number,</div>
<div class="line">      },</div>
<div class="line">      end: {</div>
<div class="line">        line: number,</div>
<div class="line">        column: number,</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31585"></a>
Example plugins</h3>
<p>The following plugins are proof of concepts/sample:</p>
<ul>
<li><a href="https://github.com/giuseppeg/styled-jsx-plugin-sass">styled-jsx-plugin-sass</a></li>
<li><a href="https://github.com/giuseppeg/styled-jsx-plugin-postcss">styled-jsx-plugin-postcss</a></li>
<li><a href="https://github.com/giuseppeg/styled-jsx-plugin-stylelint">styled-jsx-plugin-stylelint</a></li>
<li><a href="https://github.com/erasmo-marin/styled-jsx-plugin-less">styled-jsx-plugin-less</a></li>
<li><a href="https://github.com/omardelarosa/styled-jsx-plugin-stylus">styled-jsx-plugin-stylus</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md31586"></a>
Rendering in tests</h1>
<p>If you're using a tool such as Enzyme, you might want to avoid compiling your styles in test renders. In general, styled-jsx artifacts like <code>jsx-123</code> classnames and vendor prefixing are not direct concerns of your component, and they generate a lot of snapshot noise.</p>
<p>One option is to exclude the <code>styled-jsx/babel</code> plugin from the <code>test</code> environment using <code>env</code> in your Babel config (see <a href="https://babeljs.io/docs/en/options#config-merging-options">Config Merging options</a>).</p>
<p>But this can cause noise in your terminal output when rendering:</p>
<div class="fragment"><div class="line">console.error node_modules/react-dom/cjs/react-dom.development.js:527</div>
<div class="line">   Warning: Received `true` for a non-boolean attribute `jsx`.</div>
</div><!-- fragment --><p>The <code>styled-jsx/babel-test</code> solves this problem. It simply strips <code>jsx</code> attributes from all <code>&lt;style&gt;</code> tags. Be sure to target each environment with the appropriate plugin:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;env&quot;: {</div>
<div class="line">    &quot;production&quot;: {</div>
<div class="line">      &quot;plugins&quot;: [&quot;styled-jsx/babel&quot;]</div>
<div class="line">    },</div>
<div class="line">    &quot;development&quot;: {</div>
<div class="line">      &quot;plugins&quot;: [&quot;styled-jsx/babel&quot;]</div>
<div class="line">    },</div>
<div class="line">    &quot;test&quot;: {</div>
<div class="line">      &quot;plugins&quot;: [&quot;styled-jsx/babel-test&quot;]</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31587"></a>
styled-jsx/css in tests</h3>
<p>When using <code>styled-jsx/babel-test</code>, <code>styled-jsx/css</code> throws the following error:</p>
<div class="fragment"><div class="line">styled-jsx/css: if you are getting this error it means that your `css` tagged template literals were not transpiled.</div>
</div><!-- fragment --><p>to solve this issue you need to mock <code>styled-jsx/css</code>. You can find a guide at the following link <a href="https://kevinjalbert.com/jest-snapshots-reducing-styled-jsx-noise/">https://kevinjalbert.com/jest-snapshots-reducing-styled-jsx-noise/</a></p>
<h1><a class="anchor" id="autotoc_md31588"></a>
FAQ</h1>
<h2><a class="anchor" id="autotoc_md31589"></a>
Warning: unknown <code>jsx</code> prop on &lt;style&gt; tag</h2>
<p>If you get this warning it means that your styles were not compiled by styled-jsx.</p>
<p>Please take a look at your setup and make sure that everything is correct and that the styled-jsx transformation is ran by Babel.</p>
<h2><a class="anchor" id="autotoc_md31590"></a>
Can I return an array of components when using React 16?</h2>
<p>No, this feature is not supported. However we support React Fragments, which are available in React <code>16.2.0</code> and above.</p>
<div class="fragment"><div class="line">const StyledImage = ({ src, alt = &#39;&#39; }) =&gt; (</div>
<div class="line">  &lt;React.Fragment&gt;</div>
<div class="line">    &lt;img src={src} alt={alt} /&gt;</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      img {</div>
<div class="line">        max-width: 100%;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/React.Fragment&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31591"></a>
Styling third parties / child components from the parent</h2>
<p>When the component accepts a <code>className</code> (or ad-hoc) prop as a way to allow customizations then you can use the `resolve` tag from `styled-jsx/css`.</p>
<p>When the component doesn't accept any <code>className</code> or doesn't expose any API to customize the component, then your only option is to use <code>:global()</code> styles:</p>
<div class="fragment"><div class="line">export default () =&gt; (</div>
<div class="line">  &lt;div&gt;</div>
<div class="line">    &lt;ExternalComponent /&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      /* &quot;div&quot; will be prefixed, but &quot;.nested-element&quot; won&#39;t */</div>
<div class="line"> </div>
<div class="line">      div &gt; :global(.nested-element) {</div>
<div class="line">        color: red;</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/div&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><p>Please keep in mind that <code>:global()</code> styles will affect the entire subtree, so in many cases you may want to be careful and use the children (direct descendant) selector <code>&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md31592"></a>
Build a component library with styled-jsx</h2>
<p>There's an <a href="https://medium.com/@tomaszmularczyk89/guide-to-building-a-react-components-library-with-rollup-and-styled-jsx-694ec66bd2">article</a> explaining how to bundle React components with Rollup and styled-jsx as an external dependency.</p>
<h1><a class="anchor" id="autotoc_md31593"></a>
Syntax Highlighting</h1>
<p>When working with template literals a common drawback is missing syntax highlighting. The following editors currently have support for highlighting CSS inside <code>&lt;style jsx&gt;</code> elements.</p>
<p><em>If you have a solution for an editor not on the list</em> <b>please <a href="https://github.com/vercel/styled-jsx/pull/new/main">open a PR</a></b> <em>and let us now.</em></p>
<h2><a class="anchor" id="autotoc_md31594"></a>
Atom</h2>
<p>The <a href="https://github.com/gandm/language-babel"><code>language-babel</code></a> package for the <a href="https://atom.io/">Atom editor</a> has an option to <a href="https://github.com/gandm/language-babel#javascript-tagged-template-literal-grammar-extensions">extend the grammar for JavaScript tagged template literals</a>.</p>
<p>After <a href="https://github.com/gandm/language-babel#installation">installing the package</a> add the code below to the appropriate settings entry. In a few moments you should be blessed with proper CSS syntax highlighting. (<a href="https://github.com/gandm/language-babel/issues/324">source</a>)</p>
<div class="fragment"><div class="line">&quot;(?&lt;=&lt;style jsx&gt;{)|(?&lt;=&lt;style jsx global&gt;{)|(?&lt;=css)&quot;:source.css.styled</div>
</div><!-- fragment --><p><img src="https://cloud.githubusercontent.com/assets/2313237/22627258/6c97cb68-ebb7-11e6-82e1-60205f8b31e7.png" alt="babel-language settings entry" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md31595"></a>
Webstorm/Idea</h2>
<p>The IDE let you inject any language in place with <em>Inject language or reference</em> in an <em>Intention Actions</em> (default <em>alt+enter</em>). Simply perform the action in the string template and select CSS. You get full CSS highlighting and autocompletion and it will last until you close the IDE.</p>
<p>Additionally you can use language injection comments to enable all the IDE language features indefinitely using the language comment style:</p>
<div class="fragment"><div class="line">import { colors, spacing } from &#39;../theme&#39;</div>
<div class="line">import { invertColor } from &#39;../theme/utils&#39;</div>
<div class="line"> </div>
<div class="line">const Button = ({ children }) =&gt; (</div>
<div class="line">  &lt;button&gt;</div>
<div class="line">    {children}</div>
<div class="line"> </div>
<div class="line">    {/*language=CSS*/}</div>
<div class="line">    &lt;style jsx&gt;{`</div>
<div class="line">      button {</div>
<div class="line">        padding: ${spacing.medium};</div>
<div class="line">        background: ${colors.primary};</div>
<div class="line">        color: ${invertColor(colors.primary)};</div>
<div class="line">      }</div>
<div class="line">    `}&lt;/style&gt;</div>
<div class="line">  &lt;/button&gt;</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31596"></a>
Emmet</h2>
<p>If you're using Emmet you can add the following snippet to <code>~/emmet/snippets-styledjsx.json</code> This will allow you to expand <code>style-jsx</code> to a styled-jsx block.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;html&quot;: {</div>
<div class="line">    &quot;snippets&quot;: {</div>
<div class="line">      &quot;style-jsx&quot;: &quot;&lt;style jsx&gt;{`\n\t$1\n`}&lt;/style&gt;&quot;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31597"></a>
Syntax Highlighting <a href="https://marketplace.visualstudio.com/items?itemName=Divlo.vscode-styled-jsx-syntax">Visual Studio Code Extension</a></h2>
<p>Launch VS Code Quick Open (+P), paste the following command, and press enter.</p>
<div class="fragment"><div class="line">ext install Divlo.vscode-styled-jsx-syntax</div>
</div><!-- fragment --><p>If you use Stylus instead of plain CSS, install <a href="https://marketplace.visualstudio.com/items?itemName=samuelroy.vscode-styled-jsx-stylus">vscode-styled-jsx-stylus</a> or paste the command below.</p>
<div class="fragment"><div class="line">ext install vscode-styled-jsx-stylus</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31598"></a>
Autocomplete <a href="https://marketplace.visualstudio.com/items?itemName=Divlo.vscode-styled-jsx-languageserver">Visual Studio Code Extension</a></h2>
<p>Launch VS Code Quick Open (+P), paste the following command, and press enter.</p>
<div class="fragment"><div class="line">ext install Divlo.vscode-styled-jsx-languageserver</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31599"></a>
Vim</h2>
<p>Install <a href="https://github.com/alampros/vim-styled-jsx">vim-styled-jsx</a> with your plugin manager of choice.</p>
<h1><a class="anchor" id="autotoc_md31600"></a>
ESLint</h1>
<p>If you're using <code>eslint-plugin-import</code>, the <code>css</code> import will generate errors, being that it's a "magic" import (not listed in package.json). To avoid these, simply add the following line to your eslint configuration:</p>
<div class="fragment"><div class="line">&quot;settings&quot;: {&quot;import/core-modules&quot;: [&quot;styled-jsx/css&quot;] }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31601"></a>
TypeScript</h1>
<p>If you're using TypeScript, then in order to allow <code>&lt;style jsx&gt;</code> tags to be properly understood by it, create a file named "styled-jsx.d.ts" anywhere within your project containing the following, or add this line to the top of any single existing .ts file within your project:</p>
<div class="fragment"><div class="line">/// &lt;reference types=&quot;styled-jsx&quot; /&gt;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>If you're using babel to transform styled-jsx code with TypeScript, you need to specify <code>"jsx": "preserve"</code> in your tsconfig.json to keep the original JSX and let babel parse and transform with styled-jsx babel plugin. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md31602"></a>
Credits</h1>
<ul>
<li><b>Pedram Emrouznejad</b> (<a href="https://github.com/rijs/fullstack">rijs</a>) suggested attribute selectors over my initial class prefixing idea.</li>
<li><b>Sunil Pai</b> (<a href="https://github.com/threepointone/glamor">glamor</a>) inspired the use of <code>murmurhash2</code> (minimal and fast hashing) and an efficient style injection logic.</li>
<li><b>Sultan Tarimo</b> built <a href="https://github.com/thysultan">stylis.js</a>, a super fast and tiny CSS parser and compiler.</li>
<li><b>Max Stoiber</b> (<a href="https://github.com/styled-components">styled-components</a>) proved the value of retaining the familiarity of CSS syntax and pointed me to the very efficient <a href="https://github.com/thysultan/stylis.js">stylis</a> compiler (which we forked to very efficiently append attribute selectors to the user's css)</li>
<li><b>Yehuda Katz</b> (<a href="https://github.com/emberjs">ember</a>) convinced me on Twitter to transpile CSS as an alternative to CSS-in-JS.</li>
<li><b>Evan You</b> (<a href="https://github.com/vuejs">vuejs</a>) discussed his Vue.js CSS transformation with me.</li>
<li><b>Henry Zhu</b> (<a href="https://github.com/babel">babel</a>) helpfully pointed me to some important areas of the babel plugin API.</li>
</ul>
<h1><a class="anchor" id="autotoc_md31603"></a>
Authors</h1>
<ul>
<li>Guillermo Rauch (<a href="https://twitter.com/rauchg">@rauchg</a>) - <a href="https://vercel.com">Vercel</a></li>
<li>Naoyuki Kanezawa (<a href="https://twitter.com/nkzawa">@nkzawa</a>) - <a href="https://vercel.com">Vercel</a></li>
<li>Giuseppe Gurgone (<a href="https://twitter.com/giuseppegurgone">@giuseppegurgone</a>) </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_07435cae1c2f77b9a7c4357e39ae4711.html">styled-jsx</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
