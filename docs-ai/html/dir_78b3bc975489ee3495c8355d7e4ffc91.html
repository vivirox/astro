<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/expect-type Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_78b3bc975489ee3495c8355d7e4ffc91.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">expect-type Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://github.com/mmkal/expect-type/actions/workflows/ci.yml"><img src="https://github.com/mmkal/expect-type/actions/workflows/ci.yml/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a> <img src="https://img.shields.io/npm/dt/expect-type" alt="npm" class="inline"/> <a href="https://x.com/mmkalmmkal"><img src="https://img.shields.io/twitter/follow/mmkal" alt="X (formerly Twitter) Follow" class="inline"/></a></p>
<p>Compile-time tests for types. Useful to make sure types don't regress into being overly permissive as changes go in over time.</p>
<p>Similar to <code>expect</code>, but with type-awareness. Gives you access to several type-matchers that let you make assertions about the form of a reference or generic type parameter.</p>
<div class="fragment"><div class="line">import {expectTypeOf} from &#39;expect-type&#39;</div>
<div class="line">import {foo, bar} from &#39;../foo&#39;</div>
<div class="line"> </div>
<div class="line">// make sure `foo` has type {a: number}</div>
<div class="line">expectTypeOf(foo).toMatchTypeOf&lt;{a: number}&gt;()</div>
<div class="line"> </div>
<div class="line">// make sure `bar` is a function taking a string:</div>
<div class="line">expectTypeOf(bar).parameter(0).toBeString()</div>
<div class="line">expectTypeOf(bar).returns.not.toBeAny()</div>
</div><!-- fragment --><p>It can be used in your existing test files (and is actually <a href="https://vitest.dev/guide/testing-types">built in to vitest</a>). Or it can be used in any other type-checked file you'd like - it's built into existing tooling with no dependencies. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time - they'll appear in your IDE and when you run <code>tsc</code>.</p>
<p>See below for lots more examples.</p>
<h1><a class="anchor" id="autotoc_md14862"></a>
Contents</h1>
<ul>
<li>Contents</li>
<li>Installation and usage</li>
<li><a class="el" href="/Users/vivi/astro/node_modules/inquirer/README.md#documentation">Documentation</a><ul>
<li><a class="el" href="md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g.html#features">Features</a></li>
<li>Why is my assertion failing?</li>
<li>Where is `.toMatchTypeOf`?</li>
<li>Internal type helpers</li>
<li>Error messages<ul>
<li>Concrete &quot;expected&quot; objects vs type arguments</li>
</ul>
</li>
<li>Overloaded functions</li>
<li>Within test frameworks</li>
<li>Vitest<ul>
<li>Jest &amp; `eslint-plugin-jest`</li>
</ul>
</li>
<li>Limitations</li>
</ul>
</li>
<li>Similar projects<ul>
<li>Comparison</li>
</ul>
</li>
<li>TypeScript backwards-compatibility</li>
<li><a class="el" href="md_node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g.html#contributing">Contributing</a><ul>
<li>Documentation of limitations through tests</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md14863"></a>
Installation and usage</h1>
<div class="fragment"><div class="line">npm install expect-type --save-dev</div>
</div><!-- fragment --><div class="fragment"><div class="line">import {expectTypeOf} from &#39;expect-type&#39;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14864"></a>
Documentation</h1>
<p>The <code>expectTypeOf</code> method takes a single argument or a generic type parameter. Neither it nor the functions chained off its return value have any meaningful runtime behaviour. The assertions you write will be <em>compile-time</em> errors if they don't hold true.</p>
<h2><a class="anchor" id="autotoc_md14865"></a>
Features</h2>
<p>Check an object's type with <code>.toEqualTypeOf</code>:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code> can check that two concrete objects have equivalent types (note: when these assertions <em>fail</em>, the error messages can be less informative vs the generic type argument syntax above - see error messages docs):</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: 1})</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code> succeeds for objects with different values, but the same type:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: 2})</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code> fails on excess properties:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1, b: 1}).toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p>To allow for extra properties on an object type, use <code>.toMatchObjectType</code>. This is a strict check, but only on the subset of keys that are in the expected type:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1, b: 1}).toMatchObjectType&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p><code>.toMatchObjectType</code> can check partial matches on deeply nested objects:</p>
<div class="fragment"><div class="line">const user = {</div>
<div class="line">  email: &#39;a@b.com&#39;,</div>
<div class="line">  name: &#39;John Doe&#39;,</div>
<div class="line">  address: {street: &#39;123 2nd St&#39;, city: &#39;New York&#39;, zip: &#39;10001&#39;, state: &#39;NY&#39;, country: &#39;USA&#39;},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(user).toMatchObjectType&lt;{name: string; address: {city: string}}&gt;()</div>
</div><!-- fragment --><p>To check that a type extends another type, use <code>.toExtend</code>:</p>
<div class="fragment"><div class="line">expectTypeOf(&#39;some string&#39;).toExtend&lt;string | boolean&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toExtend&lt;{b: number}&gt;()</div>
</div><!-- fragment --><p><code>.toExtend</code> can be used with object types, but <code>.toMatchObjectType</code> is usually a better choice when dealing with objects, since it's stricter:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1, b: 2}).toExtend&lt;{a: number}&gt;() // avoid this</div>
<div class="line">expectTypeOf({a: 1, b: 2}).toMatchObjectType&lt;{a: number}&gt;() // prefer this</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code>, <code>.toMatchObjectType</code>, and <code>.toExtend</code> all fail on missing properties:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: number; b: number}&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toMatchObjectType&lt;{a: number; b: number}&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toExtend&lt;{a: number; b: number}&gt;()</div>
</div><!-- fragment --><p>Another example of the difference between <code>.toExtend</code>, <code>.toMatchObjectType</code>, and <code>.toEqualTypeOf</code>. <code>.toExtend</code> can be used for "is-a" relationships:</p>
<div class="fragment"><div class="line">type Fruit = {type: &#39;Fruit&#39;; edible: boolean}</div>
<div class="line">type Apple = {type: &#39;Fruit&#39;; name: &#39;Apple&#39;; edible: true}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Apple&gt;().toExtend&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - the `editable` property isn&#39;t an exact match. In `Apple`, it&#39;s `true`, which extends `boolean`, but they&#39;re not identical.</div>
<div class="line">expectTypeOf&lt;Apple&gt;().toMatchObjectType&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - Apple is not an identical type to Fruit, it&#39;s a subtype</div>
<div class="line">expectTypeOf&lt;Apple&gt;().toEqualTypeOf&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - Apple is a Fruit, but not vice versa</div>
<div class="line">expectTypeOf&lt;Fruit&gt;().toExtend&lt;Apple&gt;()</div>
</div><!-- fragment --><p>Assertions can be inverted with <code>.not</code>:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).not.toExtend&lt;{b: 1}&gt;()</div>
<div class="line">expectTypeOf({a: 1}).not.toMatchObjectType&lt;{b: 1}&gt;()</div>
</div><!-- fragment --><p><code>.not</code> can be easier than relying on <code>// @ts-expect-error</code>:</p>
<div class="fragment"><div class="line">type Fruit = {type: &#39;Fruit&#39;; edible: boolean}</div>
<div class="line">type Apple = {type: &#39;Fruit&#39;; name: &#39;Apple&#39;; edible: true}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Apple&gt;().toExtend&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Fruit&gt;().not.toExtend&lt;Apple&gt;()</div>
<div class="line">expectTypeOf&lt;Apple&gt;().not.toEqualTypeOf&lt;Fruit&gt;()</div>
</div><!-- fragment --><p>Catch any/unknown/never types:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;unknown&gt;().toBeUnknown()</div>
<div class="line">expectTypeOf&lt;any&gt;().toBeAny()</div>
<div class="line">expectTypeOf&lt;never&gt;().toBeNever()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf&lt;never&gt;().toBeNumber()</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code> distinguishes between deeply-nested <code>any</code> and <code>unknown</code> properties:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{deeply: {nested: any}}&gt;().not.toEqualTypeOf&lt;{deeply: {nested: unknown}}&gt;()</div>
</div><!-- fragment --><p>You can test for basic JavaScript types:</p>
<div class="fragment"><div class="line">expectTypeOf(() =&gt; 1).toBeFunction()</div>
<div class="line">expectTypeOf({}).toBeObject()</div>
<div class="line">expectTypeOf([]).toBeArray()</div>
<div class="line">expectTypeOf(&#39;&#39;).toBeString()</div>
<div class="line">expectTypeOf(1).toBeNumber()</div>
<div class="line">expectTypeOf(true).toBeBoolean()</div>
<div class="line">expectTypeOf(() =&gt; {}).returns.toBeVoid()</div>
<div class="line">expectTypeOf(Promise.resolve(123)).resolves.toBeNumber()</div>
<div class="line">expectTypeOf(Symbol(1)).toBeSymbol()</div>
<div class="line">expectTypeOf(1n).toBeBigInt()</div>
</div><!-- fragment --><p><code>.toBe...</code> methods allow for types that extend the expected type:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;number&gt;().toBeNumber()</div>
<div class="line">expectTypeOf&lt;1&gt;().toBeNumber()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;any[]&gt;().toBeArray()</div>
<div class="line">expectTypeOf&lt;number[]&gt;().toBeArray()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;string&gt;().toBeString()</div>
<div class="line">expectTypeOf&lt;&#39;foo&#39;&gt;().toBeString()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;boolean&gt;().toBeBoolean()</div>
<div class="line">expectTypeOf&lt;true&gt;().toBeBoolean()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;bigint&gt;().toBeBigInt()</div>
<div class="line">expectTypeOf&lt;0n&gt;().toBeBigInt()</div>
</div><!-- fragment --><p><code>.toBe...</code> methods protect against <code>any</code>:</p>
<div class="fragment"><div class="line">const goodIntParser = (s: string) =&gt; Number.parseInt(s, 10)</div>
<div class="line">const badIntParser = (s: string) =&gt; JSON.parse(s) // uh-oh - works at runtime if the input is a number, but return &#39;any&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(goodIntParser).returns.toBeNumber()</div>
<div class="line">// @ts-expect-error - if you write a test like this, `.toBeNumber()` will let you know your implementation returns `any`.</div>
<div class="line">expectTypeOf(badIntParser).returns.toBeNumber()</div>
</div><!-- fragment --><p>Nullable types:</p>
<div class="fragment"><div class="line">expectTypeOf(undefined).toBeUndefined()</div>
<div class="line">expectTypeOf(undefined).toBeNullable()</div>
<div class="line">expectTypeOf(undefined).not.toBeNull()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(null).toBeNull()</div>
<div class="line">expectTypeOf(null).toBeNullable()</div>
<div class="line">expectTypeOf(null).not.toBeUndefined()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;1 | undefined&gt;().toBeNullable()</div>
<div class="line">expectTypeOf&lt;1 | null&gt;().toBeNullable()</div>
<div class="line">expectTypeOf&lt;1 | undefined | null&gt;().toBeNullable()</div>
</div><!-- fragment --><p>More <code>.not</code> examples:</p>
<div class="fragment"><div class="line">expectTypeOf(1).not.toBeUnknown()</div>
<div class="line">expectTypeOf(1).not.toBeAny()</div>
<div class="line">expectTypeOf(1).not.toBeNever()</div>
<div class="line">expectTypeOf(1).not.toBeNull()</div>
<div class="line">expectTypeOf(1).not.toBeUndefined()</div>
<div class="line">expectTypeOf(1).not.toBeNullable()</div>
<div class="line">expectTypeOf(1).not.toBeBigInt()</div>
</div><!-- fragment --><p>Detect assignability of unioned types:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;number&gt;().toExtend&lt;string | number&gt;()</div>
<div class="line">expectTypeOf&lt;string | number&gt;().not.toExtend&lt;number&gt;()</div>
</div><!-- fragment --><p>Use <code>.extract</code> and <code>.exclude</code> to narrow down complex union types:</p>
<div class="fragment"><div class="line">type ResponsiveProp&lt;T&gt; = T | T[] | {xs?: T; sm?: T; md?: T}</div>
<div class="line">const getResponsiveProp = &lt;T&gt;(_props: T): ResponsiveProp&lt;T&gt; =&gt; ({})</div>
<div class="line">type CSSProperties = {margin?: string; padding?: string}</div>
<div class="line"> </div>
<div class="line">const cssProperties: CSSProperties = {margin: &#39;1px&#39;, padding: &#39;2px&#39;}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .exclude&lt;unknown[]&gt;()</div>
<div class="line">  .exclude&lt;{xs?: unknown}&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;CSSProperties&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .extract&lt;unknown[]&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;CSSProperties[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .extract&lt;{xs?: any}&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;{xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;ResponsiveProp&lt;number&gt;&gt;().exclude&lt;number | number[]&gt;().toHaveProperty(&#39;sm&#39;)</div>
<div class="line">expectTypeOf&lt;ResponsiveProp&lt;number&gt;&gt;().exclude&lt;number | number[]&gt;().not.toHaveProperty(&#39;xxl&#39;)</div>
</div><!-- fragment --><p><code>.extract</code> and <code>.exclude</code> return never if no types remain after exclusion:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line">type Customer = Person &amp; {customerId: string}</div>
<div class="line">type Employee = Person &amp; {employeeId: string}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Customer | Employee&gt;().extract&lt;{foo: string}&gt;().toBeNever()</div>
<div class="line">expectTypeOf&lt;Customer | Employee&gt;().exclude&lt;{name: string}&gt;().toBeNever()</div>
</div><!-- fragment --><p>Use <code>.pick</code> to pick a set of properties from an object:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Person&gt;().pick&lt;&#39;name&#39;&gt;().toEqualTypeOf&lt;{name: string}&gt;()</div>
</div><!-- fragment --><p>Use <code>.omit</code> to remove a set of properties from an object:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Person&gt;().omit&lt;&#39;name&#39;&gt;().toEqualTypeOf&lt;{age: number}&gt;()</div>
</div><!-- fragment --><p>Make assertions about object properties:</p>
<div class="fragment"><div class="line">const obj = {a: 1, b: &#39;&#39;}</div>
<div class="line"> </div>
<div class="line">// check that properties exist (or don&#39;t) with `.toHaveProperty`</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;)</div>
<div class="line">expectTypeOf(obj).not.toHaveProperty(&#39;c&#39;)</div>
<div class="line"> </div>
<div class="line">// check types of properties</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;).toBeNumber()</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;b&#39;).toBeString()</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;).not.toBeString()</div>
</div><!-- fragment --><p><code>.toEqualTypeOf</code> can be used to distinguish between functions:</p>
<div class="fragment"><div class="line">type NoParam = () =&gt; void</div>
<div class="line">type HasParam = (s: string) =&gt; void</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;NoParam&gt;().not.toEqualTypeOf&lt;HasParam&gt;()</div>
</div><!-- fragment --><p>But often it's preferable to use <code>.parameters</code> or <code>.returns</code> for more specific function assertions:</p>
<div class="fragment"><div class="line">type NoParam = () =&gt; void</div>
<div class="line">type HasParam = (s: string) =&gt; void</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;NoParam&gt;().parameters.toEqualTypeOf&lt;[]&gt;()</div>
<div class="line">expectTypeOf&lt;NoParam&gt;().returns.toBeVoid()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;HasParam&gt;().parameters.toEqualTypeOf&lt;[string]&gt;()</div>
<div class="line">expectTypeOf&lt;HasParam&gt;().returns.toBeVoid()</div>
</div><!-- fragment --><p>Up to ten overloads will produce union types for <code>.parameters</code> and <code>.returns</code>:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.not.toEqualTypeOf&lt;[number]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.toEqualTypeOf&lt;[number] | [bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().returns.toEqualTypeOf&lt;number[] | bigint[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameter(0).toEqualTypeOf&lt;number | bigint&gt;()</div>
</div><!-- fragment --><p>Note that these aren't exactly like TypeScript's built-in Parameters&lt;...&gt; and ReturnType&lt;...&gt;:</p>
<p>The TypeScript builtins simply choose a single overload (see the Overloaded functions section for more information)</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// overload using `number` is ignored!</div>
<div class="line">expectTypeOf&lt;Parameters&lt;Factorize&gt;&gt;().toEqualTypeOf&lt;[bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;ReturnType&lt;Factorize&gt;&gt;().toEqualTypeOf&lt;bigint[]&gt;()</div>
</div><!-- fragment --><p>More examples of ways to work with functions - parameters using <code>.parameter(n)</code> or <code>.parameters</code>, and return values using <code>.returns</code>:</p>
<div class="fragment"><div class="line">const f = (a: number) =&gt; [a, a]</div>
<div class="line"> </div>
<div class="line">expectTypeOf(f).toBeFunction()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(f).toBeCallableWith(1)</div>
<div class="line">expectTypeOf(f).not.toBeAny()</div>
<div class="line">expectTypeOf(f).returns.not.toBeAny()</div>
<div class="line">expectTypeOf(f).returns.toEqualTypeOf([1, 2])</div>
<div class="line">expectTypeOf(f).returns.toEqualTypeOf([1, 2, 3])</div>
<div class="line">expectTypeOf(f).parameter(0).not.toEqualTypeOf(&#39;1&#39;)</div>
<div class="line">expectTypeOf(f).parameter(0).toEqualTypeOf(1)</div>
<div class="line">expectTypeOf(1).parameter(0).toBeNever()</div>
<div class="line"> </div>
<div class="line">const twoArgFunc = (a: number, b: string) =&gt; ({a, b})</div>
<div class="line"> </div>
<div class="line">expectTypeOf(twoArgFunc).parameters.toEqualTypeOf&lt;[number, string]&gt;()</div>
</div><!-- fragment --><p><code>.toBeCallableWith</code> allows for overloads. You can also use it to narrow down the return type for given input parameters.:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6)</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6n)</div>
</div><!-- fragment --><p><code>.toBeCallableWith</code> returns a type that can be used to narrow down the return type for given input parameters.:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6).returns.toEqualTypeOf&lt;number[]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6n).returns.toEqualTypeOf&lt;bigint[]&gt;()</div>
</div><!-- fragment --><p><code>.toBeCallableWith</code> can be used to narrow down the parameters of a function:</p>
<div class="fragment"><div class="line">type Delete = {</div>
<div class="line">  (path: string): void</div>
<div class="line">  (paths: string[], options?: {force: boolean}): void</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameters.toEqualTypeOf&lt;[string]&gt;()</div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;], {force: true})</div>
<div class="line">  .parameters.toEqualTypeOf&lt;[string[], {force: boolean}?]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameter(0).toBeString()</div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameter(1).toBeUndefined()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;])</div>
<div class="line">  .parameter(0)</div>
<div class="line">  .toEqualTypeOf&lt;string[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;])</div>
<div class="line">  .parameter(1)</div>
<div class="line">  .toEqualTypeOf&lt;{force: boolean} | undefined&gt;()</div>
</div><!-- fragment --><p>You can't use <code>.toBeCallableWith</code> with <code>.not</code> - you need to use ts-expect-error::</p>
<div class="fragment"><div class="line">const f = (a: number) =&gt; [a, a]</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf(f).toBeCallableWith(&#39;foo&#39;)</div>
</div><!-- fragment --><p>Use <code>.map</code> to transform types:</p>
<p>This can be useful for generic functions or complex types which you can't access via <code>.toBeCallableWith</code>, <code>.toHaveProperty</code> etc. The callback function isn't called at runtime, which can make this a useful way to get complex inferred types without worrying about running code.</p>
<div class="fragment"><div class="line">const capitalize = &lt;S extends string&gt;(input: S) =&gt;</div>
<div class="line">  (input.slice(0, 1).toUpperCase() + input.slice(1)) as Capitalize&lt;S&gt;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(capitalize)</div>
<div class="line">  .map(fn =&gt; fn(&#39;hello world&#39;))</div>
<div class="line">  .toEqualTypeOf&lt;&#39;Hello world&#39;&gt;()</div>
</div><!-- fragment --><p>You can also check type guards &amp; type assertions:</p>
<div class="fragment"><div class="line">const assertNumber = (v: any): asserts v is number =&gt; {</div>
<div class="line">  if (typeof v !== &#39;number&#39;) {</div>
<div class="line">    throw new TypeError(&#39;Nope !&#39;)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(assertNumber).asserts.toBeNumber()</div>
<div class="line"> </div>
<div class="line">const isString = (v: any): v is string =&gt; typeof v === &#39;string&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(isString).guards.toBeString()</div>
<div class="line"> </div>
<div class="line">const isBigInt = (value: any): value is bigint =&gt; typeof value === &#39;bigint&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(isBigInt).guards.toBeBigInt()</div>
</div><!-- fragment --><p>Assert on constructor parameters:</p>
<div class="fragment"><div class="line">expectTypeOf(Date).toBeConstructibleWith(&#39;1970&#39;)</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith(0)</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith(new Date())</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(Date).constructorParameters.toEqualTypeOf&lt;</div>
<div class="line">  | []</div>
<div class="line">  | [value: string | number]</div>
<div class="line">  | [value: string | number | Date]</div>
<div class="line">  | [</div>
<div class="line">      year: number,</div>
<div class="line">      monthIndex: number,</div>
<div class="line">      date?: number | undefined,</div>
<div class="line">      hours?: number | undefined,</div>
<div class="line">      minutes?: number | undefined,</div>
<div class="line">      seconds?: number | undefined,</div>
<div class="line">      ms?: number | undefined,</div>
<div class="line">    ]</div>
<div class="line">&gt;()</div>
</div><!-- fragment --><p>Constructor overloads:</p>
<div class="fragment"><div class="line">class DBConnection {</div>
<div class="line">  constructor()</div>
<div class="line">  constructor(connectionString: string)</div>
<div class="line">  constructor(options: {host: string; port: number})</div>
<div class="line">  constructor(..._: unknown[]) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith()</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith(&#39;localhost&#39;)</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith({host: &#39;localhost&#39;, port: 1234})</div>
<div class="line">// @ts-expect-error - as when calling `new DBConnection(...)` you can&#39;t actually use the `(...args: unknown[])` overlaod, it&#39;s purely for the implementation.</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith(1, 2)</div>
</div><!-- fragment --><p>Check function <code>this</code> parameters:</p>
<div class="fragment"><div class="line">function greet(this: {name: string}, message: string) {</div>
<div class="line">  return `Hello ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(greet).thisParameter.toEqualTypeOf&lt;{name: string}&gt;()</div>
</div><!-- fragment --><p>Distinguish between functions with different <code>this</code> parameters:</p>
<div class="fragment"><div class="line">function greetFormal(this: {title: string; name: string}, message: string) {</div>
<div class="line">  return `Dear ${this.title} ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function greetCasual(this: {name: string}, message: string) {</div>
<div class="line">  return `Hi ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(greetFormal).not.toEqualTypeOf(greetCasual)</div>
</div><!-- fragment --><p>Class instance types:</p>
<div class="fragment"><div class="line">expectTypeOf(Date).instance.toHaveProperty(&#39;toISOString&#39;)</div>
</div><!-- fragment --><p>Promise resolution types can be checked with <code>.resolves</code>:</p>
<div class="fragment"><div class="line">const asyncFunc = async () =&gt; 123</div>
<div class="line"> </div>
<div class="line">expectTypeOf(asyncFunc).returns.resolves.toBeNumber()</div>
</div><!-- fragment --><p>Array items can be checked with <code>.items</code>:</p>
<div class="fragment"><div class="line">expectTypeOf([1, 2, 3]).items.toBeNumber()</div>
<div class="line">expectTypeOf([1, 2, 3]).items.not.toBeString()</div>
</div><!-- fragment --><p>You can also compare arrays directly:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;any[]&gt;().not.toEqualTypeOf&lt;number[]&gt;()</div>
</div><!-- fragment --><p>Check that functions never return:</p>
<div class="fragment"><div class="line">const thrower = () =&gt; {</div>
<div class="line">  throw new Error(&#39;oh no&#39;)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(thrower).returns.toBeNever()</div>
</div><!-- fragment --><p>Generics can be used rather than references:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{a: string}&gt;().not.toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p>Distinguish between missing/null/optional properties:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{a: number}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{a: number | undefined}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number | null}&gt;().not.toEqualTypeOf&lt;{a: number | null}&gt;()</div>
<div class="line">expectTypeOf&lt;{a: {b?: number}}&gt;().not.toEqualTypeOf&lt;{a: {}}&gt;()</div>
</div><!-- fragment --><p>Detect the difference between regular and <code>readonly</code> properties:</p>
<div class="fragment"><div class="line">type A1 = {readonly a: string; b: string}</div>
<div class="line">type E1 = {a: string; b: string}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;A1&gt;().toExtend&lt;E1&gt;()</div>
<div class="line">expectTypeOf&lt;A1&gt;().not.toEqualTypeOf&lt;E1&gt;()</div>
<div class="line"> </div>
<div class="line">type A2 = {a: string; b: {readonly c: string}}</div>
<div class="line">type E2 = {a: string; b: {c: string}}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;A2&gt;().toExtend&lt;E2&gt;()</div>
<div class="line">expectTypeOf&lt;A2&gt;().not.toEqualTypeOf&lt;E2&gt;()</div>
</div><!-- fragment --><p>Distinguish between classes with different constructors:</p>
<div class="fragment"><div class="line">class A {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(a: 1) {</div>
<div class="line">    this.value = a</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">class B {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(b: 2) {</div>
<div class="line">    this.value = b</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;typeof A&gt;().not.toEqualTypeOf&lt;typeof B&gt;()</div>
<div class="line"> </div>
<div class="line">class C {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(c: 1) {</div>
<div class="line">    this.value = c</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;typeof A&gt;().toEqualTypeOf&lt;typeof C&gt;()</div>
</div><!-- fragment --><p>Known limitation: Intersection types can cause issues with <code>toEqualTypeOf</code>:</p>
<div class="fragment"><div class="line">// @ts-expect-error the following line doesn&#39;t compile, even though the types are arguably the same.</div>
<div class="line">// See https://github.com/mmkal/expect-type/pull/21</div>
<div class="line">expectTypeOf&lt;{a: 1} &amp; {b: 2}&gt;().toEqualTypeOf&lt;{a: 1; b: 2}&gt;()</div>
</div><!-- fragment --><p>To workaround for simple cases, you can use a mapped type:</p>
<div class="fragment"><div class="line">type Simplify&lt;T&gt; = {[K in keyof T]: T[K]}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Simplify&lt;{a: 1} &amp; {b: 2}&gt;&gt;().toEqualTypeOf&lt;{a: 1; b: 2}&gt;()</div>
</div><!-- fragment --><p>But this won't work if the nesting is deeper in the type. For these situations, you can use the <code>.branded</code> helper. Note that this comes at a performance cost, and can cause the compiler to 'give up' if used with excessively deep types, so use sparingly. This helper is under <code>.branded</code> because it deeply transforms the Actual and Expected types into a pseudo-AST:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().branded.toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
</div><!-- fragment --><p>Be careful with <code>.branded</code> for very deep or complex types, though. If possible you should find a way to simplify your test to avoid needing to use it:</p>
<div class="fragment"><div class="line">// This *should* result in an error, but the &quot;branding&quot; mechanism produces too large a type and TypeScript just gives up! https://github.com/microsoft/TypeScript/issues/50670</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 1&gt;().branded.toEqualTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 2&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error the non-branded implementation catches the error as expected.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 1&gt;().toEqualTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 2&gt;()</div>
</div><!-- fragment --><p>So, if you have an extremely deep type that ALSO has an intersection in it, you're out of luck and this library won't be able to test your type properly:</p>
<div class="fragment"><div class="line">// @ts-expect-error this fails, but it should succeed.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; {a: 1} &amp; {b: 2}&gt;().toEqualTypeOf&lt;</div>
<div class="line">  () =&gt; () =&gt; () =&gt; () =&gt; {a: 1; b: 2}</div>
<div class="line">&gt;()</div>
<div class="line"> </div>
<div class="line">// this succeeds, but it should fail.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; {a: 1} &amp; {b: 2}&gt;().branded.toEqualTypeOf&lt;</div>
<div class="line">  () =&gt; () =&gt; () =&gt; () =&gt; {a: 1; c: 2}</div>
<div class="line">&gt;()</div>
</div><!-- fragment --><p>Another limitation: passing <code>this</code> references to <code>expectTypeOf</code> results in errors.:</p>
<div class="fragment"><div class="line">class B {</div>
<div class="line">  b = &#39;b&#39;</div>
<div class="line"> </div>
<div class="line">  foo() {</div>
<div class="line">    // @ts-expect-error</div>
<div class="line">    expectTypeOf(this).toEqualTypeOf(this)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Instead of the above, try something like this:</div>
<div class="line">expectTypeOf(B).instance.toEqualTypeOf&lt;{b: string; foo: () =&gt; void}&gt;()</div>
</div><!-- fragment --><p>Overloads limitation for TypeScript &lt;5.3: Due to a <a href="https://github.com/microsoft/TypeScript/issues/28867">TypeScript bug fixed in 5.3</a>, overloaded functions which include an overload resembling <code>(...args: unknown[]) =&gt; unknown</code> will exclude <code>unknown[]</code> from <code>.parameters</code> and exclude <code>unknown</code> from <code>.returns</code>:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (...args: unknown[]): unknown</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.toEqualTypeOf&lt;[number] | [bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().returns.toEqualTypeOf&lt;number[] | bigint[]&gt;()</div>
</div><!-- fragment --><p>This overload, however, allows any input and returns an unknown output anyway, so it's not very useful. If you are worried about this for some reason, you'll have to update TypeScript to 5.3+.</p>
<h2><a class="anchor" id="autotoc_md14866"></a>
Why is my assertion failing?</h2>
<p>For complex types, an assertion might fail when it should if the <code>Actual</code> type contains a deeply-nested intersection type but the <code>Expected</code> doesn't. In these cases you can use <code>.branded</code> as described above:</p>
<div class="fragment"><div class="line">// @ts-expect-error this unfortunately fails - a TypeScript limitation prevents making this pass without a big perf hit</div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().branded.toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14867"></a>
Where is <code>.toMatchTypeOf</code>?</h2>
<p>The <code>.toMatchTypeOf</code> method is deprecated, in favour of <code>.toMatchObjectType</code> (when strictly checking against an object type with a subset of keys), or <code>.toExtend</code> (when checking for "is-a" relationships). There are no foreseeable plans to remove <code>.toMatchTypeOf</code>, but there's no reason to continue using it - <code>.toMatchObjectType</code> is stricter, and <code>.toExtend</code> is identical.</p>
<h2><a class="anchor" id="autotoc_md14868"></a>
Internal type helpers</h2>
<p>ðŸš§ This library also exports some helper types for performing boolean operations on types, checking extension/equality in various ways, branding types, and checking for various special types like <code>never</code>, <code>any</code>, <code>unknown</code>. Use at your own risk! Nothing is stopping you from using these beyond this warning:</p>
<p>&gt;All internal types that are not documented here are <em>not</em> part of the supported API surface, and may be renamed, modified, or removed, without warning or documentation in release notes.</p>
<p>For a dedicated internal type library, feel free to look at the <a href="./src/index.ts">source code</a> for inspiration - or better, use a library like <a href="https://npmjs.com/package/type-fest">type-fest</a>.</p>
<h2><a class="anchor" id="autotoc_md14869"></a>
Error messages</h2>
<p>When types don't match, <code>.toEqualTypeOf</code> and <code>.toMatchTypeOf</code> use a special helper type to produce error messages that are as actionable as possible. But there's a bit of a nuance to understanding them. Since the assertions are written "fluently", the failure should be on the "expected" type, not the "actual" type (<code>expect&lt;Actual&gt;().toEqualTypeOf&lt;Expected&gt;()</code>). This means that type errors can be a little confusing - so this library produces a <code>MismatchInfo</code> type to try to make explicit what the expectation is. For example:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>Is an assertion that will fail, since <code>{a: 1}</code> has type <code>{a: number}</code> and not <code>{a: string}</code>. The error message in this case will read something like this:</p>
<div class="fragment"><div class="line">test/test.ts:999:999 - error TS2344: Type &#39;{ a: string; }&#39; does not satisfy the constraint &#39;{ a: \\&quot;Expected: string, Actual: number\\&quot;; }&#39;.</div>
<div class="line">  Types of property &#39;a&#39; are incompatible.</div>
<div class="line">    Type &#39;string&#39; is not assignable to type &#39;\\&quot;Expected: string, Actual: number\\&quot;&#39;.</div>
<div class="line"> </div>
<div class="line">999 expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>Note that the type constraint reported is a human-readable messaging specifying both the "expected" and "actual" types. Rather than taking the sentence &lsquo;Types of property 'a&rsquo; are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"<code>literally - just look at the property name (</code>'a'<code>) and the message:</code>Expected: string, Actual: number`. This will tell you what's wrong, in most cases. Extremely complex types will, of course, be more effort to debug, and may require some experimentation. Please <a href="https://github.com/mmkal/expect-type">raise an issue</a> if the error messages are misleading.</p>
<p>The <code>toBe...</code> methods (like <code>toBeString</code>, <code>toBeNumber</code>, <code>toBeVoid</code>, etc.) fail by resolving to a non-callable type when the <code>Actual</code> type under test doesn't match up. For example, the failure for an assertion like <code>expectTypeOf(1).toBeString()</code> will look something like this:</p>
<div class="fragment"><div class="line">test/test.ts:999:999 - error TS2349: This expression is not callable.</div>
<div class="line">  Type &#39;ExpectString&lt;number&gt;&#39; has no call signatures.</div>
<div class="line"> </div>
<div class="line">999 expectTypeOf(1).toBeString()</div>
<div class="line">                    ~~~~~~~~~~</div>
</div><!-- fragment --><p>The <code>This expression is not callable</code> part isn't all that helpful - the meaningful error is the next line, <code>Type 'ExpectString&lt;number&gt; has no call signatures</code>. This essentially means you passed a number but asserted it should be a string.</p>
<p>If TypeScript added support for <a href="https://github.com/microsoft/TypeScript/pull/40468">"throw" types</a> these error messages could be improved. Until then they will take a certain amount of squinting.</p>
<h3><a class="anchor" id="autotoc_md14870"></a>
Concrete "expected" objects vs type arguments</h3>
<p>Error messages for an assertion like this:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: &#39;&#39;})</div>
</div><!-- fragment --><p>Will be less helpful than for an assertion like this:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>This is because the TypeScript compiler needs to infer the type argument for the &lsquo;.toEqualTypeOf({a: &rsquo;'})<code>style and this library can only mark it as a failure by comparing it against a generic</code>Mismatch<code>type. So, where possible, use a type argument rather than a concrete type for</code>.toEqualTypeOf<code>and</code>toMatchTypeOf<code>. If it's much more convenient to compare two concrete types, you can use</code>typeof`:</p>
<div class="fragment"><div class="line">const one = valueFromFunctionOne({some: {complex: inputs}})</div>
<div class="line">const two = valueFromFunctionTwo({some: {other: inputs}})</div>
<div class="line"> </div>
<div class="line">expectTypeOf(one).toEqualTypeof&lt;typeof two&gt;()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14871"></a>
Overloaded functions</h2>
<p>Due to a TypeScript <a href="https://github.com/microsoft/TypeScript/issues/32164#issuecomment-506810756">design limitation</a>, the native TypeScript <code>Parameters&lt;...&gt;</code> and <code>ReturnType&lt;...&gt;</code> helpers only return types from one variant of an overloaded function. This limitation doesn't apply to expect-type, since it is not used to author TypeScript code, only to assert on existing types. So, we use a workaround for this TypeScript behaviour to assert on <em>all</em> overloads as a union (actually, not necessarily <em>all</em> - we cap out at 10 overloads).</p>
<h2><a class="anchor" id="autotoc_md14872"></a>
Within test frameworks</h2>
<h2><a class="anchor" id="autotoc_md14873"></a>
Vitest</h2>
<p><code>expectTypeOf</code> is built in to <a href="https://vitest.dev/guide/testing-types">vitest</a>, so you can import <code>expectTypeOf</code> from the vitest library directly if you prefer. Note that there is no set release cadence, at time of writing, so vitest may not always be using the very latest version.</p>
<div class="fragment"><div class="line">import {expectTypeOf} from &#39;vitest&#39;</div>
<div class="line">import {mount} from &#39;./mount.js&#39;</div>
<div class="line"> </div>
<div class="line">test(&#39;my types work properly&#39;, () =&gt; {</div>
<div class="line">  expectTypeOf(mount).toBeFunction()</div>
<div class="line">  expectTypeOf(mount).parameter(0).toMatchTypeOf&lt;{name: string}&gt;()</div>
<div class="line"> </div>
<div class="line">  expectTypeOf(mount({name: 42})).toBeString()</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14874"></a>
Jest &amp; <code>eslint-plugin-jest</code></h3>
<p>If you're using Jest along with <code>eslint-plugin-jest</code>, and you put assertions inside <code>test(...)</code> definitions, you may get warnings from the <a href="https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/expect-expect.md"><code>jest/expect-expect</code></a> rule, complaining that "Test has no assertions" for tests that only use <code>expectTypeOf()</code>.</p>
<p>To remove this warning, configure the ESLint rule to consider <code>expectTypeOf</code> as an assertion:</p>
<div class="fragment"><div class="line">&quot;rules&quot;: {</div>
<div class="line">  // ...</div>
<div class="line">  &quot;jest/expect-expect&quot;: [</div>
<div class="line">    &quot;warn&quot;,</div>
<div class="line">    {</div>
<div class="line">      &quot;assertFunctionNames&quot;: [</div>
<div class="line">        &quot;expect&quot;, &quot;expectTypeOf&quot;</div>
<div class="line">      ]</div>
<div class="line">    }</div>
<div class="line">  ],</div>
<div class="line">  // ...</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14875"></a>
Limitations</h2>
<p>A summary of some of the limitations of this library. Some of these are documented more fully elsewhere.</p>
<ol type="1">
<li>Intersection types can result in failures when the expected and actual types are not identically defined, even when they are effectively identical. See Why is my assertion failing for details. TL;DR: use <code>.brand</code> in these cases - and accept the performance hit that it comes with.</li>
</ol>
<ol type="1">
<li><code>toBeCallableWith</code> will likely fail if you try to use it with a generic function or an overload. See <a href="https://github.com/mmkal/expect-type/issues/50">this issue</a> for an example and how to work around it.</li>
</ol>
<ol type="1">
<li>(For now) overloaded functions might trip up the <code>.parameter</code> and <code>.parameters</code> helpers. This matches how the built-in TypeScript helper <code>Parameters&lt;...&gt;</code> works. This may be improved in the future though (<a href="https://github.com/mmkal/expect-type/issues/30">see related issue</a>).</li>
</ol>
<ol type="1">
<li><code>expectTypeOf(this).toEqualTypeOf(this)</code> inside class methods does not work.</li>
</ol>
<h1><a class="anchor" id="autotoc_md14876"></a>
Similar projects</h1>
<p>Other projects with similar goals:</p>
<ul>
<li><a href="https://github.com/SamVerschueren/tsd"><code>tsd</code></a> is a CLI that runs the TypeScript type checker over assertions</li>
<li><a href="https://github.com/TypeStrong/ts-expect"><code>ts-expect</code></a> exports several generic helper types to perform type assertions</li>
<li><a href="https://github.com/Microsoft/dtslint"><code>dtslint</code></a> does type checks via comment directives and tslint</li>
<li><a href="https://github.com/unional/type-plus"><code>type-plus</code></a> comes with various type and runtime TypeScript assertions</li>
<li><a href="https://github.com/ksxnodemodules/static-type-assert"><code>static-type-assert</code></a> type assertion functions</li>
</ul>
<h2><a class="anchor" id="autotoc_md14877"></a>
Comparison</h2>
<p>The key differences in this project are:</p>
<ul>
<li>a fluent, jest-inspired API, making the difference between <code>actual</code> and <code>expected</code> clear. This is helpful with complex types and assertions.</li>
<li>inverting assertions intuitively and easily via <code>expectTypeOf(...).not</code></li>
<li>checks generics properly and strictly (<a href="https://github.com/SamVerschueren/tsd/issues/142">tsd doesn't</a>)</li>
<li>first-class support for:<ul>
<li><code>any</code> (as well as <code>unknown</code> and <code>never</code>) (see issues outstanding at time of writing in tsd for <a href="https://github.com/SamVerschueren/tsd/issues/78">never</a> and <a href="https://github.com/SamVerschueren/tsd/issues/82">any</a>).<ul>
<li>This can be especially useful in combination with <code>not</code>, to protect against functions returning too-permissive types. For example, <code>const parseFile = (filename: string) =&gt; JSON.parse(readFileSync(filename).toString())</code> returns <code>any</code>, which could lead to errors. After giving it a proper return-type, you can add a test for this with <code>expect(parseFile).returns.not.toBeAny()</code></li>
</ul>
</li>
<li>object properties</li>
<li>function parameters</li>
<li>function return values</li>
<li>constructor parameters</li>
<li>class instances</li>
<li>array item values</li>
<li>nullable types</li>
</ul>
</li>
<li>assertions on types "matching" rather than exact type equality, for "is-a" relationships e.g. <code>expectTypeOf(square).toMatchTypeOf&lt;Shape&gt;()</code></li>
<li>built into existing tooling. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time - they'll appear in your IDE and when you run <code>tsc</code>.</li>
<li>small implementation with no dependencies. <a href="./src/index.ts">Take a look!</a> (tsd, for comparison, is <a href="https://bundlephobia.com/result?p=tsd@0.13.1">2.6MB</a> because it ships a patched version of TypeScript).</li>
</ul>
<h1><a class="anchor" id="autotoc_md14878"></a>
TypeScript backwards-compatibility</h1>
<p>There is a CI job called <code>test-types</code> that checks whether the tests still pass with certain older TypeScript versions. To check the supported TypeScript versions, <a href="./.github/workflows/ci.yml">refer to the job definition</a>.</p>
<h1><a class="anchor" id="autotoc_md14879"></a>
Contributing</h1>
<p>In most cases, it's worth checking existing issues or creating one to discuss a new feature or a bug fix before opening a pull request.</p>
<p>Once you're ready to make a pull request: clone the repo, and install pnpm if you don't have it already with <code>npm install --global pnpm</code>. Lockfiles for <code>npm</code> and <code>yarn</code> are gitignored.</p>
<p>If you're adding a feature, you should write a self-contained usage example in the form of a test, in <a href="./test/usage.test.ts">test/usage.test.ts</a>. This file is used to populate the bulk of this readme using <a href="https://npmjs.com/package/eslint-plugin-codegen">eslint-plugin-codegen</a>, and to generate an <a href="./test/errors.test.ts">"errors" test file</a>, which captures the error messages that are emitted for failing assertions by the TypeScript compiler. So, the test name should be written as a human-readable sentence explaining the usage example. Have a look at the existing tests for an idea of the style.</p>
<p>After adding the tests, run <code>npm run lint -- --fix</code> to update the readme, and <code>npm test -- --updateSnapshot</code> to update the errors test. The generated documentation and tests should be pushed to the same branch as the source code, and submitted as a pull request. CI will test that the docs and tests are up to date if you forget to run these commands.</p>
<h2><a class="anchor" id="autotoc_md14880"></a>
Documentation of limitations through tests</h2>
<p>Limitations of the library are documented through tests in <code>usage.test.ts</code>. This means that if a future TypeScript version (or library version) fixes the limitation, the test will start failing, and it will be automatically removed from the documentation once it no longer applies. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_78b3bc975489ee3495c8355d7e4ffc91.html">expect-type</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
