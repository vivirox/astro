<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/p-queue Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_2570ec52521d8919790ee981189c294b.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">p-queue Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<blockquote class="doxtable">
<p>Promise queue with concurrency control </p>
</blockquote>
<p>Useful for rate-limiting async (or sync) operations. For example, when interacting with a REST API or when doing CPU/memory intensive tasks.</p>
<p>For servers, you probably want a Redis-backed <a href="https://github.com/sindresorhus/awesome-nodejs#job-queues">job queue</a> instead.</p>
<p>Note that the project is feature complete. We are happy to review pull requests, but we don't plan any further development. We are also not answering email support questions.</p>
<h1><a class="anchor" id="autotoc_md25392"></a>
Install</h1>
<div class="fragment"><div class="line">npm install p-queue</div>
</div><!-- fragment --><p><b>Warning:</b> This package is native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">ESM</a> and no longer provides a CommonJS export. If your project uses CommonJS, you'll have to <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">convert to ESM</a>. Please don't open issues for questions regarding CommonJS / ESM.</p>
<h1><a class="anchor" id="autotoc_md25393"></a>
Usage</h1>
<p>Here we run only one promise at the time. For example, set <code>concurrency</code> to 4 to run four promises at the same time.</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line">import got from &#39;got&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 1});</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await queue.add(() =&gt; got(&#39;https://sindresorhus.com&#39;));</div>
<div class="line">    console.log(&#39;Done: sindresorhus.com&#39;);</div>
<div class="line">})();</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await queue.add(() =&gt; got(&#39;https://avajs.dev&#39;));</div>
<div class="line">    console.log(&#39;Done: avajs.dev&#39;);</div>
<div class="line">})();</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    const task = await getUnicornTask();</div>
<div class="line">    await queue.add(task);</div>
<div class="line">    console.log(&#39;Done: Unicorn task&#39;);</div>
<div class="line">})();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25394"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md25395"></a>
PQueue(options?)</h2>
<p>Returns a new <code>queue</code> instance, which is an <a href="https://github.com/primus/eventemitter3"><code>EventEmitter3</code></a> subclass.</p>
<h3><a class="anchor" id="autotoc_md25396"></a>
options</h3>
<p>Type: <code>object</code></p>
<h4><a class="anchor" id="autotoc_md25397"></a>
concurrency</h4>
<p>Type: <code>number</code>\ Default: <code>Infinity</code>\ Minimum: <code>1</code></p>
<p>Concurrency limit.</p>
<h4><a class="anchor" id="autotoc_md25398"></a>
timeout</h4>
<p>Type: <code>number</code></p>
<p>Per-operation timeout in milliseconds. Operations fulfill once <code>timeout</code> elapses if they haven't already.</p>
<h4><a class="anchor" id="autotoc_md25399"></a>
throwOnTimeout</h4>
<p>Type: <code>boolean</code>\ Default: <code>false</code></p>
<p>Whether or not a timeout is considered an exception.</p>
<h4><a class="anchor" id="autotoc_md25400"></a>
autoStart</h4>
<p>Type: <code>boolean</code>\ Default: <code>true</code></p>
<p>Whether queue tasks within concurrency limit, are auto-executed as soon as they're added.</p>
<h4><a class="anchor" id="autotoc_md25401"></a>
queueClass</h4>
<p>Type: <code>Function</code></p>
<p>Class with a <code>enqueue</code> and <code>dequeue</code> method, and a <code>size</code> getter. See the Custom QueueClass section.</p>
<h4><a class="anchor" id="autotoc_md25402"></a>
intervalCap</h4>
<p>Type: <code>number</code>\ Default: <code>Infinity</code>\ Minimum: <code>1</code></p>
<p>The max number of runs in the given interval of time.</p>
<h4><a class="anchor" id="autotoc_md25403"></a>
interval</h4>
<p>Type: <code>number</code>\ Default: <code>0</code>\ Minimum: <code>0</code></p>
<p>The length of time in milliseconds before the interval count resets. Must be finite.</p>
<h4><a class="anchor" id="autotoc_md25404"></a>
carryoverConcurrencyCount</h4>
<p>Type: <code>boolean</code>\ Default: <code>false</code></p>
<p>If <code>true</code>, specifies that any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">pending</a> Promises, should be carried over into the next interval and counted against the <code>intervalCap</code>. If <code>false</code>, any of those pending Promises will not count towards the next <code>intervalCap</code>.</p>
<h2><a class="anchor" id="autotoc_md25405"></a>
queue</h2>
<p><code>PQueue</code> instance.</p>
<h3><a class="anchor" id="autotoc_md25406"></a>
.add(fn, options?)</h3>
<p>Adds a sync or async task to the queue.</p>
<p>Returns a promise with the return value of <code>fn</code>.</p>
<p>Note: If your items can potentially throw an exception, you must handle those errors from the returned Promise or they may be reported as an unhandled Promise rejection and potentially cause your process to exit immediately.</p>
<h4><a class="anchor" id="autotoc_md25407"></a>
fn</h4>
<p>Type: <code>Function</code></p>
<p>Promise-returning/async function. When executed, it will receive <code>{signal}</code> as the first argument.</p>
<h3><a class="anchor" id="autotoc_md25408"></a>
options</h3>
<p>Type: <code>object</code></p>
<h4><a class="anchor" id="autotoc_md25409"></a>
priority</h4>
<p>Type: <code>number</code>\ Default: <code>0</code></p>
<p>Priority of operation. Operations with greater priority will be scheduled first.</p>
<h4><a class="anchor" id="autotoc_md25410"></a>
id</h4>
<p>Type <code>string</code></p>
<p>Unique identifier for the promise function, used to update its priority before execution. If not specified, it is auto-assigned an incrementing BigInt starting from <code>1n</code>.</p>
<h4><a class="anchor" id="autotoc_md25411"></a>
signal</h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal"><code>AbortSignal</code></a> for cancellation of the operation. When aborted, it will be removed from the queue and the <code>queue.add()</code> call will reject with an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason">error</a>. If the operation is already running, the signal will need to be handled by the operation itself.</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line">import got, {CancelError} from &#39;got&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue();</div>
<div class="line"> </div>
<div class="line">const controller = new AbortController();</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">    await queue.add(({signal}) =&gt; {</div>
<div class="line">        const request = got(&#39;https://sindresorhus.com&#39;);</div>
<div class="line"> </div>
<div class="line">        signal.addEventListener(&#39;abort&#39;, () =&gt; {</div>
<div class="line">            request.cancel();</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        try {</div>
<div class="line">            return await request;</div>
<div class="line">        } catch (error) {</div>
<div class="line">            if (!(error instanceof CancelError)) {</div>
<div class="line">                throw error;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }, {signal: controller.signal});</div>
<div class="line">} catch (error) {</div>
<div class="line">    if (!(error instanceof DOMException)) {</div>
<div class="line">        throw error;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25412"></a>
.addAll(fns, options?)</h3>
<p>Same as <code>.add()</code>, but accepts an array of sync or async functions and returns a promise that resolves when all functions are resolved.</p>
<h3><a class="anchor" id="autotoc_md25413"></a>
.pause()</h3>
<p>Put queue execution on hold.</p>
<h3><a class="anchor" id="autotoc_md25414"></a>
.start()</h3>
<p>Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via <code>options.autoStart = false</code> or by <code>.pause()</code> method.)</p>
<p>Returns <code>this</code> (the instance).</p>
<h3><a class="anchor" id="autotoc_md25415"></a>
.onEmpty()</h3>
<p>Returns a promise that settles when the queue becomes empty.</p>
<p>Can be called multiple times. Useful if you for example add additional items at a later time.</p>
<h3><a class="anchor" id="autotoc_md25416"></a>
.onIdle()</h3>
<p>Returns a promise that settles when the queue becomes empty, and all promises have completed; <code>queue.size === 0 &amp;&amp; queue.pending === 0</code>.</p>
<p>The difference with <code>.onEmpty</code> is that <code>.onIdle</code> guarantees that all work from the queue has finished. <code>.onEmpty</code> merely signals that the queue is empty, but it could mean that some promises haven't completed yet.</p>
<h3><a class="anchor" id="autotoc_md25417"></a>
.onSizeLessThan(limit)</h3>
<p>Returns a promise that settles when the queue size is less than the given limit: <code>queue.size &lt; limit</code>.</p>
<p>If you want to avoid having the queue grow beyond a certain size you can <code>await queue.onSizeLessThan()</code> before adding a new item.</p>
<p>Note that this only limits the number of items waiting to start. There could still be up to <code>concurrency</code> jobs already running that this call does not include in its calculation.</p>
<h3><a class="anchor" id="autotoc_md25418"></a>
.clear()</h3>
<p>Clear the queue.</p>
<h3><a class="anchor" id="autotoc_md25419"></a>
.size</h3>
<p>Size of the queue, the number of queued items waiting to run.</p>
<h3><a class="anchor" id="autotoc_md25420"></a>
.sizeBy(options)</h3>
<p>Size of the queue, filtered by the given options.</p>
<p>For example, this can be used to find the number of items remaining in the queue with a specific priority level.</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue();</div>
<div class="line"> </div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 0});</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line"> </div>
<div class="line">console.log(queue.sizeBy({priority: 1}));</div>
<div class="line">//=&gt; 2</div>
<div class="line"> </div>
<div class="line">console.log(queue.sizeBy({priority: 0}));</div>
<div class="line">//=&gt; 1</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25421"></a>
.setPriority(id, priority)</h3>
<p>Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.</p>
<p>For example, this can be used to prioritize a promise function to run earlier.</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 1});</div>
<div class="line"> </div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line">queue.add(async () =&gt; &#39;🦀&#39;, {priority: 0, id: &#39;🦀&#39;});</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line"> </div>
<div class="line">queue.setPriority(&#39;🦀&#39;, 2);</div>
</div><!-- fragment --><p>In this case, the promise function with &lsquo;id: '🦀&rsquo;` runs second.</p>
<p>You can also deprioritize a promise function to delay its execution:</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 1});</div>
<div class="line"> </div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 1});</div>
<div class="line">queue.add(async () =&gt; &#39;🦀&#39;, {priority: 1, id: &#39;🦀&#39;});</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;);</div>
<div class="line">queue.add(async () =&gt; &#39;🦄&#39;, {priority: 0});</div>
<div class="line"> </div>
<div class="line">queue.setPriority(&#39;🦀&#39;, -1);</div>
</div><!-- fragment --><p>Here, the promise function with &lsquo;id: '🦀&rsquo;` executes last.</p>
<h3><a class="anchor" id="autotoc_md25422"></a>
.pending</h3>
<p>Number of running items (no longer in the queue).</p>
<h3><a class="anchor" id="autotoc_md25423"></a>
<a class="el" href="/Users/vivi/astro/node_modules/d3-timer/README.md#timeout">.timeout</a></h3>
<h3><a class="anchor" id="autotoc_md25424"></a>
<a class="el" href="/Users/vivi/astro/node_modules/fastq/README.md#concurrency">.concurrency</a></h3>
<h3><a class="anchor" id="autotoc_md25425"></a>
.isPaused</h3>
<p>Whether the queue is currently paused.</p>
<h1><a class="anchor" id="autotoc_md25426"></a>
Events</h1>
<h3><a class="anchor" id="autotoc_md25427"></a>
active</h3>
<p>Emitted as each item is processed in the queue for the purpose of tracking progress.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 2});</div>
<div class="line"> </div>
<div class="line">let count = 0;</div>
<div class="line">queue.on(&#39;active&#39;, () =&gt; {</div>
<div class="line">    console.log(`Working on item #${++count}.  Size: ${queue.size}  Pending: ${queue.pending}`);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">queue.add(() =&gt; Promise.resolve());</div>
<div class="line">queue.add(() =&gt; delay(2000));</div>
<div class="line">queue.add(() =&gt; Promise.resolve());</div>
<div class="line">queue.add(() =&gt; Promise.resolve());</div>
<div class="line">queue.add(() =&gt; delay(500));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25428"></a>
completed</h3>
<p>Emitted when an item completes without error.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 2});</div>
<div class="line"> </div>
<div class="line">queue.on(&#39;completed&#39;, result =&gt; {</div>
<div class="line">    console.log(result);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">queue.add(() =&gt; Promise.resolve(&#39;hello, world!&#39;));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25429"></a>
error</h3>
<p>Emitted if an item throws an error.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 2});</div>
<div class="line"> </div>
<div class="line">queue.on(&#39;error&#39;, error =&gt; {</div>
<div class="line">    console.error(error);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">queue.add(() =&gt; Promise.reject(new Error(&#39;error&#39;)));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25430"></a>
empty</h3>
<p>Emitted every time the queue becomes empty.</p>
<p>Useful if you for example add additional items at a later time.</p>
<h3><a class="anchor" id="autotoc_md25431"></a>
idle</h3>
<p>Emitted every time the queue becomes empty and all promises have completed; <code>queue.size === 0 &amp;&amp; queue.pending === 0</code>.</p>
<p>The difference with <code>empty</code> is that <code>idle</code> guarantees that all work from the queue has finished. <code>empty</code> merely signals that the queue is empty, but it could mean that some promises haven't completed yet.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue();</div>
<div class="line"> </div>
<div class="line">queue.on(&#39;idle&#39;, () =&gt; {</div>
<div class="line">    console.log(`Queue is idle.  Size: ${queue.size}  Pending: ${queue.pending}`);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const job1 = queue.add(() =&gt; delay(2000));</div>
<div class="line">const job2 = queue.add(() =&gt; delay(500));</div>
<div class="line"> </div>
<div class="line">await job1;</div>
<div class="line">await job2;</div>
<div class="line">// =&gt; &#39;Queue is idle.  Size: 0  Pending: 0&#39;</div>
<div class="line"> </div>
<div class="line">await queue.add(() =&gt; delay(600));</div>
<div class="line">// =&gt; &#39;Queue is idle.  Size: 0  Pending: 0&#39;</div>
</div><!-- fragment --><p>The <code>idle</code> event is emitted every time the queue reaches an idle state. On the other hand, the promise the <code>onIdle()</code> function returns resolves once the queue becomes idle instead of every time the queue is idle.</p>
<h3><a class="anchor" id="autotoc_md25432"></a>
add</h3>
<p>Emitted every time the add method is called and the number of pending or queued tasks is increased.</p>
<h3><a class="anchor" id="autotoc_md25433"></a>
next</h3>
<p>Emitted every time a task is completed and the number of pending or queued tasks is decreased. This is emitted regardless of whether the task completed normally or with an error.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue();</div>
<div class="line"> </div>
<div class="line">queue.on(&#39;add&#39;, () =&gt; {</div>
<div class="line">    console.log(`Task is added.  Size: ${queue.size}  Pending: ${queue.pending}`);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">queue.on(&#39;next&#39;, () =&gt; {</div>
<div class="line">    console.log(`Task is completed.  Size: ${queue.size}  Pending: ${queue.pending}`);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const job1 = queue.add(() =&gt; delay(2000));</div>
<div class="line">const job2 = queue.add(() =&gt; delay(500));</div>
<div class="line"> </div>
<div class="line">await job1;</div>
<div class="line">await job2;</div>
<div class="line">//=&gt; &#39;Task is added.  Size: 0  Pending: 1&#39;</div>
<div class="line">//=&gt; &#39;Task is added.  Size: 0  Pending: 2&#39;</div>
<div class="line"> </div>
<div class="line">await queue.add(() =&gt; delay(600));</div>
<div class="line">//=&gt; &#39;Task is completed.  Size: 0  Pending: 1&#39;</div>
<div class="line">//=&gt; &#39;Task is completed.  Size: 0  Pending: 0&#39;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25434"></a>
Advanced example</h1>
<p>A more advanced example to help you understand the flow.</p>
<div class="fragment"><div class="line">import delay from &#39;delay&#39;;</div>
<div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({concurrency: 1});</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await delay(200);</div>
<div class="line"> </div>
<div class="line">    console.log(`8. Pending promises: ${queue.pending}`);</div>
<div class="line">    //=&gt; &#39;8. Pending promises: 0&#39;</div>
<div class="line"> </div>
<div class="line">    (async () =&gt; {</div>
<div class="line">        await queue.add(async () =&gt; &#39;🐙&#39;);</div>
<div class="line">        console.log(&#39;11. Resolved&#39;)</div>
<div class="line">    })();</div>
<div class="line"> </div>
<div class="line">    console.log(&#39;9. Added 🐙&#39;);</div>
<div class="line"> </div>
<div class="line">    console.log(`10. Pending promises: ${queue.pending}`);</div>
<div class="line">    //=&gt; &#39;10. Pending promises: 1&#39;</div>
<div class="line"> </div>
<div class="line">    await queue.onIdle();</div>
<div class="line">    console.log(&#39;12. All work is done&#39;);</div>
<div class="line">})();</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await queue.add(async () =&gt; &#39;🦄&#39;);</div>
<div class="line">    console.log(&#39;5. Resolved&#39;)</div>
<div class="line">})();</div>
<div class="line">console.log(&#39;1. Added 🦄&#39;);</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await queue.add(async () =&gt; &#39;🐴&#39;);</div>
<div class="line">    console.log(&#39;6. Resolved&#39;)</div>
<div class="line">})();</div>
<div class="line">console.log(&#39;2. Added 🐴&#39;);</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    await queue.onEmpty();</div>
<div class="line">    console.log(&#39;7. Queue is empty&#39;);</div>
<div class="line">})();</div>
<div class="line"> </div>
<div class="line">console.log(`3. Queue size: ${queue.size}`);</div>
<div class="line">//=&gt; &#39;3. Queue size: 1`</div>
<div class="line"> </div>
<div class="line">console.log(`4. Pending promises: ${queue.pending}`);</div>
<div class="line">//=&gt; &#39;4. Pending promises: 1&#39;</div>
</div><!-- fragment --><div class="fragment"><div class="line">$ node example.js</div>
<div class="line">1. Added 🦄</div>
<div class="line">2. Added 🐴</div>
<div class="line">3. Queue size: 1</div>
<div class="line">4. Pending promises: 1</div>
<div class="line">5. Resolved 🦄</div>
<div class="line">6. Resolved 🐴</div>
<div class="line">7. Queue is empty</div>
<div class="line">8. Pending promises: 0</div>
<div class="line">9. Added 🐙</div>
<div class="line">10. Pending promises: 1</div>
<div class="line">11. Resolved 🐙</div>
<div class="line">12. All work is done</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25435"></a>
Custom QueueClass</h1>
<p>For implementing more complex scheduling policies, you can provide a QueueClass in the options:</p>
<div class="fragment"><div class="line">import PQueue from &#39;p-queue&#39;;</div>
<div class="line"> </div>
<div class="line">class QueueClass {</div>
<div class="line">    constructor() {</div>
<div class="line">        this._queue = [];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    enqueue(run, options) {</div>
<div class="line">        this._queue.push(run);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    dequeue() {</div>
<div class="line">        return this._queue.shift();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    get size() {</div>
<div class="line">        return this._queue.length;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    filter(options) {</div>
<div class="line">        return this._queue;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const queue = new PQueue({queueClass: QueueClass});</div>
</div><!-- fragment --><p><code>p-queue</code> will call corresponding methods to put and get operations from this queue.</p>
<h1><a class="anchor" id="autotoc_md25436"></a>
FAQ</h1>
<h3><a class="anchor" id="autotoc_md25437"></a>
How do the <code>concurrency</code> and <code>intervalCap</code> options affect each other?</h3>
<p>They are just different constraints. The <code>concurrency</code> option limits how many things run at the same time. The <code>intervalCap</code> option limits how many things run in total during the interval (over time).</p>
<h1><a class="anchor" id="autotoc_md25438"></a>
Maintainers</h1>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/Richienb">Richie Bendall</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md25439"></a>
Related</h1>
<ul>
<li><a href="https://github.com/sindresorhus/p-limit">p-limit</a> - Run multiple promise-returning &amp; async functions with limited concurrency</li>
<li><a href="https://github.com/sindresorhus/p-throttle">p-throttle</a> - Throttle promise-returning &amp; async functions</li>
<li><a href="https://github.com/sindresorhus/p-debounce">p-debounce</a> - Debounce promise-returning &amp; async functions</li>
<li><a href="https://github.com/sindresorhus/p-all">p-all</a> - Run promise-returning &amp; async functions concurrently with optional limited concurrency</li>
<li><a href="https://github.com/sindresorhus/promise-fun">More…</a> </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_2570ec52521d8919790ee981189c294b.html">p-queue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
