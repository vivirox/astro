<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/fflate Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_659b8a9d70a61e2b6195c42f9fd52df8.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">fflate Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>High performance (de)compression in an 8kB package</p>
<h1><a class="anchor" id="autotoc_md15427"></a>
Why fflate?</h1>
<p><code>fflate</code> (short for fast flate) is the <b>fastest, smallest, and most versatile</b> pure JavaScript compression and decompression library in existence, handily beating <a href="https://npmjs.com/package/pako"><code>pako</code></a>, <a href="https://npmjs.com/package/tiny-inflate"><code>tiny-inflate</code></a>, and <a href="https://github.com/photopea/UZIP.js"><code>UZIP.js</code></a> in performance benchmarks while being multiple times more lightweight. Its compression ratios are often better than even the original Zlib C library. It includes support for DEFLATE, GZIP, and Zlib data. Data compressed by <code>fflate</code> can be decompressed by other tools, and vice versa.</p>
<p>In addition to the base decompression and compression APIs, <code>fflate</code> supports high-speed ZIP file archiving for an extra 3 kB. In fact, the compressor, in synchronous mode, compresses both more quickly and with a higher compression ratio than most compression software (even Info-ZIP, a C program), and in asynchronous mode it can utilize multiple threads to achieve over 3x the performance of virtually any other utility.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"><code>pako</code>   </th><th class="markdownTableHeadNone"><code>tiny-inflate</code>   </th><th class="markdownTableHeadNone"><code>UZIP.js</code>   </th><th class="markdownTableHeadNone"><code>fflate</code>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Decompression performance   </td><td class="markdownTableBodyNone">1x   </td><td class="markdownTableBodyNone">Up to 40% slower   </td><td class="markdownTableBodyNone"><b>Up to 40% faster</b>   </td><td class="markdownTableBodyNone"><b>Up to 40% faster</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compression performance   </td><td class="markdownTableBodyNone">1x   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">Up to 25% faster   </td><td class="markdownTableBodyNone"><b>Up to 50% faster</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Base bundle size (minified)   </td><td class="markdownTableBodyNone">45.6kB   </td><td class="markdownTableBodyNone"><b>3kB (inflate only)</b>   </td><td class="markdownTableBodyNone">14.2kB   </td><td class="markdownTableBodyNone">8kB <b>(3kB for inflate only)</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Decompression support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Compression support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ZIP support   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Streaming support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GZIP support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Supports files up to 4GB   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Doesn't hang on error   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dictionary support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Multi-thread/Asynchronous   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Streaming ZIP support   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Uses ES Modules   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md15428"></a>
Demo</h1>
<p>If you'd like to try <code>fflate</code> for yourself without installing it, you can take a look at the <a href="https://101arrowz.github.io/fflate">browser demo</a>. Since <code>fflate</code> is a pure JavaScript library, it works in both the browser and Node.js (see <a href="https://github.com/101arrowz/fflate/#browser-support">Browser support</a> for more info).</p>
<h1><a class="anchor" id="autotoc_md15429"></a>
Usage</h1>
<p>Install <code>fflate</code>: </p><div class="fragment"><div class="line">npm i fflate # or yarn add fflate, or pnpm add fflate</div>
</div><!-- fragment --><p>Import: </p><div class="fragment"><div class="line">// I will assume that you use the following for the rest of this guide</div>
<div class="line">import * as fflate from &#39;fflate&#39;;</div>
<div class="line"> </div>
<div class="line">// However, you should import ONLY what you need to minimize bloat.</div>
<div class="line">// So, if you just need GZIP compression support:</div>
<div class="line">import { gzipSync } from &#39;fflate&#39;;</div>
<div class="line">// Woo! You just saved 20 kB off your bundle with one line.</div>
</div><!-- fragment --><p>If your environment doesn't support ES Modules (e.g. Node.js): </p><div class="fragment"><div class="line">// Try to avoid this when using fflate in the browser, as it will import</div>
<div class="line">// all of fflate&#39;s components, even those that you aren&#39;t using.</div>
<div class="line">const fflate = require(&#39;fflate&#39;);</div>
</div><!-- fragment --><p>If you want to load from a CDN in the browser: </p><div class="fragment"><div class="line">&lt;!--</div>
<div class="line">You should use either UNPKG or jsDelivr (i.e. only one of the following)</div>
<div class="line"> </div>
<div class="line">Note that tree shaking is completely unsupported from the CDN. If you want</div>
<div class="line">a small build without build tools, please ask me and I will make one manually</div>
<div class="line">with only the features you need. This build is about 31kB, or 11.5kB gzipped.</div>
<div class="line">--&gt;</div>
<div class="line">&lt;script src=&quot;https://unpkg.com/fflate@0.8.2&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;!-- Now, the global variable fflate contains the library --&gt;</div>
<div class="line"> </div>
<div class="line">&lt;!-- If you&#39;re going buildless but want ESM, import from Skypack --&gt;</div>
<div class="line">&lt;script type=&quot;module&quot;&gt;</div>
<div class="line">  import * as fflate from &#39;https://cdn.skypack.dev/fflate@0.8.2?min&#39;;</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>If you are using Deno: </p><div class="fragment"><div class="line">// Don&#39;t use the ?dts Skypack flag; it isn&#39;t necessary for Deno support</div>
<div class="line">// The @deno-types comment adds TypeScript typings</div>
<div class="line"> </div>
<div class="line">// @deno-types=&quot;https://cdn.skypack.dev/fflate@0.8.2/lib/index.d.ts&quot;</div>
<div class="line">import * as fflate from &#39;https://cdn.skypack.dev/fflate@0.8.2?min&#39;;</div>
</div><!-- fragment --><p>If your environment doesn't support bundling: </p><div class="fragment"><div class="line">// Again, try to import just what you need</div>
<div class="line"> </div>
<div class="line">// For the browser:</div>
<div class="line">import * as fflate from &#39;fflate/esm/browser.js&#39;;</div>
<div class="line">// If the standard ESM import fails on Node (i.e. older version):</div>
<div class="line">import * as fflate from &#39;fflate/esm&#39;;</div>
</div><!-- fragment --><p>And use: </p><div class="fragment"><div class="line">// This is an ArrayBuffer of data</div>
<div class="line">const massiveFileBuf = await fetch(&#39;/aMassiveFile&#39;).then(</div>
<div class="line">  res =&gt; res.arrayBuffer()</div>
<div class="line">);</div>
<div class="line">// To use fflate, you need a Uint8Array</div>
<div class="line">const massiveFile = new Uint8Array(massiveFileBuf);</div>
<div class="line">// Note that Node.js Buffers work just fine as well:</div>
<div class="line">// const massiveFile = require(&#39;fs&#39;).readFileSync(&#39;aMassiveFile.txt&#39;);</div>
<div class="line"> </div>
<div class="line">// Higher level means lower performance but better compression</div>
<div class="line">// The level ranges from 0 (no compression) to 9 (max compression)</div>
<div class="line">// The default level is 6</div>
<div class="line">const notSoMassive = fflate.zlibSync(massiveFile, { level: 9 });</div>
<div class="line">const massiveAgain = fflate.unzlibSync(notSoMassive);</div>
<div class="line">const gzipped = fflate.gzipSync(massiveFile, {</div>
<div class="line">  // GZIP-specific: the filename to use when decompressed</div>
<div class="line">  filename: &#39;aMassiveFile.txt&#39;,</div>
<div class="line">  // GZIP-specific: the modification time. Can be a Date, date string,</div>
<div class="line">  // or Unix timestamp</div>
<div class="line">  mtime: &#39;9/1/16 2:00 PM&#39;</div>
<div class="line">});</div>
</div><!-- fragment --><p> <code>fflate</code> can autodetect a compressed file's format as well: </p><div class="fragment"><div class="line">const compressed = new Uint8Array(</div>
<div class="line">  await fetch(&#39;/GZIPorZLIBorDEFLATE&#39;).then(res =&gt; res.arrayBuffer())</div>
<div class="line">);</div>
<div class="line">// Above example with Node.js Buffers:</div>
<div class="line">// Buffer.from(&#39;H4sIAAAAAAAAE8tIzcnJBwCGphA2BQAAAA==&#39;, &#39;base64&#39;);</div>
<div class="line"> </div>
<div class="line">const decompressed = fflate.decompressSync(compressed);</div>
</div><!-- fragment --><p>Using strings is easy with <code>fflate</code>'s string conversion API: </p><div class="fragment"><div class="line">const buf = fflate.strToU8(&#39;Hello world!&#39;);</div>
<div class="line"> </div>
<div class="line">// The default compression method is gzip</div>
<div class="line">// Increasing mem may increase performance at the cost of memory</div>
<div class="line">// The mem ranges from 0 to 12, where 4 is the default</div>
<div class="line">const compressed = fflate.compressSync(buf, { level: 6, mem: 8 });</div>
<div class="line"> </div>
<div class="line">// When you need to decompress:</div>
<div class="line">const decompressed = fflate.decompressSync(compressed);</div>
<div class="line">const origText = fflate.strFromU8(decompressed);</div>
<div class="line">console.log(origText); // Hello world!</div>
</div><!-- fragment --><p>If you need to use an (albeit inefficient) binary string, you can set the second argument to <code>true</code>. </p><div class="fragment"><div class="line">const buf = fflate.strToU8(&#39;Hello world!&#39;);</div>
<div class="line"> </div>
<div class="line">// The second argument, latin1, is a boolean that indicates that the data</div>
<div class="line">// is not Unicode but rather should be encoded and decoded as Latin-1.</div>
<div class="line">// This is useful for creating a string from binary data that isn&#39;t</div>
<div class="line">// necessarily valid UTF-8. However, binary strings are incredibly</div>
<div class="line">// inefficient and tend to double file size, so they&#39;re not recommended.</div>
<div class="line">const compressedString = fflate.strFromU8(</div>
<div class="line">  fflate.compressSync(buf),</div>
<div class="line">  true</div>
<div class="line">);</div>
<div class="line">const decompressed = fflate.decompressSync(</div>
<div class="line">  fflate.strToU8(compressedString, true)</div>
<div class="line">);</div>
<div class="line">const origText = fflate.strFromU8(decompressed);</div>
<div class="line">console.log(origText); // Hello world!</div>
</div><!-- fragment --><p>You can use streams as well to incrementally add data to be compressed or decompressed: </p><div class="fragment"><div class="line">// This example uses synchronous streams, but for the best experience</div>
<div class="line">// you&#39;ll definitely want to use asynchronous streams.</div>
<div class="line"> </div>
<div class="line">let outStr = &#39;&#39;;</div>
<div class="line">const gzipStream = new fflate.Gzip({ level: 9 }, (chunk, isLast) =&gt; {</div>
<div class="line">  // accumulate in an inefficient binary string (just an example)</div>
<div class="line">  outStr += fflate.strFromU8(chunk, true);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// You can also attach the data handler separately if you don&#39;t want to</div>
<div class="line">// do so in the constructor.</div>
<div class="line">gzipStream.ondata = (chunk, final) =&gt; { ... }</div>
<div class="line"> </div>
<div class="line">// Since this is synchronous, all errors will be thrown by stream.push()</div>
<div class="line">gzipStream.push(chunk1);</div>
<div class="line">gzipStream.push(chunk2);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">// You should mark the last chunk by using true in the second argument</div>
<div class="line">// In addition to being necessary for the stream to work properly, this</div>
<div class="line">// will also set the isLast parameter in the handler to true.</div>
<div class="line">gzipStream.push(lastChunk, true);</div>
<div class="line"> </div>
<div class="line">console.log(outStr); // The compressed binary string is now available</div>
<div class="line"> </div>
<div class="line">// The options parameter for compression streams is optional; you can</div>
<div class="line">// provide one parameter (the handler) or none at all if you set</div>
<div class="line">// deflateStream.ondata later.</div>
<div class="line">const deflateStream = new fflate.Deflate((chunk, final) =&gt; {</div>
<div class="line">  console.log(chunk, final);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// If you want to create a stream from strings, use EncodeUTF8</div>
<div class="line">const utfEncode = new fflate.EncodeUTF8((data, final) =&gt; {</div>
<div class="line">  // Chaining streams together is done by pushing to the</div>
<div class="line">  // next stream in the handler for the previous stream</div>
<div class="line">  deflateStream.push(data, final);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">utfEncode.push(&#39;Hello&#39;.repeat(1000));</div>
<div class="line">utfEncode.push(&#39; &#39;.repeat(100));</div>
<div class="line">utfEncode.push(&#39;world!&#39;.repeat(10), true);</div>
<div class="line"> </div>
<div class="line">// The deflateStream has logged the compressed data</div>
<div class="line"> </div>
<div class="line">const inflateStream = new fflate.Inflate();</div>
<div class="line">inflateStream.ondata = (decompressedChunk, final) =&gt; { ... };</div>
<div class="line"> </div>
<div class="line">let stringData = &#39;&#39;;</div>
<div class="line"> </div>
<div class="line">// Streaming UTF-8 decode is available too</div>
<div class="line">const utfDecode = new fflate.DecodeUTF8((data, final) =&gt; {</div>
<div class="line">  stringData += data;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Decompress streams auto-detect the compression method, as the</div>
<div class="line">// non-streaming decompress() method does.</div>
<div class="line">const dcmpStrm = new fflate.Decompress((chunk, final) =&gt; {</div>
<div class="line">  console.log(chunk, &#39;was encoded with GZIP, Zlib, or DEFLATE&#39;);</div>
<div class="line">  utfDecode.push(chunk, final);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">dcmpStrm.push(zlibJSONData1);</div>
<div class="line">dcmpStrm.push(zlibJSONData2, true);</div>
<div class="line"> </div>
<div class="line">// This succeeds; the UTF-8 decoder chained with the unknown compression format</div>
<div class="line">// stream to reach a string as a sink.</div>
<div class="line">console.log(JSON.parse(stringData));</div>
</div><!-- fragment --><p>You can create multi-file ZIP archives easily as well. Note that by default, compression is enabled for all files, which is not useful when ZIPping many PNGs, JPEGs, PDFs, etc. because those formats are already compressed. You should either override the level on a per-file basis or globally to avoid wasting resources. </p><div class="fragment"><div class="line">// Note that the asynchronous version (see below) runs in parallel and</div>
<div class="line">// is *much* (up to 3x) faster for larger archives.</div>
<div class="line">const zipped = fflate.zipSync({</div>
<div class="line">  // Directories can be nested structures, as in an actual filesystem</div>
<div class="line">  &#39;dir1&#39;: {</div>
<div class="line">    &#39;nested&#39;: {</div>
<div class="line">      // You can use Unicode in filenames</div>
<div class="line">      &#39;你好.txt&#39;: fflate.strToU8(&#39;Hey there!&#39;)</div>
<div class="line">    },</div>
<div class="line">    // You can also manually write out a directory path</div>
<div class="line">    &#39;other/tmp.txt&#39;: new Uint8Array([97, 98, 99, 100])</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  // You can also provide compression options</div>
<div class="line">  &#39;massiveImage.bmp&#39;: [aMassiveFile, {</div>
<div class="line">    level: 9,</div>
<div class="line">    mem: 12</div>
<div class="line">  }],</div>
<div class="line">  // PNG is pre-compressed; no need to waste time</div>
<div class="line">  &#39;superTinyFile.png&#39;: [aPNGFile, { level: 0 }],</div>
<div class="line"> </div>
<div class="line">  // Directories take options too</div>
<div class="line">  &#39;exec&#39;: [{</div>
<div class="line">    &#39;hello.sh&#39;: [fflate.strToU8(&#39;echo hello world&#39;), {</div>
<div class="line">      // ZIP only: Set the operating system to Unix</div>
<div class="line">      os: 3,</div>
<div class="line">      // ZIP only: Make this file executable on Unix</div>
<div class="line">      attrs: 0o755 &lt;&lt; 16</div>
<div class="line">    }]</div>
<div class="line">  }, {</div>
<div class="line">    // ZIP and GZIP support mtime (defaults to current time)</div>
<div class="line">    mtime: new Date(&#39;10/20/2020&#39;)</div>
<div class="line">  }]</div>
<div class="line">}, {</div>
<div class="line">  // These options are the defaults for all files, but file-specific</div>
<div class="line">  // options take precedence.</div>
<div class="line">  level: 1,</div>
<div class="line">  // Obfuscate last modified time by default </div>
<div class="line">  mtime: new Date(&#39;1/1/1980&#39;)</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// If you write the zipped data to myzip.zip and unzip, the folder</div>
<div class="line">// structure will be outputted as:</div>
<div class="line"> </div>
<div class="line">// myzip.zip (original file)</div>
<div class="line">// dir1</div>
<div class="line">// |-&gt; nested</div>
<div class="line">// |   |-&gt; 你好.txt</div>
<div class="line">// |-&gt; other</div>
<div class="line">// |   |-&gt; tmp.txt</div>
<div class="line">// massiveImage.bmp</div>
<div class="line">// superTinyFile.png</div>
<div class="line"> </div>
<div class="line">// When decompressing, folders are not nested; all filepaths are fully</div>
<div class="line">// written out in the keys. For example, the return value may be:</div>
<div class="line">// { &#39;nested/directory/structure.txt&#39;: Uint8Array(2) [97, 97] }</div>
<div class="line">const decompressed = fflate.unzipSync(zipped, {</div>
<div class="line">  // You may optionally supply a filter for files. By default, all files in a</div>
<div class="line">  // ZIP archive are extracted, but a filter can save resources by telling</div>
<div class="line">  // the library not to decompress certain files</div>
<div class="line">  filter(file) {</div>
<div class="line">    // Don&#39;t decompress the massive image or any files larger than 10 MiB</div>
<div class="line">    return file.name != &#39;massiveImage.bmp&#39; &amp;&amp; file.originalSize &lt;= 10_000_000;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>If you need extremely high performance or custom ZIP compression formats, you can use the highly-extensible ZIP streams. They take streams as both input and output. You can even use custom compression/decompression algorithms from other libraries, as long as they <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">are defined in the ZIP spec</a> (see section 4.4.5). If you'd like more info on using custom compressors, <a href="https://github.com/101arrowz/fflate/discussions">feel free to ask</a>. </p><div class="fragment"><div class="line">// ZIP object</div>
<div class="line">// Can also specify zip.ondata outside of the constructor</div>
<div class="line">const zip = new fflate.Zip((err, dat, final) =&gt; {</div>
<div class="line">  if (!err) {</div>
<div class="line">    // output of the streams</div>
<div class="line">    console.log(dat, final);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const helloTxt = new fflate.ZipDeflate(&#39;hello.txt&#39;, {</div>
<div class="line">  level: 9</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Always add streams to ZIP archives before pushing to those streams</div>
<div class="line">zip.add(helloTxt);</div>
<div class="line"> </div>
<div class="line">helloTxt.push(chunk1);</div>
<div class="line">// Last chunk</div>
<div class="line">helloTxt.push(chunk2, true);</div>
<div class="line"> </div>
<div class="line">// ZipPassThrough is like ZipDeflate with level 0, but allows for tree shaking</div>
<div class="line">const nonStreamingFile = new fflate.ZipPassThrough(&#39;test.png&#39;);</div>
<div class="line">zip.add(nonStreamingFile);</div>
<div class="line">// If you have data already loaded, just .push(data, true)</div>
<div class="line">nonStreamingFile.push(pngData, true);</div>
<div class="line"> </div>
<div class="line">// You need to call .end() after finishing</div>
<div class="line">// This ensures the ZIP is valid</div>
<div class="line">zip.end();</div>
<div class="line"> </div>
<div class="line">// Unzip object</div>
<div class="line">const unzipper = new fflate.Unzip();</div>
<div class="line"> </div>
<div class="line">// This function will almost always have to be called. It is used to support</div>
<div class="line">// compression algorithms such as BZIP2 or LZMA in ZIP files if just DEFLATE</div>
<div class="line">// is not enough (though it almost always is).</div>
<div class="line">// If your ZIP files are not compressed, this line is not needed.</div>
<div class="line">unzipper.register(fflate.UnzipInflate);</div>
<div class="line"> </div>
<div class="line">const neededFiles = [&#39;file1.txt&#39;, &#39;example.json&#39;];</div>
<div class="line"> </div>
<div class="line">// Can specify handler in constructor too</div>
<div class="line">unzipper.onfile = file =&gt; {</div>
<div class="line">  // file.name is a string, file is a stream</div>
<div class="line">  if (neededFiles.includes(file.name)) {</div>
<div class="line">    file.ondata = (err, dat, final) =&gt; {</div>
<div class="line">      // Stream output here</div>
<div class="line">      console.log(dat, final);</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    console.log(&#39;Reading:&#39;, file.name);</div>
<div class="line"> </div>
<div class="line">    // File sizes are sometimes not set if the ZIP file did not encode</div>
<div class="line">    // them, so you may want to check that file.size != undefined</div>
<div class="line">    console.log(&#39;Compressed size&#39;, file.size);</div>
<div class="line">    console.log(&#39;Decompressed size&#39;, file.originalSize);</div>
<div class="line"> </div>
<div class="line">    // You should only start the stream if you plan to use it to improve</div>
<div class="line">    // performance. Only after starting the stream will ondata be called.</div>
<div class="line">    // This method will throw if the compression method hasn&#39;t been registered</div>
<div class="line">    file.start();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Try to keep under 5,000 files per chunk to avoid stack limit errors</div>
<div class="line">// For example, if all files are a few kB, multi-megabyte chunks are OK</div>
<div class="line">// If files are mostly under 100 bytes, 64kB chunks are the limit</div>
<div class="line">unzipper.push(zipChunk1);</div>
<div class="line">unzipper.push(zipChunk2);</div>
<div class="line">unzipper.push(zipChunk3, true);</div>
</div><!-- fragment --><p>As you may have guessed, there is an asynchronous version of every method as well. Unlike most libraries, this will cause the compression or decompression run in a separate thread entirely and automatically by using Web (or Node) Workers. This means that the processing will not block the main thread at all.</p>
<p>Note that there is a significant initial overhead to using workers of about 50ms for each asynchronous function. For instance, if you call <code>unzip</code> ten times, the overhead only applies for the first call, but if you call <code>unzip</code> and <code>zlib</code>, they will each cause the 50ms delay. For small (under about 50kB) payloads, the asynchronous APIs will be much slower. However, if you're compressing larger files/multiple files at once, or if the synchronous API causes the main thread to hang for too long, the callback APIs are an order of magnitude better. </p><div class="fragment"><div class="line">import {</div>
<div class="line">  gzip, zlib, AsyncGzip, zip, unzip, strFromU8,</div>
<div class="line">  Zip, AsyncZipDeflate, Unzip, AsyncUnzipInflate</div>
<div class="line">} from &#39;fflate&#39;;</div>
<div class="line"> </div>
<div class="line">// Workers will work in almost any browser (even IE11!)</div>
<div class="line">// All of the async APIs use a node-style callback as so:</div>
<div class="line">const terminate = gzip(aMassiveFile, (err, data) =&gt; {</div>
<div class="line">  if (err) {</div>
<div class="line">    // The compressed data was likely corrupt, so we have to handle</div>
<div class="line">    // the error.</div>
<div class="line">    return;</div>
<div class="line">  }</div>
<div class="line">  // Use data however you like</div>
<div class="line">  console.log(data.length);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">if (needToCancel) {</div>
<div class="line">  // The return value of any of the asynchronous APIs is a function that,</div>
<div class="line">  // when called, will immediately cancel the operation. The callback</div>
<div class="line">  // will not be called.</div>
<div class="line">  terminate();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// If you wish to provide options, use the second argument.</div>
<div class="line"> </div>
<div class="line">// The consume option will render the data inside aMassiveFile unusable,</div>
<div class="line">// but can improve performance and dramatically reduce memory usage.</div>
<div class="line">zlib(aMassiveFile, { consume: true, level: 9 }, (err, data) =&gt; {</div>
<div class="line">  // Use the data</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Asynchronous streams are similar to synchronous streams, but the</div>
<div class="line">// handler has the error that occurred (if any) as the first parameter,</div>
<div class="line">// and they don&#39;t block the main thread.</div>
<div class="line"> </div>
<div class="line">// Additionally, any buffers that are pushed in will be consumed and</div>
<div class="line">// rendered unusable; if you need to use a buffer you push in, you</div>
<div class="line">// should clone it first.</div>
<div class="line">const gzs = new AsyncGzip({ level: 9, mem: 12, filename: &#39;hello.txt&#39; });</div>
<div class="line">let wasCallbackCalled = false;</div>
<div class="line">gzs.ondata = (err, chunk, final) =&gt; {</div>
<div class="line">  // Note the new err parameter</div>
<div class="line">  if (err) {</div>
<div class="line">    // Note that after this occurs, the stream becomes corrupt and must</div>
<div class="line">    // be discarded. You can&#39;t continue pushing chunks and expect it to</div>
<div class="line">    // work.</div>
<div class="line">    console.error(err);</div>
<div class="line">    return;</div>
<div class="line">  }</div>
<div class="line">  wasCallbackCalled = true;</div>
<div class="line">}</div>
<div class="line">gzs.push(chunk);</div>
<div class="line"> </div>
<div class="line">// Since the stream is asynchronous, the callback will not be called</div>
<div class="line">// immediately. If such behavior is absolutely necessary (it shouldn&#39;t</div>
<div class="line">// be), use synchronous streams.</div>
<div class="line">console.log(wasCallbackCalled) // false</div>
<div class="line"> </div>
<div class="line">// To terminate an asynchronous stream&#39;s internal worker, call</div>
<div class="line">// stream.terminate().</div>
<div class="line">gzs.terminate();</div>
<div class="line"> </div>
<div class="line">// This is way faster than zipSync because the compression of multiple</div>
<div class="line">// files runs in parallel. In fact, the fact that it&#39;s parallelized</div>
<div class="line">// makes it faster than most standalone ZIP CLIs. The effect is most</div>
<div class="line">// significant for multiple large files; less so for many small ones.</div>
<div class="line">zip({ f1: aMassiveFile, &#39;f2.txt&#39;: anotherMassiveFile }, {</div>
<div class="line">  // The options object is still optional, you can still do just</div>
<div class="line">  // zip(archive, callback)</div>
<div class="line">  level: 6</div>
<div class="line">}, (err, data) =&gt; {</div>
<div class="line">  // Save the ZIP file</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// unzip is the only async function without support for consume option</div>
<div class="line">// It is parallelized, so unzip is also often much faster than unzipSync</div>
<div class="line">unzip(aMassiveZIPFile, (err, unzipped) =&gt; {</div>
<div class="line">  // If the archive has data.xml, log it here</div>
<div class="line">  console.log(unzipped[&#39;data.xml&#39;]);</div>
<div class="line">  // Conversion to string</div>
<div class="line">  console.log(strFromU8(unzipped[&#39;data.xml&#39;]))</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Streaming ZIP archives can accept asynchronous streams. This automatically</div>
<div class="line">// uses multicore compression.</div>
<div class="line">const zip = new Zip();</div>
<div class="line">zip.ondata = (err, chunk, final) =&gt; { ... };</div>
<div class="line">// The JSON and BMP are compressed in parallel</div>
<div class="line">const exampleFile = new AsyncZipDeflate(&#39;example.json&#39;);</div>
<div class="line">zip.add(exampleFile);</div>
<div class="line">exampleFile.push(JSON.stringify({ large: &#39;object&#39; }), true);</div>
<div class="line">const exampleFile2 = new AsyncZipDeflate(&#39;example2.bmp&#39;, { level: 9 });</div>
<div class="line">zip.add(exampleFile2);</div>
<div class="line">exampleFile2.push(ec2a);</div>
<div class="line">exampleFile2.push(ec2b);</div>
<div class="line">exampleFile2.push(ec2c);</div>
<div class="line">...</div>
<div class="line">exampleFile2.push(ec2Final, true);</div>
<div class="line">zip.end();</div>
<div class="line"> </div>
<div class="line">// Streaming Unzip should register the asynchronous inflation algorithm</div>
<div class="line">// for parallel processing.</div>
<div class="line">const unzip = new Unzip(stream =&gt; {</div>
<div class="line">  if (stream.name.endsWith(&#39;.json&#39;)) {</div>
<div class="line">    stream.ondata = (err, chunk, final) =&gt; { ... };</div>
<div class="line">    stream.start();</div>
<div class="line"> </div>
<div class="line">    if (needToCancel) {</div>
<div class="line">      // To cancel these streams, call .terminate()</div>
<div class="line">      stream.terminate();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line">unzip.register(AsyncUnzipInflate);</div>
<div class="line">unzip.push(data, true);</div>
</div><!-- fragment --><p>See the <a href="https://github.com/101arrowz/fflate/blob/master/docs/README.md">documentation</a> for more detailed information about the API.</p>
<h1><a class="anchor" id="autotoc_md15430"></a>
Bundle size estimates</h1>
<p>The bundle size measurements for <code>fflate</code> on sites like Bundlephobia include every feature of the library and should be seen as an upper bound. As long as you are using tree shaking or dead code elimination, this table should give you a general idea of <code>fflate</code>'s bundle size for the features you need.</p>
<p>The maximum bundle size that is possible with <code>fflate</code> is about 31kB (11.5kB gzipped) if you use every single feature, but feature parity with <code>pako</code> is only around 10kB (as opposed to 45kB from <code>pako</code>). If your bundle size increases dramatically after adding <code>fflate</code>, please <a href="https://github.com/101arrowz/fflate/issues/new">create an issue</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone">Bundle size (minified)   </th><th class="markdownTableHeadNone">Nearest competitor    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Decompression   </td><td class="markdownTableBodyNone">3kB   </td><td class="markdownTableBodyNone"><code>tiny-inflate</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compression   </td><td class="markdownTableBodyNone">5kB   </td><td class="markdownTableBodyNone"><code>UZIP.js</code>, 2.84x larger    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Async decompression   </td><td class="markdownTableBodyNone">4kB (1kB + raw decompression)   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Async compression   </td><td class="markdownTableBodyNone">6kB (1kB + raw compression)   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ZIP decompression   </td><td class="markdownTableBodyNone">5kB (2kB + raw decompression)   </td><td class="markdownTableBodyNone"><code>UZIP.js</code>, 2.84x larger    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ZIP compression   </td><td class="markdownTableBodyNone">7kB (2kB + raw compression)   </td><td class="markdownTableBodyNone"><code>UZIP.js</code>, 2.03x larger    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GZIP/Zlib decompression   </td><td class="markdownTableBodyNone">4kB (1kB + raw decompression)   </td><td class="markdownTableBodyNone"><code>pako</code>, 11.4x larger    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GZIP/Zlib compression   </td><td class="markdownTableBodyNone">5kB (1kB + raw compression)   </td><td class="markdownTableBodyNone"><code>pako</code>, 9.12x larger    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Streaming decompression   </td><td class="markdownTableBodyNone">4kB (1kB + raw decompression)   </td><td class="markdownTableBodyNone"><code>pako</code>, 11.4x larger    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Streaming compression   </td><td class="markdownTableBodyNone">5kB (1kB + raw compression)   </td><td class="markdownTableBodyNone"><code>pako</code>, 9.12x larger   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md15431"></a>
What makes <code>fflate</code> so fast?</h1>
<p>Many JavaScript compression/decompression libraries exist. However, the most popular one, <a href="https://npmjs.com/package/pako"><code>pako</code></a>, is merely a clone of Zlib rewritten nearly line-for-line in JavaScript. Although it is by no means poorly made, <code>pako</code> doesn't recognize the many differences between JavaScript and C, and therefore is suboptimal for performance. Moreover, even when minified, the library is 45 kB; it may not seem like much, but for anyone concerned with optimizing bundle size (especially library authors), it's more weight than necessary.</p>
<p>Note that there exist some small libraries like <a href="https://npmjs.com/package/tiny-inflate"><code>tiny-inflate</code></a> for solely decompression, and with a minified size of 3 kB, it can be appealing; however, its performance is lackluster, typically 40% worse than <code>pako</code> in my tests.</p>
<p><a href="https://github.com/photopea/UZIP.js"><code>UZIP.js</code></a> is both faster (by up to 40%) and smaller (14 kB minified) than <code>pako</code>, and it contains a variety of innovations that make it excellent for both performance and compression ratio. However, the developer made a variety of tiny mistakes and inefficient design choices that make it imperfect. Moreover, it does not support GZIP or Zlib data directly; one must remove the headers manually to use <code>UZIP.js</code>.</p>
<p>So what makes <code>fflate</code> different? It takes the brilliant innovations of <code>UZIP.js</code> and optimizes them while adding direct support for GZIP and Zlib data. And unlike all of the above libraries, it uses ES Modules to allow for partial builds through tree shaking, meaning that it can rival even <code>tiny-inflate</code> in size while maintaining excellent performance. The end result is a library that, in total, weighs 8kB minified for the core build (3kB for decompression only and 5kB for compression only), is about 15% faster than <code>UZIP.js</code> or up to 60% faster than <code>pako</code>, and achieves the same or better compression ratio than the rest.</p>
<p>Before you decide that <code>fflate</code> is the end-all compression library, you should note that JavaScript simply cannot rival the performance of a native program. If you're only using Node.js, it's probably better to use the <a href="https://nodejs.org/api/zlib.html">native Zlib bindings</a>, which tend to offer the best performance. Though note that even against Zlib, <code>fflate</code> is only around 30% slower in decompression and 10% slower in compression, and can still achieve better compression ratios!</p>
<h1><a class="anchor" id="autotoc_md15432"></a>
What about <code>CompressionStream</code>?</h1>
<p>Like <code>fflate</code>, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API">Compression Streams API</a> provides DEFLATE, GZIP, and Zlib compression and decompression support. It's a good option if you'd like to compress or decompress data without installing any third-party libraries, and it wraps native Zlib bindings to achieve better performance than what most JavaScript programs can achieve.</p>
<p>However, browsers do not offer any native non-streaming compression API, and <code>CompressionStream</code> has surprisingly poor performance on data already loaded into memory; <code>fflate</code> tends to be faster even for files that are dozens of megabytes large. Similarly, <code>fflate</code> is much faster for files under a megabyte because it avoids marshalling overheads. Even when streaming hundreds of megabytes of data, the native API usually performs between 30% faster and 10% slower than <code>fflate</code>. And Compression Streams have many other disadvantages - no ability to control compression level, poor support for older browsers, no ZIP support, etc.</p>
<p>If you'd still prefer to depend upon a native browser API but want to support older browsers, you can use an <code>fflate</code>-based <a href="https://github.com/101arrowz/compression-streams-polyfill">Compression Streams ponyfill</a>.</p>
<h1><a class="anchor" id="autotoc_md15433"></a>
Browser support</h1>
<p><code>fflate</code> makes heavy use of typed arrays (<code>Uint8Array</code>, <code>Uint16Array</code>, etc.). Typed arrays can be polyfilled at the cost of performance, but the most recent browser that doesn't support them <a href="https://caniuse.com/typedarrays">is from 2011</a>, so I wouldn't bother.</p>
<p>The asynchronous APIs also use <code>Worker</code>, which is not supported in a few browsers (however, the vast majority of browsers that support typed arrays support <code>Worker</code>).</p>
<p>Other than that, <code>fflate</code> is completely ES3, meaning you probably won't even need a bundler to use it.</p>
<h1><a class="anchor" id="autotoc_md15434"></a>
Testing</h1>
<p>You can validate the performance of <code>fflate</code> with <code>npm test</code>. It validates that the module is working as expected, ensures the outputs are no more than 5% larger than competitors at max compression, and outputs performance metrics to <code>test/results</code>.</p>
<p>Note that the time it takes for the CLI to show the completion of each test is not representative of the time each package took, so please check the JSON output if you want accurate measurements.</p>
<h1><a class="anchor" id="autotoc_md15435"></a>
License</h1>
<p>This software is <a href="./LICENSE">MIT Licensed</a>, with special exemptions for projects and organizations as noted below:</p>
<ul>
<li><a href="https://github.com/SheetJS/">SheetJS</a> is exempt from MIT licensing and may license any source code from this software under the BSD Zero Clause License </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_659b8a9d70a61e2b6195c42f9fd52df8.html">fflate</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
