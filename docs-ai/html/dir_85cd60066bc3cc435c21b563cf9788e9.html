<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gradiant Ascent: node_modules/bfj Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Gradiant Ascent
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_85cd60066bc3cc435c21b563cf9788e9.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">bfj Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://gitlab.com/philbooth/bfj/pipelines"><img src="https://gitlab.com/philbooth/bfj/badges/master/pipeline.svg" alt="Build status" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/bfj"><img src="https://img.shields.io/npm/v/bfj.svg" alt="Package status" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/bfj"><img src="https://img.shields.io/npm/dm/bfj.svg" alt="Downloads" style="pointer-events: none;" class="inline"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/bfj.svg" alt="License" style="pointer-events: none;" class="inline"/></a></p>
<p>Big-Friendly JSON. Asynchronous streaming functions for large JSON data sets.</p>
<ul>
<li>Why would I want those?</li>
<li>Is it fast?</li>
<li>What functions does it implement?</li>
<li>How do I install it?</li>
<li>How do I read a JSON file?</li>
<li>How do I parse a stream of JSON?</li>
<li>How do I selectively parse individual items from a JSON stream?</li>
<li>How do I write a JSON file?</li>
<li>How do I create a stream of JSON?</li>
<li>How do I create a JSON string?</li>
<li>What other methods are there?<ul>
<li>bfj.walk (stream, options)</li>
<li>bfj.eventify (data, options)</li>
</ul>
</li>
<li>What options can I specify?<ul>
<li>Options for parsing functions</li>
<li>Options for serialisation functions</li>
</ul>
</li>
<li>Is it possible to pause parsing or serialisation from calling code?</li>
<li>Can it handle newline-delimited JSON (NDJSON)?</li>
<li>Why does it default to bluebird promises?</li>
<li>Can I specify a different promise implementation?</li>
<li>Is there a change log?</li>
<li>How do I set up the dev environment?</li>
<li>What versions of Node.js does it support?</li>
<li>What license is it released under?</li>
</ul>
<h1><a class="anchor" id="autotoc_md9301"></a>
Why would I want those?</h1>
<p>If you need to parse huge JSON strings or stringify huge JavaScript data sets, it monopolises the event loop and can lead to out-of-memory exceptions. BFJ implements asynchronous functions and uses pre-allocated fixed-length arrays to try and alleviate those issues.</p>
<h1><a class="anchor" id="autotoc_md9302"></a>
Is it fast?</h1>
<p>No.</p>
<p>BFJ yields frequently to avoid monopolising the event loop, interrupting its own execution to let other event handlers run. The frequency of those yields can be controlled with the `yieldRate` option, but fundamentally it is not designed for speed.</p>
<p>Furthermore, when serialising data to a stream, BFJ uses a fixed-length buffer to avoid exhausting available memory. Whenever that buffer is full, serialisation is paused until the receiving stream processes some more data, regardless of the value of <code>yieldRate</code>. You can control the size of the buffer using the `bufferLength` option but really, if you need quick results, BFJ is not for you.</p>
<h1><a class="anchor" id="autotoc_md9303"></a>
What functions does it implement?</h1>
<p>Nine functions are exported.</p>
<p>Five are concerned with parsing, or turning JSON strings into JavaScript data:</p>
<ul>
<li>`read` asynchronously parses a JSON file from disk.</li>
<li>`parse` and `unpipe` are for asynchronously parsing streams of JSON.</li>
<li>`match` selectively parses individual items from a JSON stream.</li>
<li>`walk` asynchronously walks a stream, emitting events as it encounters JSON tokens. Analagous to a <a href="http://en.wikipedia.org/wiki/Simple_API_for_XML">SAX parser</a>.</li>
</ul>
<p>The other four functions handle the reverse transformations, serialising JavaScript data to JSON:</p>
<ul>
<li>`write` asynchronously serialises data to a JSON file on disk.</li>
<li>`streamify` asynchronously serialises data to a stream of JSON.</li>
<li>`stringify` asynchronously serialises data to a JSON string.</li>
<li>`eventify` asynchronously traverses a data structure depth-first, emitting events as it encounters items. By default it coerces promises, buffers and iterables to JSON-friendly values.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9304"></a>
How do I install it?</h1>
<p>If you're using npm:</p>
<div class="fragment"><div class="line">npm i bfj --save</div>
</div><!-- fragment --><p>Or if you just want the git repo:</p>
<div class="fragment"><div class="line">git clone git@gitlab.com:philbooth/bfj.git</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9305"></a>
How do I read a JSON file?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">bfj.read(path, options)</div>
<div class="line">  .then(data =&gt; {</div>
<div class="line">    // :)</div>
<div class="line">  })</div>
<div class="line">  .catch(error =&gt; {</div>
<div class="line">    // :(</div>
<div class="line">  });</div>
</div><!-- fragment --><p><code>read</code> returns a <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird promise</a> and asynchronously parses a JSON file from disk.</p>
<p>It takes two arguments; the path to the JSON file and an options object.</p>
<p>If there are no syntax errors, the returned promise is resolved with the parsed data. If syntax errors occur, the promise is rejected with the first error.</p>
<h1><a class="anchor" id="autotoc_md9306"></a>
How do I parse a stream of JSON?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">// By passing a readable stream to bfj.parse():</div>
<div class="line">bfj.parse(fs.createReadStream(path), options)</div>
<div class="line">  .then(data =&gt; {</div>
<div class="line">    // :)</div>
<div class="line">  })</div>
<div class="line">  .catch(error =&gt; {</div>
<div class="line">    // :(</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">// ...or by passing the result from bfj.unpipe() to stream.pipe():</div>
<div class="line">request({ url }).pipe(bfj.unpipe((error, data) =&gt; {</div>
<div class="line">  if (error) {</div>
<div class="line">    // :(</div>
<div class="line">  } else {</div>
<div class="line">    // :)</div>
<div class="line">  }</div>
<div class="line">}))</div>
</div><!-- fragment --><ul>
<li><p class="startli"><code>parse</code> returns a <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird promise</a> and asynchronously parses a stream of JSON data.</p>
<p class="startli">It takes two arguments; a <a href="https://nodejs.org/api/stream.html#stream_readable_streams">readable stream</a> from which the JSON will be parsed and an options object.</p>
<p class="startli">If there are no syntax errors, the returned promise is resolved with the parsed data. If syntax errors occur, the promise is rejected with the first error.</p>
</li>
<li><p class="startli"><code>unpipe</code> returns a <a href="https://nodejs.org/api/stream.html#stream_writable_streams">writable stream</a> that can be passed to <a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options"><code>stream.pipe</code></a>, then parses JSON data read from the stream.</p>
<p class="startli">It takes two arguments; a callback function that will be called after parsing is complete and an options object.</p>
<p class="startli">If there are no errors, the callback is invoked with the result as the second argument. If errors occur, the first error is passed the callback as the first argument.</p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md9307"></a>
How do I selectively parse individual items from a JSON stream?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">// Call match with your stream and a selector predicate/regex/JSONPath/string</div>
<div class="line">const dataStream = bfj.match(jsonStream, selector, options);</div>
<div class="line"> </div>
<div class="line">// Get data out of the returned stream with event handlers</div>
<div class="line">dataStream.on(&#39;data&#39;, item =&gt; { /* ... */ });</div>
<div class="line">dataStream.on(&#39;end&#39;, () =&gt; { /* ... */);</div>
<div class="line">dataStream.on(&#39;error&#39;, () =&gt; { /* ... */);</div>
<div class="line">dataStream.on(&#39;dataError&#39;, () =&gt; { /* ... */);</div>
<div class="line"> </div>
<div class="line">// ...or you can pipe it to another stream</div>
<div class="line">dataStream.pipe(someOtherStream);</div>
</div><!-- fragment --><p><code>match</code> returns a readable, object-mode stream and asynchronously parses individual matching items from an input JSON stream.</p>
<p>It takes three arguments: a <a href="https://nodejs.org/api/stream.html#stream_readable_streams">readable stream</a> from which the JSON will be parsed; a selector argument for determining matches, which may be a string, a regular expression, a JSONPath expression, or a predicate function; and an options object.</p>
<p>If the selector is a string, it will be compared to property keys to determine whether each item in the data is a match. If it is a regular expression, the comparison will be made by calling the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">RegExp <code>test</code> method</a> with the property key. If it is a JSONPath expression, it must start with <code>$.</code> to identify the root node and only use <code>child</code> scope expressions for subsequent nodes. Predicate functions will be called with three arguments: <code>key</code>, <code>value</code> and <code>depth</code>. If the result of the predicate is a truthy value then the item will be deemed a match.</p>
<p>In addition to the regular options accepted by other parsing functions, you can also specify <code>minDepth</code> to only apply the selector to certain depths. This can improve performance and memory usage, if you know that you're not interested in parsing top-level items.</p>
<p>If there are any syntax errors in the JSON, a <code>dataError</code> event will be emitted. If any other errors occur, an <code>error</code> event will be emitted.</p>
<h1><a class="anchor" id="autotoc_md9308"></a>
How do I write a JSON file?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">bfj.write(path, data, options)</div>
<div class="line">  .then(() =&gt; {</div>
<div class="line">    // :)</div>
<div class="line">  })</div>
<div class="line">  .catch(error =&gt; {</div>
<div class="line">    // :(</div>
<div class="line">  });</div>
</div><!-- fragment --><p><code>write</code> returns a <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird promise</a> and asynchronously serialises a data structure to a JSON file on disk. The promise is resolved when the file has been written, or rejected with the error if writing failed.</p>
<p>It takes three arguments; the path to the JSON file, the data structure to serialise and an options object.</p>
<h1><a class="anchor" id="autotoc_md9309"></a>
How do I create a stream of JSON?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">const stream = bfj.streamify(data, options);</div>
<div class="line"> </div>
<div class="line">// Get data out of the stream with event handlers</div>
<div class="line">stream.on(&#39;data&#39;, chunk =&gt; { /* ... */ });</div>
<div class="line">stream.on(&#39;end&#39;, () =&gt; { /* ... */);</div>
<div class="line">stream.on(&#39;error&#39;, () =&gt; { /* ... */);</div>
<div class="line">stream.on(&#39;dataError&#39;, () =&gt; { /* ... */);</div>
<div class="line"> </div>
<div class="line">// ...or you can pipe it to another stream</div>
<div class="line">stream.pipe(someOtherStream);</div>
</div><!-- fragment --><p><code>streamify</code> returns a <a href="https://nodejs.org/api/stream.html#stream_readable_streams">readable stream</a> and asynchronously serialises a data structure to JSON, pushing the result to the returned stream.</p>
<p>It takes two arguments; the data structure to serialise and an options object.</p>
<p>If there a circular reference is encountered in the data and <code>options.circular</code> is not set to &lsquo;'ignore&rsquo;<code>, a</code>dataError<code>event will be emitted. If any other errors occur, an</code>error` event will be emitted.</p>
<h1><a class="anchor" id="autotoc_md9310"></a>
How do I create a JSON string?</h1>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">bfj.stringify(data, options)</div>
<div class="line">  .then(json =&gt; {</div>
<div class="line">    // :)</div>
<div class="line">  })</div>
<div class="line">  .catch(error =&gt; {</div>
<div class="line">    // :(</div>
<div class="line">  });</div>
</div><!-- fragment --><p><code>stringify</code> returns a <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird promise</a> and asynchronously serialises a data structure to a JSON string. The promise is resolved to the JSON string when serialisation is complete.</p>
<p>It takes two arguments; the data structure to serialise and an options object.</p>
<h1><a class="anchor" id="autotoc_md9311"></a>
What other methods are there?</h1>
<h2><a class="anchor" id="autotoc_md9312"></a>
bfj.walk (stream, options)</h2>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = bfj.walk(fs.createReadStream(path), options);</div>
<div class="line"> </div>
<div class="line">emitter.on(bfj.events.array, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.object, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.property, name =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.string, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.number, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.literal, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.endArray, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.endObject, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.error, error =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.dataError, error =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.end, () =&gt; { /* ... */ });</div>
</div><!-- fragment --><p><code>walk</code> returns an <a href="https://nodejs.org/api/events.html#events_class_eventemitter">event emitter</a> and asynchronously walks a stream of JSON data, emitting events as it encounters tokens.</p>
<p>It takes two arguments; a <a href="https://nodejs.org/api/stream.html#stream_readable_streams">readable stream</a> from which the JSON will be read and an options object.</p>
<p>The emitted events are defined as public properties of an object, <code>bfj.events</code>:</p>
<ul>
<li><code>bfj.events.array</code> indicates that an array context has been entered by encountering the <code>[</code> character.</li>
<li><code>bfj.events.endArray</code> indicates that an array context has been left by encountering the <code>]</code> character.</li>
<li><code>bfj.events.object</code> indicates that an object context has been entered by encountering the <code>{</code> character.</li>
<li><code>bfj.events.endObject</code> indicates that an object context has been left by encountering the <code>}</code> character.</li>
<li><code>bfj.events.property</code> indicates that a property has been encountered in an object. The listener will be passed the name of the property as its argument and the next event to be emitted will represent the property's value.</li>
<li><code>bfj.events.string</code> indicates that a string has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.number</code> indicates that a number has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.literal</code> indicates that a JSON literal (either <code>true</code>, <code>false</code> or <code>null</code>) has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.error</code> indicates that an error was caught from one of the event handlers in user code. The listener will be passed the <code>Error</code> instance as its argument.</li>
<li><code>bfj.events.dataError</code> indicates that a syntax error was encountered in the incoming JSON stream. The listener will be passed an <code>Error</code> instance decorated with <code>actual</code>, <code>expected</code>, <code>lineNumber</code> and <code>columnNumber</code> properties as its argument.</li>
<li><code>bfj.events.end</code> indicates that the end of the input has been reached and the stream is closed.</li>
<li><code>bfj.events.endLine</code> indicates that a root-level newline character has been encountered in an NDJSON stream. Only emitted if the <code>ndjson</code> option is set.</li>
</ul>
<p>If you are using <code>bfj.walk</code> to sequentially parse items in an array, you might also be interested in the <a href="https://github.com/hash-bang/bfj-collections">bfj-collections</a> module.</p>
<h2><a class="anchor" id="autotoc_md9313"></a>
bfj.eventify (data, options)</h2>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = bfj.eventify(data, options);</div>
<div class="line"> </div>
<div class="line">emitter.on(bfj.events.array, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.object, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.property, name =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.string, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.number, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.literal, value =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.endArray, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.endObject, () =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.error, error =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.dataError, error =&gt; { /* ... */ });</div>
<div class="line">emitter.on(bfj.events.end, () =&gt; { /* ... */ });</div>
</div><!-- fragment --><p><code>eventify</code> returns an <a href="https://nodejs.org/api/events.html#events_class_eventemitter">event emitter</a> and asynchronously traverses a data structure depth-first, emitting events as it encounters items. By default it coerces promises, buffers and iterables to JSON-friendly values.</p>
<p>It takes two arguments; the data structure to traverse and an options object.</p>
<p>The emitted events are defined as public properties of an object, <code>bfj.events</code>:</p>
<ul>
<li><code>bfj.events.array</code> indicates that an array has been encountered.</li>
<li><code>bfj.events.endArray</code> indicates that the end of an array has been encountered.</li>
<li><code>bfj.events.object</code> indicates that an object has been encountered.</li>
<li><code>bfj.events.endObject</code> indicates that the end of an object has been encountered.</li>
<li><code>bfj.events.property</code> indicates that a property has been encountered in an object. The listener will be passed the name of the property as its argument and the next event to be emitted will represent the property's value.</li>
<li><code>bfj.events.string</code> indicates that a string has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.number</code> indicates that a number has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.literal</code> indicates that a JSON literal (either <code>true</code>, <code>false</code> or <code>null</code>) has been encountered. The listener will be passed the value as its argument.</li>
<li><code>bfj.events.error</code> indicates that an error was caught from one of the event handlers in user code. The listener will be passed the <code>Error</code> instance as its argument.</li>
<li><code>bfj.events.dataError</code> indicates that a circular reference was encountered in the data and the <code>circular</code> option was not set to &lsquo;'ignore&rsquo;<code>. The listener will be passed an</code>Error` instance as its argument.</li>
<li><code>bfj.events.end</code> indicates that the end of the data has been reached and no further events will be emitted.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9314"></a>
What options can I specify?</h1>
<h2><a class="anchor" id="autotoc_md9315"></a>
Options for parsing functions</h2>
<ul>
<li><code>options.reviver</code>: Transformation function, invoked depth-first against the parsed data structure. This option is analagous to the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter">reviver parameter for JSON.parse</a>.</li>
<li><code>options.yieldRate</code>: The number of data items to process before yielding to the event loop. Smaller values yield to the event loop more frequently, meaning less time will be consumed by bfj per tick but the overall parsing time will be slower. Larger values yield to the event loop less often, meaning slower tick times but faster overall parsing time. The default value is <code>16384</code>.</li>
<li><code>options.Promise</code>: Promise constructor that will be used for promises returned by all methods. If you set this option, please be aware that some promise implementations (including native promises) may cause your process to die with out-of-memory exceptions. Defaults to <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird's implementation</a>, which does not have that problem.</li>
<li><code>options.ndjson</code>: If set to <code>true</code>, newline characters at the root level will be treated as delimiters between discrete chunks of JSON. See NDJSON for more information.</li>
<li><code>options.numbers</code>: For <code>bfj.match</code> only, set this to <code>true</code> if you wish to match against numbers with a string or regular expression <code>selector</code> argument.</li>
<li><code>options.bufferLength</code>: For <code>bfj.match</code> only, the length of the match buffer. Smaller values use less memory but may result in a slower parse time. The default value is <code>1024</code>.</li>
<li><code>options.highWaterMark</code>: For <code>bfj.match</code> only, set this if you would like to pass a value for the <code>highWaterMark</code> option to the readable stream constructor.</li>
</ul>
<h2><a class="anchor" id="autotoc_md9316"></a>
Options for serialisation functions</h2>
<ul>
<li><code>options.space</code>: Indentation string or the number of spaces to indent each nested level by. This option is analagous to the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_space_argument">space parameter for JSON.stringify</a>.</li>
<li><code>options.promises</code>: By default, promises are coerced to their resolved value. Set this property to &lsquo;'ignore&rsquo;` for improved performance if you don't need to coerce promises.</li>
<li><code>options.buffers</code>: By default, buffers are coerced using their <code>toString</code> method. Set this property to &lsquo;'ignore&rsquo;` for improved performance if you don't need to coerce buffers.</li>
<li><code>options.maps</code>: By default, maps are coerced to plain objects. Set this property to &lsquo;'ignore&rsquo;` for improved performance if you don't need to coerce maps.</li>
<li><code>options.iterables</code>: By default, other iterables (i.e. not arrays, strings or maps) are coerced to arrays. Set this property to &lsquo;'ignore&rsquo;` for improved performance if you don't need to coerce iterables.</li>
<li><code>options.circular</code>: By default, circular references will cause the write to fail. Set this property to &lsquo;'ignore&rsquo;` if you'd prefer to silently skip past circular references in the data.</li>
<li><code>options.bufferLength</code>: The length of the write buffer. Smaller values use less memory but may result in a slower serialisation time. The default value is <code>1024</code>.</li>
<li><code>options.highWaterMark</code>: Set this if you would like to pass a value for the <code>highWaterMark</code> option to the readable stream constructor.</li>
<li><code>options.yieldRate</code>: The number of data items to process before yielding to the event loop. Smaller values yield to the event loop more frequently, meaning less time will be consumed by bfj per tick but the overall serialisation time will be slower. Larger values yield to the event loop less often, meaning slower tick times but faster overall serialisation time. The default value is <code>16384</code>.</li>
<li><code>options.Promise</code>: Promise constructor that will be used for promises returned by all methods. If you set this option, please be aware that some promise implementations (including native promises) may cause your process to die with out-of-memory exceptions. Defaults to <a href="http://bluebirdjs.com/docs/api-reference.html">bluebird's implementation</a>, which does not have that problem.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9317"></a>
Is it possible to pause parsing or serialisation from calling code?</h1>
<p>Yes it is! Both `walk` and `eventify` decorate their returned event emitters with a <code>pause</code> method that will prevent any further events being emitted. The <code>pause</code> method itself returns a <code>resume</code> function that you can call to indicate that processing should continue.</p>
<p>For example:</p>
<div class="fragment"><div class="line">const bfj = require(&#39;bfj&#39;);</div>
<div class="line">const emitter = bfj.walk(fs.createReadStream(path), options);</div>
<div class="line"> </div>
<div class="line">// Later, when you want to pause parsing:</div>
<div class="line"> </div>
<div class="line">const resume = emitter.pause();</div>
<div class="line"> </div>
<div class="line">// Then when you want to resume:</div>
<div class="line"> </div>
<div class="line">resume();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9318"></a>
Can it handle <a href="http://ndjson.org/">newline-delimited JSON (NDJSON)</a>?</h1>
<p>Yes. If you pass the <code>ndjson</code> option to <code>bfj.walk</code>, <code>bfj.match</code> or <code>bfj.parse</code>, newline characters at the root level will act as delimiters between discrete JSON values:</p>
<ul>
<li><code>bfj.walk</code> will emit a <code>bfj.events.endLine</code> event each time it encounters a newline character.</li>
<li><code>bfj.match</code> will just ignore the newlines while it continues looking for matching items.</li>
<li><code>bfj.parse</code> will resolve with the first value and pause the underlying stream. If it's called again with the same stream, it will resume processing and resolve with the second value. To parse the entire stream, calls should be made sequentially one-at-a-time until the returned promise resolves to <code>undefined</code> (<code>undefined</code> is not a valid JSON token).</li>
</ul>
<p><code>bfj.unpipe</code> and <code>bfj.read</code> will not parse NDJSON.</p>
<h1><a class="anchor" id="autotoc_md9319"></a>
Why does it default to bluebird promises?</h1>
<p>Until version <code>4.2.4</code>, native promises were used. But they were found to cause out-of-memory errors when serialising large amounts of data to JSON, due to <a href="https://alexn.org/blog/2017/10/11/javascript-promise-leaks-memory.html">well-documented problems with the native promise implementation</a>. So in version <code>5.0.0</code>, bluebird promises were used instead. In version <code>5.1.0</code>, an option was added that enables callers to specify the promise constructor to use. Use it at your own risk.</p>
<h1><a class="anchor" id="autotoc_md9320"></a>
Can I specify a different promise implementation?</h1>
<p>Yes. Just pass the <code>Promise</code> option to any method. If you get out-of-memory errors when using that option, consider changing your promise implementation.</p>
<h1><a class="anchor" id="autotoc_md9321"></a>
Is there a change log?</h1>
<p><a class="el" href="md_node__modules_2bfj_2_h_i_s_t_o_r_y.html">Yes</a>.</p>
<h1><a class="anchor" id="autotoc_md9322"></a>
How do I set up the dev environment?</h1>
<p>The development environment relies on <a href="https://nodejs.org/en/">Node.js</a>, <a href="http://eslint.org/">ESLint</a>, <a href="https://mochajs.org/">Mocha</a>, <a href="http://chaijs.com/">Chai</a>, <a href="https://github.com/thlorenz/proxyquire">Proxyquire</a> and <a href="https://gitlab.com/philbooth/spooks.js">Spooks</a>. Assuming that you already have node and NPM set up, you just need to run <code>npm install</code> to install all of the dependencies as listed in <code>package.json</code>.</p>
<p>You can lint the code with the command <code>npm run lint</code>.</p>
<p>You can run the tests with the command <code>npm test</code>.</p>
<h1><a class="anchor" id="autotoc_md9323"></a>
What versions of Node.js does it support?</h1>
<p>As of <a href="HISTORY.md#700">version <code>7.0.0</code></a>, only Node.js versions 8 or greater are supported.</p>
<p>Between versions <a href="HISTORY.md#300"><code>3.0.0</code></a> and <a href="HISTORY.md#612"><code>6.1.2</code></a>, only Node.js versions 6 or greater were supported.</p>
<p>Until <a href="HISTORY.md#212">version <code>2.1.2</code></a>, only Node.js versions 4 or greater were supported.</p>
<h1><a class="anchor" id="autotoc_md9324"></a>
What license is it released under?</h1>
<p>[MIT][license]. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_acd06b18086a0dd2ae699b1e0b775be8.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_85cd60066bc3cc435c21b563cf9788e9.html">bfj</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
