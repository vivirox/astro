#!/usr/bin/env ts-node

/**
 * AI Web Vulnerability Scanner
 *
 * This script tests AI components for common web vulnerabilities including:
 * - Cross-Site Scripting (XSS)
 * - SQL Injection
 * - Cross-Site Request Forgery (CSRF)
 * - Server-Side Request Forgery (SSRF)
 * - Insecure Direct Object References (IDOR)
 * - Rate Limiting Bypass
 * - Information Disclosure
 * - HTTP Security Headers
 * - Content Security Policy
 * - CORS Misconfigurations
 */

import fs from 'fs'
import path from 'path'
import axios from 'axios'
import type { AxiosRequestConfig } from 'axios'
import { performance } from 'perf_hooks'

// Configuration
interface Config {
  baseUrl: string
  outputDir: string
  requestDelay: number
  testTimeout: number
  verbose: boolean
  authToken: string
  adminToken: string
}

interface TestResult {
  testName: string
  category: string
  severity: 'Critical' | 'High' | 'Medium' | 'Low' | 'Informational'
  vulnerable: boolean
  details: string
  evidence?: string
  responseTime: number
  timestamp: string
}

interface TestRequest extends Omit<AxiosRequestConfig, 'validateStatus'> {
  method: string
  url: string
  headers: Record<string, string>
  data?: any
}

interface ErrorTest {
  name: string
  request: TestRequest
}

// Default configuration
const config: Config = {
  baseUrl: 'http://localhost:3000',
  outputDir: path.join(process.cwd(), 'security-reports'),
  requestDelay: 500,
  testTimeout: 10000,
  verbose: true,
  authToken: 'user-token',
  adminToken: 'admin-token',
}

// Ensure output directory exists
if (!fs.existsSync(config.outputDir)) {
  fs.mkdirSync(config.outputDir, { recursive: true })
}

// Create report file
const reportFile = path.join(
  config.outputDir,
  `ai-web-vulnerability-scan-${new Date().toISOString().split('T')[0]}.json`
)
const reportStream = fs.createWriteStream(reportFile)

/**
 * Write to report file
 */
function writeReport(results: TestResult[]) {
  reportStream.write(JSON.stringify(results, null, 2))
  reportStream.end()

  console.log(`\nScan complete. Report saved to: ${reportFile}`)

  // Print summary
  const total = results.length
  const vulnerable = results.filter((r) => r.vulnerable).length
  const safe = total - vulnerable

  console.log(`\nSummary:`)
  console.log(`- Total tests: ${total}`)
  console.log(`- Vulnerable: ${vulnerable}`)
  console.log(`- Safe: ${safe}`)

  if (vulnerable > 0) {
    console.log(`\nVulnerabilities found:`)

    // Group by severity
    const severities = ['Critical', 'High', 'Medium', 'Low', 'Informational']

    for (const severity of severities) {
      const vulns = results.filter(
        (r) => r.vulnerable && r.severity === severity
      )

      if (vulns.length > 0) {
        console.log(`\n${severity} severity (${vulns.length}):`)

        vulns.forEach((vuln) => {
          console.log(`- ${vuln.testName}: ${vuln.details}`)
        })
      }
    }
  }
}

/**
 * Log message if verbose mode is enabled
 */
function log(message: string) {
  if (config.verbose) {
    console.log(message)
  }
}

/**
 * Test for missing security headers
 */
async function testSecurityHeaders(): Promise<TestResult[]> {
  log('Testing for missing security headers...')

  const results: TestResult[] = []
  const startTime = performance.now()

  try {
    const response = await axios({
      method: 'GET',
      url: `${config.baseUrl}/api/ai/completion`,
      headers: {
        Authorization: `Bearer ${config.authToken}`,
      },
      timeout: config.testTimeout,
      validateStatus: () => true,
    })

    const headers = response.headers

    // Check for Content-Security-Policy
    results.push({
      testName: 'Content-Security-Policy Header',
      category: 'Security Headers',
      severity: 'High',
      vulnerable: !headers['content-security-policy'],
      details: headers['content-security-policy']
        ? 'CSP header is present'
        : 'CSP header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for X-Frame-Options
    results.push({
      testName: 'X-Frame-Options Header',
      category: 'Security Headers',
      severity: 'Medium',
      vulnerable: !headers['x-frame-options'],
      details: headers['x-frame-options']
        ? 'X-Frame-Options header is present'
        : 'X-Frame-Options header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for X-Content-Type-Options
    results.push({
      testName: 'X-Content-Type-Options Header',
      category: 'Security Headers',
      severity: 'Medium',
      vulnerable: !headers['x-content-type-options'],
      details: headers['x-content-type-options']
        ? 'X-Content-Type-Options header is present'
        : 'X-Content-Type-Options header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for X-XSS-Protection
    results.push({
      testName: 'X-XSS-Protection Header',
      category: 'Security Headers',
      severity: 'Medium',
      vulnerable: !headers['x-xss-protection'],
      details: headers['x-xss-protection']
        ? 'X-XSS-Protection header is present'
        : 'X-XSS-Protection header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for Strict-Transport-Security
    results.push({
      testName: 'Strict-Transport-Security Header',
      category: 'Security Headers',
      severity: 'High',
      vulnerable: !headers['strict-transport-security'],
      details: headers['strict-transport-security']
        ? 'HSTS header is present'
        : 'HSTS header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for Referrer-Policy
    results.push({
      testName: 'Referrer-Policy Header',
      category: 'Security Headers',
      severity: 'Medium',
      vulnerable: !headers['referrer-policy'],
      details: headers['referrer-policy']
        ? 'Referrer-Policy header is present'
        : 'Referrer-Policy header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })

    // Check for Permissions-Policy
    results.push({
      testName: 'Permissions-Policy Header',
      category: 'Security Headers',
      severity: 'Medium',
      vulnerable: !headers['permissions-policy'],
      details: headers['permissions-policy']
        ? 'Permissions-Policy header is present'
        : 'Permissions-Policy header is missing',
      evidence: JSON.stringify(headers),
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    results.push({
      testName: 'Security Headers Test',
      category: 'Security Headers',
      severity: 'High',
      vulnerable: true,
      details: `Error testing security headers: ${error instanceof Error ? error.message : 'Unknown error'}`,
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })
  }

  return results
}

/**
 * Test for CORS misconfigurations
 */
async function testCORSMisconfigurations(): Promise<TestResult[]> {
  log('Testing for CORS misconfigurations...')

  const results: TestResult[] = []
  const startTime = performance.now()

  try {
    // Test with various origins
    const origins = [
      'http://evil.com',
      'http://localhost:4000',
      'null',
      '*',
      'http://subdomain.yourdomain.com',
      'https://evil.com',
    ]

    for (const origin of origins) {
      const response = await axios({
        method: 'OPTIONS',
        url: `${config.baseUrl}/api/ai/completion`,
        headers: {
          'Origin': origin,
          'Access-Control-Request-Method': 'POST',
          'Access-Control-Request-Headers': 'Content-Type, Authorization',
        },
        timeout: config.testTimeout,
        validateStatus: () => true,
      })

      const corsHeaders = {
        'access-control-allow-origin':
          response.headers['access-control-allow-origin'],
        'access-control-allow-methods':
          response.headers['access-control-allow-methods'],
        'access-control-allow-headers':
          response.headers['access-control-allow-headers'],
        'access-control-allow-credentials':
          response.headers['access-control-allow-credentials'],
      }

      // Check if the origin is allowed
      const isAllowed =
        corsHeaders['access-control-allow-origin'] === origin ||
        corsHeaders['access-control-allow-origin'] === '*'

      if (isAllowed) {
        results.push({
          testName: `CORS Origin Test (${origin})`,
          category: 'CORS',
          severity: 'High',
          vulnerable: true,
          details: `Server allows requests from potentially dangerous origin: ${origin}`,
          evidence: JSON.stringify(corsHeaders),
          responseTime: performance.now() - startTime,
          timestamp: new Date().toISOString(),
        })
      }

      // Check if credentials are allowed with wildcard origin
      if (
        corsHeaders['access-control-allow-origin'] === '*' &&
        corsHeaders['access-control-allow-credentials'] === 'true'
      ) {
        results.push({
          testName: 'CORS Credentials with Wildcard',
          category: 'CORS',
          severity: 'Critical',
          vulnerable: true,
          details: 'Server allows credentials with wildcard origin',
          evidence: JSON.stringify(corsHeaders),
          responseTime: performance.now() - startTime,
          timestamp: new Date().toISOString(),
        })
      }

      // Check for overly permissive methods
      if (corsHeaders['access-control-allow-methods']?.includes('*')) {
        results.push({
          testName: 'CORS Methods',
          category: 'CORS',
          severity: 'High',
          vulnerable: true,
          details: 'Server allows all HTTP methods',
          evidence: JSON.stringify(corsHeaders),
          responseTime: performance.now() - startTime,
          timestamp: new Date().toISOString(),
        })
      }

      // Check for overly permissive headers
      if (corsHeaders['access-control-allow-headers']?.includes('*')) {
        results.push({
          testName: 'CORS Headers',
          category: 'CORS',
          severity: 'Medium',
          vulnerable: true,
          details: 'Server allows all request headers',
          evidence: JSON.stringify(corsHeaders),
          responseTime: performance.now() - startTime,
          timestamp: new Date().toISOString(),
        })
      }
    }
  } catch (error) {
    results.push({
      testName: 'CORS Test',
      category: 'CORS',
      severity: 'High',
      vulnerable: true,
      details: `Error testing CORS: ${error instanceof Error ? error.message : 'Unknown error'}`,
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })
  }

  return results
}

/**
 * Test for information disclosure
 */
async function testInformationDisclosure(): Promise<TestResult[]> {
  log('Testing for information disclosure...')

  const results: TestResult[] = []
  const startTime = performance.now()

  try {
    // Test error responses for sensitive information
    const errorTests: ErrorTest[] = [
      {
        name: 'Invalid JSON',
        request: {
          method: 'POST',
          url: `${config.baseUrl}/api/ai/completion`,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.authToken}`,
          },
          data: 'invalid json{',
        },
      },
      {
        name: 'Invalid Token',
        request: {
          method: 'GET',
          url: `${config.baseUrl}/api/ai/usage`,
          headers: {
            Authorization: 'Bearer invalid-token',
          },
        },
      },
      {
        name: 'Server Error',
        request: {
          method: 'POST',
          url: `${config.baseUrl}/api/ai/completion`,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.authToken}`,
          },
          data: {
            messages: [{ role: 'user', content: 'A'.repeat(1000000) }],
            model: 'together-ai-model',
          },
        },
      },
    ]

    for (const test of errorTests) {
      try {
        const axiosConfig: AxiosRequestConfig = {
          ...test.request,
          timeout: config.testTimeout,
          validateStatus: () => true,
        }

        const response = await axios(axiosConfig)

        const responseData = JSON.stringify(response.data)

        // Check for stack traces
        if (responseData.includes('at ') && responseData.includes('.js:')) {
          results.push({
            testName: `Stack Trace Disclosure (${test.name})`,
            category: 'Information Disclosure',
            severity: 'High',
            vulnerable: true,
            details: 'Error response contains stack trace',
            evidence: responseData,
            responseTime: performance.now() - startTime,
            timestamp: new Date().toISOString(),
          })
        }

        // Check for file paths
        if (responseData.match(/[/\\][\w-]+[/\\][\w-]+/)) {
          results.push({
            testName: `File Path Disclosure (${test.name})`,
            category: 'Information Disclosure',
            severity: 'Medium',
            vulnerable: true,
            details: 'Error response contains file paths',
            evidence: responseData,
            responseTime: performance.now() - startTime,
            timestamp: new Date().toISOString(),
          })
        }

        // Check for internal IPs
        if (
          responseData.match(
            /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/
          )
        ) {
          results.push({
            testName: `IP Address Disclosure (${test.name})`,
            category: 'Information Disclosure',
            severity: 'Medium',
            vulnerable: true,
            details: 'Error response contains IP addresses',
            evidence: responseData,
            responseTime: performance.now() - startTime,
            timestamp: new Date().toISOString(),
          })
        }

        // Check for database errors
        if (
          responseData.toLowerCase().includes('sql') ||
          responseData.toLowerCase().includes('database') ||
          responseData.toLowerCase().includes('postgres')
        ) {
          results.push({
            testName: `Database Error Disclosure (${test.name})`,
            category: 'Information Disclosure',
            severity: 'High',
            vulnerable: true,
            details: 'Error response contains database information',
            evidence: responseData,
            responseTime: performance.now() - startTime,
            timestamp: new Date().toISOString(),
          })
        }
      } catch (error) {
        // Ignore test errors
      }
    }

    // Check response headers for sensitive information
    const response = await axios({
      method: 'GET',
      url: `${config.baseUrl}/api/ai/completion`,
      timeout: config.testTimeout,
      validateStatus: () => true,
    })

    const headers = response.headers

    // Check for server software disclosure
    if (headers['server']) {
      results.push({
        testName: 'Server Header Disclosure',
        category: 'Information Disclosure',
        severity: 'Low',
        vulnerable: true,
        details: 'Server header reveals software information',
        evidence: headers['server'],
        responseTime: performance.now() - startTime,
        timestamp: new Date().toISOString(),
      })
    }

    // Check for technology stack disclosure
    if (headers['x-powered-by']) {
      results.push({
        testName: 'X-Powered-By Disclosure',
        category: 'Information Disclosure',
        severity: 'Low',
        vulnerable: true,
        details: 'X-Powered-By header reveals technology stack',
        evidence: headers['x-powered-by'],
        responseTime: performance.now() - startTime,
        timestamp: new Date().toISOString(),
      })
    }
  } catch (error) {
    results.push({
      testName: 'Information Disclosure Test',
      category: 'Information Disclosure',
      severity: 'High',
      vulnerable: true,
      details: `Error testing information disclosure: ${error instanceof Error ? error.message : 'Unknown error'}`,
      responseTime: performance.now() - startTime,
      timestamp: new Date().toISOString(),
    })
  }

  return results
}

/**
 * Run all tests
 */
async function runTests() {
  console.log('Starting AI web vulnerability scan...')

  const results: TestResult[] = []

  // Test security headers
  console.log('\nTesting security headers...')
  results.push(...(await testSecurityHeaders()))
  await new Promise((resolve) => setTimeout(resolve, config.requestDelay))

  // Test CORS misconfigurations
  console.log('\nTesting CORS misconfigurations...')
  results.push(...(await testCORSMisconfigurations()))
  await new Promise((resolve) => setTimeout(resolve, config.requestDelay))

  // Test information disclosure
  console.log('\nTesting information disclosure...')
  results.push(...(await testInformationDisclosure()))

  writeReport(results)
}

// Run tests
runTests().catch((error) => {
  console.error('Error running web vulnerability scan:', error)
  process.exit(1)
})
